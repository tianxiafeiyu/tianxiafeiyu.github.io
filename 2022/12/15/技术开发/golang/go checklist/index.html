<!DOCTYPE html>
<html lang=zh>
<head>
    <meta name="referrer" content="never">
    <meta charset="utf-8">
    
    <title>go checklist | Dalin blog</title>
    
    
        <meta name="keywords" content="go checklist" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="go checklist2. 介绍本文档参考开源(Urber)编码规范整理，记录 Go 代码中的惯用约定、规范，其中许多是 Go 语言的通用准则，期望通过引入业界最佳实践来提升团队编码能力，规范编码习惯，提高代码质量。 其他扩展准则依赖于下面外部的指南：  Effective Go Go Common Mistakes Go Code Review Comments  3. 规范实施方法本规范作为">
<meta property="og:type" content="article">
<meta property="og:title" content="go checklist">
<meta property="og:url" content="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%20checklist/index.html">
<meta property="og:site_name" content="Dalin blog">
<meta property="og:description" content="go checklist2. 介绍本文档参考开源(Urber)编码规范整理，记录 Go 代码中的惯用约定、规范，其中许多是 Go 语言的通用准则，期望通过引入业界最佳实践来提升团队编码能力，规范编码习惯，提高代码质量。 其他扩展准则依赖于下面外部的指南：  Effective Go Go Common Mistakes Go Code Review Comments  3. 规范实施方法本规范作为">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-15T23:13:57.000Z">
<meta property="article:modified_time" content="2022-12-16T21:36:16.000Z">
<meta property="article:author" content="Dalin">
<meta property="article:tag" content="go checklist">
<meta name="twitter:card" content="summary">
    

    

    
        <link rel="icon" href="/static/lin.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Dalin blog" type="application/atom+xml">
</head>

<body>
    <div id="container">
        <header id="header" style="z-index:999">
  <div id="header-main" class="header-inner">
    <div class="header-outer">
      <a href="/" id="logo">
        <i class="logo"></i>
        <span class="site-title">Dalin blog</span>
      </a>
      <nav id="main-nav">
        
        <a class="main-nav-link " href="/archives">归档</a>
        
        <a class="main-nav-link " href="/categories">分类</a>
        
        <a class="main-nav-link " href="/tags">标签</a>
        
        <a class="main-nav-link " href="/about">关于</a>
        
      </nav>
      
      <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
      <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>
<script>
  (function(window) {
    var INSIGHT_CONFIG = {
      TRANSLATION: {
        POSTS: '文章',
        PAGES: '页面',
        CATEGORIES: '分类',
        TAGS: '标签',
        UNTITLED: '(未命名)',
      },
      ROOT_URL: '/',
      CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
  })(window);
</script>

<script src="/js/insight.js"></script>


</div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
        
        <td><a class="main-nav-link" href="/archives">归档</a></td>
        
        <td><a class="main-nav-link" href="/categories">分类</a></td>
        
        <td><a class="main-nav-link" href="/tags">标签</a></td>
        
        <td><a class="main-nav-link" href="/about">关于</a></td>
        
        <td>
          
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

        </td>
      </tr>
    </table>
  </div>
</header>
        <div class="outer">
            
            
                <aside id="sidebar">
   
        
<div class="widget-wrap" id='categories'>
  <h3 class="widget-title">
    <span></span>
    <a id='allExpand' href="#">
      <i class="fa fa-angle-double-down fa-2x"></i>
    </a>
  </h3>

  
  
  
  <ul class="unstyled" id="tree" > 
    <li class="directory open">
      <a href="#" data-role="directory">
        技术开发
        &nbsp;
        <i class="fa fa-pull-right fa-angle-down" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="directory">
      <a href="#" data-role="directory">
        database
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="directory">
      <a href="#" data-role="directory">
        es
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E5%AD%A6%E4%B9%A0/">
        
        Elasticsearch学习
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%20Java%20Rest%20Client/">
        
        Elasticsearch Java Rest Client
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/">
        
        Elasticsearch版本特性
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="file">
      <a href="/2023/06/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E4%B8%AD%E7%9A%84NULL%E5%80%BC%E8%A7%A3%E6%9E%90/">
        
        mysql中的NULL值解析
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/">
        
        mysql常用函数汇总
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/">
        
        mysql联合索引
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E8%84%8F%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/">
        
        数据库之脏读、幻读、不可重复读
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E3%80%81redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/">
        
        mysql、redis开启远程访问
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory open">
      <a href="#" data-role="directory">
        golang
        &nbsp;
        <i class="fa fa-pull-right fa-angle-down" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/Golang%E4%B8%8EJava/">
        
        Golang与Java
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/golang%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/">
        
        golang学习大纲
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">
        
        go流程控制
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%E9%A1%B9%E7%9B%AE%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80/">
        
        go项目标准布局
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/http%20client%E6%9C%80%E4%BC%98%E9%85%8D%E7%BD%AE/">
        
        http client最优配置
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/%E4%BC%98%E7%A7%80golang%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
        
        优秀golang开源项目
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%20ast/">
        
        go ast
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%20csp%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/">
        
        go csp并发模型
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%20gc/">
        
        go gc
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/xorm%E4%BD%BF%E7%94%A8/">
        
        xorm使用
        
      </a>
    </li> 
    <li class="file active">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/go%20checklist/">
        
        go checklist
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/golang/%E4%B8%BA%E4%BB%80%E4%B9%88bk-cmdb%E4%B8%8D%E7%94%A8go%20mod%E7%AE%A1%E7%90%86/">
        
        为什么bk-cmdb不用go mod管理
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        grocery
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/30/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/">
        
        cpu加压脚本
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Chrome%E5%B9%B4%E5%BA%A6%E7%83%AD%E9%97%A8%20%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/">
        
        Chrome年度热门扩展程序
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/">
        
        Prometheus监控kubernetes方案及实现
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/websocket%E5%AD%A6%E4%B9%A0/">
        
        websocket学习
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/">
        
        交换机端口标识含义
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">
        
        基于etcd实现的分布式锁
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/">
        
        数据结构与算法---常见算法减治、分治、递归、迭代、回溯、动态规划、贪心的基本思想
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/">
        
        火焰图怎么看
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/">
        
        NaN代表什么意思
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/jsonpath%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">
        
        jsonpath使用心得
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/">
        
        k8s国际化实现
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/RESTful%20API%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/">
        
        RESTful API格式规范
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/AI%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6/">
        
        AI视频处理软件
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/FTP%E3%80%81FTPS%E5%92%8CSFTP%E9%83%BD%E6%98%AF%E5%95%A5/">
        
        FTP、FTPS和SFTP都是啥
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/github%E6%B7%BB%E5%8A%A0ssh%E6%96%B9%E6%B3%95/">
        
        github添加ssh方法
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/git%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%8D%E5%90%8C%E4%BB%93%E5%BA%93%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/">
        
        git—合并不同仓库的项目代码
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/git%E4%BB%93%E5%BA%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4%E6%97%B6%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">
        
        git仓库第一次提交时失败问题记录
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%B8%80%E6%AC%A1apisix%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B/">
        
        一次apisix问题排查过程
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%B8%80%E6%AC%A1python%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">
        
        一次python代码混淆问题排查
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%B8%80%E7%A7%8D%E5%B0%86%E6%96%87%E6%9C%AC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9B%BE%E8%A1%A8%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%9B%BE%E8%A1%A8%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/">
        
        一种将文本转换为图表的现代图表脚本语言
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E5%A4%9A%E6%98%AF%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%B1%82/">
        
        为什么好的开源软件多是基础架构层
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%BB%B6%E6%97%B6%E3%80%81%E4%B8%A2%E5%8C%85%E3%80%81%E6%8A%96%E5%8A%A8%E2%80%94%E2%80%94%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/">
        
        延时、丢包、抖动——术语解释
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/git%20%E7%AC%94%E8%AE%B0/">
        
        git 笔记
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Apdex%20%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%95%B0/">
        
        Apdex 应用性能指数
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/GraphQL%20%E5%85%A5%E9%97%A8/">
        
        GraphQL 入门
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/REST%E9%A3%8E%E6%A0%BC%E7%90%86%E8%A7%A3/">
        
        REST风格理解
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/dalin%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/">
        
        dalin的服务器配置记录
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">
        
        k8s配置文件详解
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/session%EF%BC%8Ccookie%EF%BC%8Ctoken%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/">
        
        session，cookie，token学习
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E3%80%90%E8%BD%AC%E3%80%91/">
        
        一次完整的HTTP请求过程【转】
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E7%9A%84%20Helloworld/">
        
        各种语言版本的 Helloworld
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/">
        
        服务缓存数据更新
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">
        
        使用github搭建个人博客
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/">
        
        进程间通信技术
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        html
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/html/css%E7%9F%A5%E8%AF%86%E7%82%B9/">
        
        css知识点
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        java
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">
        
        PriorityQueue-优先级队列
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/">
        
        实体类中用基本类型还是包装类
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/">
        
        混乱的Java版本命名
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">
        
        解读阿里巴巴 Java 代码规范
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/maven%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/">
        
        maven使用本地依赖
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20%E6%B3%A8%E8%A7%A3/">
        
        Spring 注解
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/SkyWalking%E2%80%94Java%E6%8E%A2%E9%92%88%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">
        
        SkyWalking—Java探针插件开发
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Skywalking%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90%EF%BC%88%E5%BA%9F%E7%A8%BF%EF%BC%89/">
        
        Skywalking数据库插件分析（废稿）
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">
        
        Spring的单例模式与线程安全
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/skywalking%20Jdbc%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/">
        
        skywalking Jdbc插件分析
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E4%B8%AD%E6%97%A0%E5%A4%84%E4%B8%8D%E5%9C%A8%E7%9A%84%E5%9D%91/">
        
        Java中无处不在的坑
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90/">
        
        Java优雅的关闭连接资源
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E4%BF%9D%E7%95%99%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E%E5%87%A0%E4%BD%8D/">
        
        Java保留小数点后几位
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E5%AF%B9%E8%B1%A1%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%A7%A3%E6%B3%95/">
        
        Java对象循环引用解法
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Jpa%E8%BF%98%E6%98%AFMybatis%EF%BC%9F/">
        
        Jpa还是Mybatis？
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%A2%B3%E7%90%86%E3%80%90%E8%BD%AC%E3%80%91/">
        
        java多线程核心技术梳理
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/JTW%E8%AF%A6%E8%A7%A3/">
        
        JTW详解
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/JVM%E4%B8%8EJava%E7%A8%8B%E5%BA%8F/">
        
        JVM与Java程序
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/">
        
        Java创建线程的4种方式
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">
        
        Java序列化与反序列化
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99/">
        
        Java异常处理原则
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82/">
        
        Java构造函数细节
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
        
        Java正则表达式
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB/">
        
        Java获取时间工具类
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Jenkins%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/">
        
        Jenkins遇到的坑
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Skywalking%E4%BD%BF%E7%94%A8graphql%E6%9F%A5%E8%AF%A2/">
        
        Skywalking使用graphql查询
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Skywalking%E5%AD%A6%E4%B9%A0/">
        
        Skywalking学习
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20boot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">
        
        Spring boot单元测试
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20boot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/">
        
        Spring boot读取配置文件问题
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20security%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/">
        
        Spring security实现权限认证
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/lombok/">
        
        lombok
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/null==obj%20or%20obj==null%20%EF%BC%9F/">
        
        null==obj or obj==null ？
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%20+%20jasypt%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86/">
        
        spring boot + jasypt实现配置文件信息加密
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%B8%AD%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">
        
        spring boot中代码修改配置文件
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%97%9B/">
        
        spring boot使用单例模式的痛
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        
        spring boot使用多线程
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20security%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/">
        
        spring security学习【转】
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">
        
        关于线程安全
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/2020%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/">
        
        2020 学习计划（成长之路）
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%90%E8%BD%AC%E3%80%91/">
        
        Java 归并排序【转】
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/acmp%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">
        
        acmp开发记录
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/idea+maven+git%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">
        
        idea+maven+git 开发环境安装
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/idea%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">
        
        idea使用心得
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E3%80%8AOn%20Java%208%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">
        
        《On Java 8》读书笔记
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">
        
        Java8新特性
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        os
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/TCP%20%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82%2012%20%E9%97%AE%20%E3%80%90%E8%BD%AC%E3%80%91/">
        
        TCP 协议灵魂 12 问 【转】
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/Linux%20shell%20%E5%90%84%E7%A7%8D%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/">
        
        Linux shell 各种符号的意义
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
        
        Linux常用命令
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        python
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="directory">
      <a href="#" data-role="directory">
        Script
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/Script/cmdb_mock/">
        
        cmdb_mock
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/Script/push_cmdb_data/">
        
        push_cmdb_data
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/tops/">
        
        tops
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/Python%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">
        
        Python高级编程技巧
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%20list()%E5%92%8C%5B%5D,dict()%E5%92%8C%7B%7D/">
        
        python list()和[],dict()和{}
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E5%85%A5%E9%97%A8/">
        
        python入门
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/">
        
        python单例模式实现
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
        
        python多进程与多线程
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E7%9F%A5%E8%AF%86%E7%82%B9/">
        
        python知识点
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">
        
        python编程技巧
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/python%E8%84%9A%E6%9C%AC%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">
        
        python脚本接收参数的几种实现方式
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/python/%E5%8F%98%E9%87%8F%E5%8F%8A%E6%96%B9%E6%B3%95%E5%89%8D%E5%90%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E5%90%AB%E4%B9%89/">
        
        变量及方法前后下划线的含义
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="file">
      <a href="/2023/06/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Fiddler%E6%8A%93%E5%8C%85%E5%AE%89%E5%8D%93APP/">
        
        使用Fillder抓包安卓APP
        
      </a>
    </li> 
    <li class="file">
      <a href="/2023/02/28/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
        
        深入浅出设计模式
        
      </a>
    </li> 
  </ul> 
    </li>
    
    <li class="directory">
      <a href="#" data-role="directory">
        生活点滴
        &nbsp;
        <i class="fa fa-pull-right fa-angle-right" style="margin-top:4px;margin-right:12px"></i>
      </a>
      
  <ul class="unstyled" id="tree" > 
    <li class="file">
      <a href="/2023/06/16/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/%E6%88%91%E7%9A%84%E6%96%B0%E5%86%A0%E7%BB%8F%E5%8E%86/">
        
        我的新冠经历
        
      </a>
    </li> 
    <li class="file">
      <a href="/2023/06/15/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/2023-06-15-game_report/">
        
        每日游戏报告（2023-06-15）
        
      </a>
    </li> 
    <li class="file">
      <a href="/2022/12/13/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/keep/">
        
        keep
        
      </a>
    </li> 
  </ul> 
    </li>
    
  </ul> 
</div>
<script>
  $(document).ready(function() {
    var iconFolderOpenClass = 'fa-angle-down';
    var iconFolderCloseClass = 'fa-angle-right';
    var iconAllExpandClass = 'fa-angle-double-down';
    var iconAllPackClass = 'fa-angle-double-up';
    // Handle directory-tree expansion:
    // 左键单独展开目录
    $(document).on('click', '#categories a[data-role="directory"]', function(event) {
      event.preventDefault();

      var icon = $(this).children('.fa');
      var expanded = icon.hasClass(iconFolderOpenClass);
      var subtree = $(this).siblings('ul');
      icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
      if (expanded) {
        if (typeof subtree != 'undefined') {
          subtree.slideUp({
            duration: 100
          });
        }
        icon.addClass(iconFolderCloseClass);
      } else {
        if (typeof subtree != 'undefined') {
          subtree.slideDown({
            duration: 100
          });
        }
        icon.addClass(iconFolderOpenClass);
      }
    });
    // 右键展开下属所有目录
    $('#categories a[data-role="directory"]').bind("contextmenu", function(event) {
      event.preventDefault();

      var icon = $(this).children('.fa');
      var expanded = icon.hasClass(iconFolderOpenClass);
      var listNode = $(this).siblings('ul');
      var subtrees = $.merge(listNode.find('li ul'), listNode);
      var icons = $.merge(listNode.find('.fa'), icon);
      icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
      if (expanded) {
        subtrees.slideUp({
          duration: 100
        });
        icons.addClass(iconFolderCloseClass);
      } else {
        subtrees.slideDown({
          duration: 100
        });
        icons.addClass(iconFolderOpenClass);
      }
    })
    // 展开关闭所有目录按钮
    $(document).on('click', '#allExpand', function(event) {
      event.preventDefault();

      var icon = $(this).children('.fa');
      var expanded = icon.hasClass(iconAllExpandClass);
      icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
      if (expanded) {
        $('#sidebar .fa.fa-angle-right').removeClass('fa-angle-right').addClass('fa-angle-down')
        $('#categories li ul').slideDown({
          duration: 100
        });
        icon.addClass(iconAllPackClass);
      } else {
        $('#sidebar .fa.fa-angle-down').removeClass('fa-angle-down').addClass('fa-angle-right')
        $('#categories li ul').slideUp({
          duration: 100
        });
        icon.addClass(iconAllExpandClass);
      }
    });
  });
</script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-技术开发/golang/go checklist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <header class="article-header">
      
      
      
    
        <h1 class="article-title" itemprop="name">
            go checklist
        </h1>
    

    </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        
        
        <h1 id="go-checklist"><a href="#go-checklist" class="headerlink" title="go checklist"></a>go checklist</h1><h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h2><p>本文档参考开源(Urber)编码规范整理，记录 Go 代码中的惯用约定、规范，其中许多是 Go 语言的通用准则，期望通过引入业界最佳实践来提升团队编码能力，规范编码习惯，提高代码质量。</p>
<p>其他扩展准则依赖于下面外部的指南：</p>
<ul>
<li>Effective Go</li>
<li>Go Common Mistakes</li>
<li>Go Code Review Comments</li>
</ul>
<h2 id="3-规范实施方法"><a href="#3-规范实施方法" class="headerlink" title="3. 规范实施方法"></a>3. 规范实施方法</h2><p>本规范作为Go语言编码的基本规范和准则，是代码自检和检视的参考文档，配合各部门编码checklist，共同看护编码质量。<br>本规范中未标明非强制的规范和准则，均为强制规范&#x2F;准则。</p>
<h2 id="4-工程要求"><a href="#4-工程要求" class="headerlink" title="4. 工程要求"></a>4. 工程要求</h2><h4 id="4-1-IDE-中集成下述工具插件"><a href="#4-1-IDE-中集成下述工具插件" class="headerlink" title="4.1. IDE 中集成下述工具插件"></a>4.1. IDE 中集成下述工具插件</h4><ul>
<li>提交代码时，必须使用 gofmt 工具格式化代码。注意，gofmt 不识别空行，因为 gofmt 不能理解空行的意义。</li>
<li>提交代码前，必须使用 goimports 工具检查导入。</li>
<li>提交代码时，必须使用 golint 工具检查代码规范。</li>
<li>提交代码前，必须使用 go vet 工具静态分析代码实现</li>
<li>可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p>
<h2 id="5-规范"><a href="#5-规范" class="headerlink" title="5. 规范"></a>5. 规范</h2><h3 id="5-1-基本约定"><a href="#5-1-基本约定" class="headerlink" title="5.1. 基本约定"></a>5.1. 基本约定</h3><h4 id="5-1-1-文件、函数大小约定"><a href="#5-1-1-文件、函数大小约定" class="headerlink" title="5.1.1. 文件、函数大小约定"></a>5.1.1. 文件、函数大小约定</h4><p>单行长度尽量限制为 99个 字符 。</p>
<p>单个文件长度尽量不超过 500 行。</p>
<p>单个函数长度尽量不超过 50 行。</p>
<p>单个函数圈复杂度尽量不超过 10，禁止超过 15。</p>
<p>单个函数中嵌套尽量不超过 3 层。</p>
<p>这不是硬性限制，但是超过此限制需要向reviewer做适当解释。</p>
<h4 id="5-1-2-缩进、括号和空格约定"><a href="#5-1-2-缩进、括号和空格约定" class="headerlink" title="5.1.2. 缩进、括号和空格约定"></a>5.1.2. 缩进、括号和空格约定</h4><p>缩进、括号和空格都使用 gofmt 工具处理。</p>
<p>强制使用 tab 缩进。</p>
<p>强制左大括号不换行。</p>
<p>强制所有的运算符和操作数之间要留空格。</p>
<h4 id="5-1-3-一致性"><a href="#5-1-3-一致性" class="headerlink" title="5.1.3. 一致性"></a>5.1.3. 一致性</h4><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，保持一致.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="5-2-分组规范"><a href="#5-2-分组规范" class="headerlink" title="5.2. 分组规范"></a>5.2. 分组规范</h3><h4 id="5-2-1-相似的声明放在一组"><a href="#5-2-1-相似的声明放在一组" class="headerlink" title="5.2.1. 相似的声明放在一组"></a>5.2.1. 相似的声明放在一组</h4><p>Go 语言支持将相似的声明放在一个组内。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;a&quot;</span><br><span class="line">import &quot;b&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;a&quot;</span><br><span class="line">  &quot;b&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这同样适用于常量、变量和类型声明：</p>
</li>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const a = 1</span><br><span class="line">const b = 2</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">type Area float64</span><br><span class="line">type Volume float64</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">  a = 1</span><br><span class="line">  b = 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">  a = 1</span><br><span class="line">  b = 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type (</span><br><span class="line">  Area float64</span><br><span class="line">  Volume float64</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
</li>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Operation int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  Add Operation = iota + 1</span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  EnvVar = &quot;MY_ENV&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Operation int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  Add Operation = iota + 1</span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const EnvVar = &quot;MY_ENV&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func f() string &#123;</span><br><span class="line">  red := color.New(0xff0000)</span><br><span class="line">  green := color.New(0x00ff00)</span><br><span class="line">  blue := color.New(0x0000ff)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func f() string &#123;</span><br><span class="line">  var (</span><br><span class="line">    red   = color.New(0xff0000)</span><br><span class="line">    green = color.New(0x00ff00)</span><br><span class="line">    blue  = color.New(0x0000ff)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>例外：如果变量声明与其他变量相邻，则应将变量声明（尤其是函数内部的声明）分组在一起。对一起声明的变量执行此操作，即使它们不相关。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (c *client) request() &#123;</span><br><span class="line">  caller := c.name</span><br><span class="line">  format := &quot;json&quot;</span><br><span class="line">  timeout := 5*time.Second</span><br><span class="line">  var err error</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *client) request() &#123;</span><br><span class="line">  var (</span><br><span class="line">    caller  = c.name</span><br><span class="line">    format  = &quot;json&quot;</span><br><span class="line">    timeout = 5*time.Second</span><br><span class="line">    err error</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-2-2-import-分组规范"><a href="#5-2-2-import-分组规范" class="headerlink" title="5.2.2. import 分组规范"></a>5.2.2. import 分组规范</h4><p>导入应该分为三组：</p>
<ul>
<li>标准库</li>
<li>内部库</li>
<li>其他库</li>
</ul>
<p>默认情况下，这是 goimports 应用的分组。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line">  &quot;go.sangfor.org/cloudtech/resourcecenter&quot;</span><br><span class="line">  &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;go.sangfor.org/cloudtech/resourcecenter&quot;</span><br><span class="line"></span><br><span class="line">  &quot;go.uber.org/atomic&quot;</span><br><span class="line">  &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-2-3-函数分组与顺序"><a href="#5-2-3-函数分组与顺序" class="headerlink" title="5.2.3. 函数分组与顺序"></a>5.2.3. 函数分组与顺序</h4><p>函数应按粗略的调用顺序排序。</p>
<p>同一文件中的函数应按接收者分组。</p>
<p>因此，导出的函数应先出现在文件中，放在struct, const, var定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 newXYZ()&#x2F;NewXYZ()</p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (s *something) Cost() &#123;</span><br><span class="line">  return calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type something struct&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">func calcCost(n []int) int &#123;...&#125;</span><br><span class="line"></span><br><span class="line">func (s *something) Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">func newSomething() *something &#123;</span><br><span class="line">    return &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type something struct&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">func newSomething() *something &#123;</span><br><span class="line">    return &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *something) Cost() &#123;</span><br><span class="line">  return calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *something) Stop() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">func calcCost(n []int) int &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-命名规范"><a href="#5-3-命名规范" class="headerlink" title="5.3. 命名规范"></a>5.3. 命名规范</h3><h4 id="5-3-1-包名"><a href="#5-3-1-包名" class="headerlink" title="5.3.1. 包名"></a>5.3.1. 包名</h4><p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如net&#x2F;url，而不是net&#x2F;urls。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li>
<li>另请参阅 Go 包命名规则 和 Go 包样式指南.</li>
</ul>
<h4 id="5-3-2-文件名"><a href="#5-3-2-文件名" class="headerlink" title="5.3.2. 文件名"></a>5.3.2. 文件名</h4><p>文件名为全小写单词，使用 “_” 分词。Golang 通常具有以下几种代码文件类型：</p>
<ul>
<li>业务代码文件</li>
<li>模型代码文件</li>
<li>测试代码文件</li>
<li>工具代码文件</li>
</ul>
<h4 id="5-3-3-函数名"><a href="#5-3-3-函数名" class="headerlink" title="5.3.3. 函数名"></a>5.3.3. 函数名</h4><p>遵循 Go 社区关于使用 <a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html#mixed-caps">MixedCaps 作为函数名</a> 的约定。</p>
<p>函数、方法（结构体或者接口下属的函数称为方法）命名规则： 动词 + 名词。</p>
<p>若函数、方法为判断类型（返回值主要为 bool 类型），则名称应以 Has、Is、Can 或 Allow 等判断性动词开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func HasPrefix(name string, prefixes []string) bool &#123; ... &#125;</span><br><span class="line">func IsEntry(name string, entries []string) bool &#123; ... &#125;</span><br><span class="line">func CanManage(name string) bool &#123; ... &#125;</span><br><span class="line">func AllowGitHook() bool &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：TestMyFunction_WhatIsBeingTested.</p>
<h4 id="5-3-4-结构体、接口名"><a href="#5-3-4-结构体、接口名" class="headerlink" title="5.3.4. 结构体、接口名"></a>5.3.4. 结构体、接口名</h4><p>结构体命名规则：名词或名词短语。</p>
<p>接口命名规则：以 ”er” 作为后缀，例如：Reader、Writer。接口实现的方法则去掉 “er”，例如：Read、Write。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123; Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多个函数接口</span><br><span class="line">type WriteFlusher interface &#123; Write([]byte) (int, error) Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-5-变量、常量名"><a href="#5-3-5-变量、常量名" class="headerlink" title="5.3.5. 变量、常量名"></a>5.3.5. 变量、常量名</h4><p>变量命名遵循驼峰法。</p>
<p>常量使用全大写单词，使用 “_” 分词。</p>
<p>首字母根据访问控制原则使用大写或者小写。</p>
<p>对于常规缩略语，一旦选择了大写或小写的风格，就应当在整份代码中保持这种风格，不要首字母大写和缩写两种风格混用。以 URL 为例，如果选择了缩写 URL 这种风格，则应在整份代码中保持。错误：UrlArray，正确：urlArray 或 URLArray。再以 ID 为例，如果选择了缩写 ID 这种风格，错误：appleId，正确：appleID。<br>对于只在本文件中有效的顶级变量、常量，应该使用 “_” 前缀，避免在同一个包中的其他文件中意外使用错误的值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">  _defaultPort = 8080</span><br><span class="line">  _defaultUser = &quot;user&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="5-3-6-导入别名"><a href="#5-3-6-导入别名" class="headerlink" title="5.3.6. 导入别名"></a>5.3.6. 导入别名</h4><p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">  client &quot;example.com/client-go&quot;</span><br><span class="line">  trace &quot;example.com/trace/v2&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line"></span><br><span class="line">  nettrace &quot;golang.net/x/trace&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line">  &quot;runtime/trace&quot;</span><br><span class="line"></span><br><span class="line">  nettrace &quot;golang.net/x/trace&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-4-注释规范"><a href="#5-4-注释规范" class="headerlink" title="5.4. 注释规范"></a>5.4. 注释规范</h3><p>Golang 的 go doc 工具可以根据注释生成代码文档，所以注释的质量决定了代码文档的质量。</p>
<p>【强制】所有新增代码文件需添加版权声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* Copyright @2022 Sangfor Technologies. All rights reserved. */</span><br></pre></td></tr></table></figure>

<h3 id="5-4-1-注释风格"><a href="#5-4-1-注释风格" class="headerlink" title="5.4.1. 注释风格"></a>5.4.1. 注释风格</h3><p>统一使用中文注释，中西文之间严格使用空格分隔，严格使用中文标点符号。</p>
<p>注释应当是一个完整的句子，以句号结尾。</p>
<p>句子类型的注释首字母均需大写，短语类型的注释首字母需小写。</p>
<p>注释的单行长度不能超过 99 个字符。</p>
<h4 id="5-4-2-包注释"><a href="#5-4-2-包注释" class="headerlink" title="5.4.2. 包注释"></a>5.4.2. 包注释</h4><p>每个包都应该有一个包注释。包注释应该包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包名，简介。</span><br><span class="line">创建者(使用团队名，个人名只在提交记录中体现，不在代码中体现)。</span><br><span class="line">创建时间。</span><br></pre></td></tr></table></figure>
<p>对于 main 包，通常只有一行简短的注释用以说明包的用途，且以项目名称开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// gormc(Go Resource Management Service) 是资源分配服务.</span><br><span class="line">package main</span><br></pre></td></tr></table></figure>

<p>对于简单的非 main 包，也可用一行注释概括。</p>
<p>对于一个复杂项目的子包，一般情况下不需要包级别注释，除非是代表某个特定功能的模块。</p>
<p>对于相对功能复杂的非 main 包，一般都会增加一些使用示例或基本说明，且以 Package 开头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 包regexp 实现了一个简单的正则匹配库. 基本使用语法: regexp: concatenation &#123; &#x27;|&#x27; concatenation &#125; concatenation: &#123; closure &#125; closure: term [ &#x27;*&#x27; | &#x27;+&#x27; | &#x27;?&#x27; ] term: &#x27;^&#x27; &#x27;$&#x27; &#x27;.&#x27; character &#x27;[&#x27; [ &#x27;^&#x27; ] character-ranges &#x27;]&#x27; &#x27;(&#x27; regexp &#x27;)&#x27; */</span><br><span class="line">package regexp</span><br></pre></td></tr></table></figure>
<p>对于特别复杂的包说明，一般使用 doc.go</p>
<p>文件用于编写包的描述，并提供与整个包相关的信息。</p>
<h4 id="5-4-3-函数、方法注释"><a href="#5-4-3-函数、方法注释" class="headerlink" title="5.4.3. 函数、方法注释"></a>5.4.3. 函数、方法注释</h4><p>每个函数、方法（结构体或者接口下属的函数称为方法）都应该有注释说明，包括三个方面（顺序严格）：</p>
<ul>
<li>函数、方法名，简要说明。</li>
<li>参数列表，每行一个参数。</li>
<li>返回值，每行一个返回值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NewtAttrModel，属性数据层操作类的工厂方法。</span><br><span class="line">// 参数：</span><br><span class="line">// ctx：上下文信息。</span><br><span class="line">// 返回值：</span><br><span class="line">// 属性操作类指针。</span><br><span class="line">func NewAttrModel(ctx *common.Context) *AttrModel &#123;&#125;</span><br></pre></td></tr></table></figure>
如果一句话不足以说明全部问题，则可换行继续进行更加细致的描述：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 复制函数将文件从源地址复制到目的地址.</span><br><span class="line">// 失败场景下返回false或error.</span><br></pre></td></tr></table></figure>
若函数或方法为判断类型（返回值主要为 bool 类型），则注释以&lt;函数名&gt; returns true if 开头：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// HasPrefix 返回 true，如果输入的name参数包含指定的prefix.</span><br><span class="line">func HasPrefix(name string, prefixes []string) bool &#123; ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-4-4-结构体、接口注释"><a href="#5-4-4-结构体、接口注释" class="headerlink" title="5.4.4. 结构体、接口注释"></a>5.4.4. 结构体、接口注释</h4><p>每个自定义的结构体、接口都应该有注释说明，放在实体定义的前一行，格式为：名称、说明。同时，结构体内的每个成员都要有说明，该说明放在成员变量的后面（注意对齐），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// User，用户实例，定义了用户的基础信息。</span><br><span class="line">type User struct&#123; </span><br><span class="line">  Username  string  // 用户名 </span><br><span class="line">  Email string  // 邮箱</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-5-其它说明"><a href="#5-4-5-其它说明" class="headerlink" title="5.4.5. 其它说明"></a>5.4.5. 其它说明</h4><p>当某个部分等待完成时，用 TODO(Your name): 开头的注释来提醒维护人员。</p>
<p>当某个部分存在已知问题进行需要修复或改进时，用 FIXME(Your name): 开头的注释来提醒维护人员。</p>
<p>当需要特别说明某个问题时，可用 NOTE(You name): 开头的注释。</p>
<h3 id="5-5-单元测试规范"><a href="#5-5-单元测试规范" class="headerlink" title="5.5. 单元测试规范"></a>5.5. 单元测试规范</h3><h4 id="5-5-1-测试命名和提交规范"><a href="#5-5-1-测试命名和提交规范" class="headerlink" title="5.5.1. 测试命名和提交规范"></a>5.5.1. 测试命名和提交规范</h4><p>单元测试都必须使用 GoConvey 编写，且覆盖率必须在 80% 以上。</p>
<p>业务代码文件和单元测试文件放在同一目录下。</p>
<p>单元测试文件名以 *_test.go 为后缀，例如：example_test.go。</p>
<p>测试用例的函数名称必须以 Test 开头，例如：Test_Logger。</p>
<p>如果为结构体的方法编写测试用例，则需要以 Text__的形式命名，例如：Test_Macaron_Run。</p>
<p>每个重要的函数都要同步编写测试用例。</p>
<p>测试用例和业务代码同步提交，方便进行回归测试。</p>
<h4 id="5-5-2-表驱动测试"><a href="#5-5-2-表驱动测试" class="headerlink" title="5.5.2. 表驱动测试"></a>5.5.2. 表驱动测试</h4><p>当测试逻辑是重复的时候，通过 subtests 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// func TestSplitHostPort(t *testing.T)</span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(&quot;192.0.2.0:8000&quot;)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, &quot;192.0.2.0&quot;, host)</span><br><span class="line">assert.Equal(t, &quot;8000&quot;, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(&quot;192.0.2.0:http&quot;)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, &quot;192.0.2.0&quot;, host)</span><br><span class="line">assert.Equal(t, &quot;http&quot;, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(&quot;:8000&quot;)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, &quot;&quot;, host)</span><br><span class="line">assert.Equal(t, &quot;8000&quot;, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(&quot;1:8&quot;)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, &quot;1&quot;, host)</span><br><span class="line">assert.Equal(t, &quot;8&quot;, port)</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// func TestSplitHostPort(t *testing.T)</span><br><span class="line"></span><br><span class="line">tests := []struct&#123;</span><br><span class="line">  give     string</span><br><span class="line">  wantHost string</span><br><span class="line">  wantPort string</span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     &quot;192.0.2.0:8000&quot;,</span><br><span class="line">    wantHost: &quot;192.0.2.0&quot;,</span><br><span class="line">    wantPort: &quot;8000&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     &quot;192.0.2.0:http&quot;,</span><br><span class="line">    wantHost: &quot;192.0.2.0&quot;,</span><br><span class="line">    wantPort: &quot;http&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     &quot;:8000&quot;,</span><br><span class="line">    wantHost: &quot;&quot;,</span><br><span class="line">    wantPort: &quot;8000&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     &quot;1:8&quot;,</span><br><span class="line">    wantHost: &quot;1&quot;,</span><br><span class="line">    wantPort: &quot;8&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, tt := range tests &#123;</span><br><span class="line">  t.Run(tt.give, func(t *testing.T) &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</li>
</ul>
<p>我们遵循这样的约定：将结构体切片称为tests。 每个测试用例称为tt。此外，我们鼓励使用give和want前缀说明每个测试用例的输入和输出值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []struct&#123;</span><br><span class="line">  give     string</span><br><span class="line">  wantHost string</span><br><span class="line">  wantPort string</span><br><span class="line">&#125;&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for _, tt := range tests &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-代码逻辑规范"><a href="#5-6-代码逻辑规范" class="headerlink" title="5.6. 代码逻辑规范"></a>5.6. 代码逻辑规范</h3><h4 id="5-6-1-变量声明规范"><a href="#5-6-1-变量声明规范" class="headerlink" title="5.6.1. 变量声明规范"></a>5.6.1. 变量声明规范</h4><h5 id="5-6-1-1-顶层变量声明规范"><a href="#5-6-1-1-顶层变量声明规范" class="headerlink" title="5.6.1.1. 顶层变量声明规范"></a>5.6.1.1. 顶层变量声明规范</h5><p>在顶层，使用标准var关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var _s string = F()</span><br><span class="line"></span><br><span class="line">func F() string &#123; return &quot;A&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var _s = F()</span><br><span class="line">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span><br><span class="line">// 还是那种类型</span><br><span class="line"></span><br><span class="line">func F() string &#123; return &quot;A&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type myError struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (myError) Error() string &#123; return &quot;error&quot; &#125;</span><br><span class="line"></span><br><span class="line">func F() myError &#123; return myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">var _e error = F()</span><br><span class="line">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-1-2-未导出的顶层常量和变量，使用-作为前缀"><a href="#5-6-1-2-未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="5.6.1.2. 未导出的顶层常量和变量，使用_作为前缀"></a>5.6.1.2. 未导出的顶层常量和变量，使用_作为前缀</h5><p>在未导出的顶级vars和consts， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以err开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// foo.go</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  defaultPort = 8080</span><br><span class="line">  defaultUser = &quot;user&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// bar.go</span><br><span class="line"></span><br><span class="line">func Bar() &#123;</span><br><span class="line">  defaultPort := 9090</span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(&quot;Default port&quot;, defaultPort)</span><br><span class="line"></span><br><span class="line">  // We will not see a compile error if the first line of</span><br><span class="line">  // Bar() is deleted.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// foo.go</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  _defaultPort = 8080</span><br><span class="line">  _defaultUser = &quot;user&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>Exception:未导出的错误值可以使用不带下划线的前缀 err。 参见错误命名。</p>
</li>
</ul>
<h5 id="5-6-1-3-本地变量声明"><a href="#5-6-1-3-本地变量声明" class="headerlink" title="5.6.1.3. 本地变量声明"></a>5.6.1.3. 本地变量声明</h5><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (:&#x3D;)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &quot;foo&quot;</span><br><span class="line">s := &quot;foo&quot;</span><br></pre></td></tr></table></figure>
<p>但是，在某些情况下，var 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func f(list []int) &#123;</span><br><span class="line">  filtered := []int&#123;&#125;</span><br><span class="line">  for _, v := range list &#123;</span><br><span class="line">    if v &gt; 10 &#123;</span><br><span class="line">      filtered = append(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func f(list []int) &#123;</span><br><span class="line">  var filtered []int</span><br><span class="line">  for _, v := range list &#123;</span><br><span class="line">    if v &gt; 10 &#123;</span><br><span class="line">      filtered = append(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-1-4-缩小变量作用域"><a href="#5-6-1-4-缩小变量作用域" class="headerlink" title="5.6.1.4. 缩小变量作用域"></a>5.6.1.4. 缩小变量作用域</h5><p>如果有可能，尽量缩小变量作用范围。除非它与 减少嵌套的规则冲突。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, 0644)</span><br><span class="line">if err != nil &#123;</span><br><span class="line"> return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if err := ioutil.WriteFile(name, data, 0644); err != nil &#123;</span><br><span class="line"> return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</li>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if data, err := ioutil.ReadFile(name); err == nil &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  return nil</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">   return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err := cfg.Decode(data); err != nil &#123;</span><br><span class="line">  return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-6-2-函数定义规范"><a href="#5-6-2-函数定义规范" class="headerlink" title="5.6.2. 函数定义规范"></a>5.6.2. 函数定义规范</h4><h3 id="5-6-2-1-避免参数语义不明确-Avoid-Naked-Parameters"><a href="#5-6-2-1-避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="5.6.2.1. 避免参数语义不明确 (Avoid Naked Parameters)"></a>5.6.2.1. 避免参数语义不明确 (Avoid Naked Parameters)</h3><p>函数调用中的意义不明确的参数可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// func printInfo(name string, isLocal, done bool)</span><br><span class="line"></span><br><span class="line">printInfo(&quot;foo&quot;, true, true)</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// func printInfo(name string, isLocal, done bool)</span><br><span class="line"></span><br><span class="line">printInfo(&quot;foo&quot;, true /* isLocal */, true /* done */)</span><br></pre></td></tr></table></figure>
对于上面的示例代码，还有一种更好的处理方式是将上面的 bool 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true&#x2F;false）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Region int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  UnknownRegion Region = iota</span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Status int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  StatusReady Status= iota + 1</span><br><span class="line">  StatusDone</span><br><span class="line">  // Maybe we will have a StatusInProgress in the future.</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func printInfo(name string, region Region, status Status)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-2-2-避免使用-init"><a href="#5-6-2-2-避免使用-init" class="headerlink" title="5.6.2.2. 避免使用 init()"></a>5.6.2.2. 避免使用 init()</h5><p>尽可能避免使用init()。当init()是不可避免或可取的，代码应先尝试：</p>
<p>无论程序环境或调用如何，都要完全确定。</p>
<p>避免依赖于其他init()函数的顺序或副作用。虽然init()顺序是明确的，但代码可以更改，因此init()函数之间的关系可能会使代码变得脆弱和容易出错。</p>
<p>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数&#x2F;输入等。</p>
<p>避免I&#x2F;O，包括文件系统、网络和系统调用。</p>
<p>不能满足这些要求的代码可能属于要作为main()调用的一部分（或程序生命周期中的其他地方），<br>或者作为main()本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，<br>而不是执行“init magic”。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">var _defaultFoo Foo</span><br><span class="line">func init() &#123;</span><br><span class="line">    _defaultFoo = Foo&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var _defaultFoo = Foo&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">// or，为了更好的可测试性：</span><br><span class="line">var _defaultFoo = defaultFoo()</span><br><span class="line">func defaultFoo() Foo &#123;</span><br><span class="line">    return Foo&#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">var _config Config</span><br><span class="line">func init() &#123;</span><br><span class="line">    // Bad: 基于当前目录</span><br><span class="line">    cwd, _ := os.Getwd()</span><br><span class="line">    // Bad: I/O</span><br><span class="line">    raw, _ := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, &quot;config&quot;, &quot;config.yaml&quot;),</span><br><span class="line">    )</span><br><span class="line">    yaml.Unmarshal(raw, &amp;_config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">func loadConfig() Config &#123;</span><br><span class="line">    cwd, err := os.Getwd()</span><br><span class="line">    // handle err</span><br><span class="line">    raw, err := ioutil.ReadFile(</span><br><span class="line">        path.Join(cwd, &quot;config&quot;, &quot;config.yaml&quot;),</span><br><span class="line">    )</span><br><span class="line">    // handle err</span><br><span class="line">    var config Config</span><br><span class="line">    yaml.Unmarshal(raw, &amp;config)</span><br><span class="line">    return config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到上述情况，在某些情况下，init()可能更可取或是必要的，可能包括：</p>
</li>
<li><p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li><p>可插入的钩子，如database&#x2F;sql、编码类型注册表等。</p>
</li>
<li><p>对 Google Cloud Functions 和其他形式的确定性预计算的优化。</p>
</li>
</ul>
<h4 id="5-6-3-结构体类型定义规范"><a href="#5-6-3-结构体类型定义规范" class="headerlink" title="5.6.3. 结构体类型定义规范"></a>5.6.3. 结构体类型定义规范</h4><h5 id="5-6-3-1-使用字段名初始化结构"><a href="#5-6-3-1-使用字段名初始化结构" class="headerlink" title="5.6.3.1. 使用字段名初始化结构"></a>5.6.3.1. 使用字段名初始化结构</h5><p>初始化结构时，几乎应该始终指定字段名。目前由 go vet 强制执行。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;&quot;John&quot;, &quot;Doe&quot;, true&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: &quot;John&quot;,</span><br><span class="line">    LastName: &quot;Doe&quot;,</span><br><span class="line">    Admin: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例外：当有 3 个或更少的字段时，测试表中的字段名may可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []struct&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want string</span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, &quot;add&quot;&#125;,</span><br><span class="line">  &#123;Subtract, &quot;subtract&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-3-2-省略结构中的零值字段"><a href="#5-6-3-2-省略结构中的零值字段" class="headerlink" title="5.6.3.2. 省略结构中的零值字段"></a>5.6.3.2. 省略结构中的零值字段</h5><p>初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零值的字段。<br>也就是，让我们自动将这些设置为零值</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: &quot;John&quot;,</span><br><span class="line">  LastName: &quot;Doe&quot;,</span><br><span class="line">  MiddleName: &quot;&quot;,</span><br><span class="line">  Admin: false,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;</span><br><span class="line">  FirstName: &quot;John&quot;,</span><br><span class="line">  LastName: &quot;Doe&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</li>
</ul>
<p>在字段名提供有意义上下文的地方包含零值。例如，表驱动测试 中的测试用例可以指定全部字段的名称，即使它们是零值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []struct&#123;</span><br><span class="line">  give string</span><br><span class="line">  want int</span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;give: &quot;0&quot;, want: 0&#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-6-3-3-对零值结构使用-var"><a href="#5-6-3-3-对零值结构使用-var" class="headerlink" title="5.6.3.3. 对零值结构使用 var"></a>5.6.3.3. 对零值结构使用 var</h5><p>如果在声明中省略了结构的所有字段，请使用 var 声明结构。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var user User</span><br></pre></td></tr></table></figure>
<p>这将零值结构与那些具有类似于为 初始化 Maps 创建的，区别于非零值字段的结构区分开来，<br>并与我们更喜欢的 声明空切片 方式相匹配。</p>
</li>
</ul>
<h5 id="5-6-3-4-初始化-Struct-引用"><a href="#5-6-3-4-初始化-Struct-引用" class="headerlink" title="5.6.3.4. 初始化 Struct 引用"></a>5.6.3.4. 初始化 Struct 引用</h5><p>在初始化结构引用时，请使用&amp;T{}代替new(T)，以使其与结构体初始化一致。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: &quot;foo&quot;&#125;</span><br><span class="line"></span><br><span class="line">// inconsistent</span><br><span class="line">sptr := new(T)</span><br><span class="line">sptr.Name = &quot;bar&quot;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: &quot;foo&quot;&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: &quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-3-5-结构体中的嵌入"><a href="#5-6-3-5-结构体中的嵌入" class="headerlink" title="5.6.3.5. 结构体中的嵌入"></a>5.6.3.5. 结构体中的嵌入</h5><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Client struct &#123;</span><br><span class="line">  version int</span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Client struct &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。</li>
</ul>
<p>它应该在对用户没有任何不利影响的情况下使用。（另请参见：避免在公共结构中嵌入类型）。</p>
<p>例外：即使在未导出类型中，Mutex 也不应该作为内嵌字段。另请参见：零值 Mutex 是有效的。</p>
<p>嵌入 不应该:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的 API 或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有目的地嵌入。<br>一种很好的测试体验是，”是否所有这些导出的内部方法&#x2F;字段都将直接添加到外部类型？”，<br>如果答案是some或no，不要嵌入内部类型，而是使用字段。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type A struct &#123;</span><br><span class="line">    // Bad: A.Lock() and A.Unlock() 现在可用</span><br><span class="line">    // 不提供任何功能性好处，并允许用户控制有关 A 的内部细节。</span><br><span class="line">    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Book struct &#123;</span><br><span class="line">    // Bad: 指针更改零值的有用性</span><br><span class="line">    io.ReadWriter</span><br><span class="line">    // other fields</span><br><span class="line">&#125;</span><br><span class="line">// later</span><br><span class="line">var b Book</span><br><span class="line">b.Read(...)  // panic: nil pointer</span><br><span class="line">b.String()   // panic: nil pointer</span><br><span class="line">b.Write(...) // panic: nil pointer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Client struct &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    sync.WaitGroup</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type countingWriteCloser struct &#123;</span><br><span class="line">    // Good: Write() 在外层提供用于特定目的，</span><br><span class="line">    // 并且委托工作到内部类型的 Write() 中。</span><br><span class="line">    io.WriteCloser</span><br><span class="line">    count int</span><br><span class="line">&#125;</span><br><span class="line">func (w *countingWriteCloser) Write(bs []byte) (int, error) &#123;</span><br><span class="line">    w.count += len(bs)</span><br><span class="line">    return w.WriteCloser.Write(bs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Book struct &#123;</span><br><span class="line">    // Good: 有用的零值</span><br><span class="line">    bytes.Buffer</span><br><span class="line">    // other fields</span><br><span class="line">&#125;</span><br><span class="line">// later</span><br><span class="line">var b Book</span><br><span class="line">b.Read(...)  // ok</span><br><span class="line">b.String()   // ok</span><br><span class="line">b.Write(...) // ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Client struct &#123;</span><br><span class="line">    mtx sync.Mutex</span><br><span class="line">    wg  sync.WaitGroup</span><br><span class="line">    buf bytes.Buffer</span><br><span class="line">    url url.URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-6-4-接口定义规范"><a href="#5-6-4-接口定义规范" class="headerlink" title="5.6.4. 接口定义规范"></a>5.6.4. 接口定义规范</h4><p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ul>
<li>一个指向某些特定类型信息的指针。您可以将其视为”type”。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ul>
<p>如果希望接口方法修改基础数据，则必须使用指针传递 (将对象指针赋值给接口变量)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type F interface &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S1 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s S1) f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">type S2 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *S2) f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">// f1.f() 无法修改底层数据</span><br><span class="line">// f2.f() 可以修改底层数据，给接口变量 f2 赋值时使用的是对象指针</span><br><span class="line">var f1 F = S1&#123;&#125;</span><br><span class="line">var f2 F = &amp;S2&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-6-5-Map-x2F-Slice-类型定义规范"><a href="#5-6-5-Map-x2F-Slice-类型定义规范" class="headerlink" title="5.6.5. Map&#x2F;Slice 类型定义规范"></a>5.6.5. Map&#x2F;Slice 类型定义规范</h4><h5 id="5-6-5-1-Map-类型定义规范"><a href="#5-6-5-1-Map-类型定义规范" class="headerlink" title="5.6.5.1. Map 类型定义规范"></a>5.6.5.1. Map 类型定义规范</h5><p>对于空 map 请使用 make(..) 初始化， 并且 map 是通过编程方式填充的。</p>
<p>这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">  // m1 读写安全;</span><br><span class="line">  // m2 在写入时会 panic</span><br><span class="line">  m1 = map[T1]T2&#123;&#125;</span><br><span class="line">  m2 map[T1]T2</span><br><span class="line">)</span><br><span class="line">// 声明和初始化看起来非常相似的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">  // m1 读写安全;</span><br><span class="line">  // m2 在写入时会 panic</span><br><span class="line">  m1 = make(map[T1]T2)</span><br><span class="line">  m2 map[T1]T2</span><br><span class="line">)</span><br><span class="line">// 声明和初始化看起来差别非常大。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 指定 Map 容量提示。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[T1]T2, 3)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := map[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 make (如果可以，请尽量指定 map 容量)。</li>
</ul>
<h5 id="5-6-5-2-nil-是一个有效的-slice"><a href="#5-6-5-2-nil-是一个有效的-slice" class="headerlink" title="5.6.5.2. nil 是一个有效的 slice"></a>5.6.5.2. nil 是一个有效的 slice</h5><p>nil 是一个有效的长度为 0 的 slice，这意味着，</p>
<ol>
<li>您不应明确返回长度为零的切片。应该返回nil 来代替。</li>
</ol>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == &quot;&quot; &#123;</span><br><span class="line">  return []int&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if x == &quot;&quot; &#123;</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>要检查切片是否为空，请始终使用len(s) &#x3D;&#x3D; 0。而非 nil。</li>
</ol>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isEmpty(s []string) bool &#123;</span><br><span class="line">  return s == nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isEmpty(s []string) bool &#123;</span><br><span class="line">  return len(s) == 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>零值切片（用var声明的切片）可立即使用，无需调用make()创建。</li>
</ol>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []int&#123;&#125;</span><br><span class="line">// or, nums := make([]int)</span><br><span class="line"></span><br><span class="line">if add1 &#123;</span><br><span class="line">  nums = append(nums, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if add2 &#123;</span><br><span class="line">  nums = append(nums, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var nums []int</span><br><span class="line"></span><br><span class="line">if add1 &#123;</span><br><span class="line">  nums = append(nums, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if add2 &#123;</span><br><span class="line">  nums = append(nums, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
记住，虽然 nil 切片是有效的切片，但它不等于长度为 0 的切片（一个为 nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</li>
</ul>
<h4 id="5-6-6-字符串类型定义规范"><a href="#5-6-6-字符串类型定义规范" class="headerlink" title="5.6.6. 字符串类型定义规范"></a>5.6.6. 字符串类型定义规范</h4><h5 id="5-6-6-1-声明-Printf-style-String-时，将其设置为-const-常量"><a href="#5-6-6-1-声明-Printf-style-String-时，将其设置为-const-常量" class="headerlink" title="5.6.6.1. 声明 Printf-style String 时，将其设置为 const 常量"></a>5.6.6.1. 声明 Printf-style String 时，将其设置为 const 常量</h5><p>在函数外声明Printf-style 函数的格式字符串，请将其设置为const常量。</p>
<p>这有助于go vet对格式字符串执行静态分析。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := &quot;unexpected values %v, %v\n&quot;</span><br><span class="line">fmt.Printf(msg, 1, 2)</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const msg = &quot;unexpected values %v, %v\n&quot;</span><br><span class="line">fmt.Printf(msg, 1, 2)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="5-6-6-2-使用原始字符串字符，避免转义"><a href="#5-6-6-2-使用原始字符串字符，避免转义" class="headerlink" title="5.6.6.2. 使用原始字符串字符，避免转义"></a>5.6.6.2. 使用原始字符串字符，避免转义</h5><p>Go 支持使用 原始字符串字符，也就是 “ &#96; “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := &quot;unknown name:\&quot;test\&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := `unknown error:&quot;test&quot;`</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-6-6-3-命名-Printf-样式的函数"><a href="#5-6-6-3-命名-Printf-样式的函数" class="headerlink" title="5.6.6.3. 命名 Printf 样式的函数"></a>5.6.6.3. 命名 Printf 样式的函数</h4><p>声明Printf-style 函数时，请确保go vet可以检测到它并检查格式字符串。</p>
<p>这意味着您应尽可能使用预定义的Printf-style 函数名称。go vet将默认检查这些。有关更多信息，请参见 Printf 系列。</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：Wrapf，而不是Wrap。go vet可以要求检查特定的 Printf 样式名称，但名称必须以f结尾。</p>
<p>$ go vet -printfuncs&#x3D;wrapf,statusf<br>另请参阅 go vet: Printf family check.</p>
<h2 id="6-指导原则"><a href="#6-指导原则" class="headerlink" title="6. 指导原则"></a>6. 指导原则</h2><h3 id="6-1-减少嵌套"><a href="#6-1-减少嵌套" class="headerlink" title="6.1. 减少嵌套"></a>6.1. 减少嵌套</h3><p>代码应通过尽可能先处理错误情况&#x2F;特殊情况并尽早返回或继续循环来减少嵌套（不超过3 层嵌套）。减少嵌套多个级别的代码的代码量。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range data &#123;</span><br><span class="line">  if v.F1 == 1 &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    if err := v.Call(); err == nil &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    log.Printf(&quot;Invalid v: %v&quot;, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for _, v := range data &#123;</span><br><span class="line">  if v.F1 != 1 &#123;</span><br><span class="line">    log.Printf(&quot;Invalid v: %v&quot;, v)</span><br><span class="line">    continue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  if err := v.Call(); err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-替换不必要的-else"><a href="#6-2-替换不必要的-else" class="headerlink" title="6.2. 替换不必要的 else"></a>6.2. 替换不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a int</span><br><span class="line">if b &#123;</span><br><span class="line">  a = 100</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  a = 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := 10</span><br><span class="line">if b &#123;</span><br><span class="line">  a = 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-Interface-合理性验证"><a href="#6-3-Interface-合理性验证" class="headerlink" title="6.3. Interface 合理性验证"></a>6.3. Interface 合理性验证</h3><p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口 API 的一部分进行检查</li>
<li>实现同一接口的 (导出和非导出) 类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景，都会终止编译，并通知给用户</li>
</ul>
<p>补充：上面 3 条是编译器对接口的检查机制，<br>大体意思是错误使用接口会在编译期报错。<br>所以可以利用这个机制让部分问题在编译期暴露。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 如果 Handler 没有实现 http.Handler，会在运行时报错</span><br><span class="line">type Handler struct &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">func (h *Handler) ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Handler struct &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 用于触发编译期的接口的合理性检查机制</span><br><span class="line">// 如果 Handler 没有实现 http.Handler，会在编译期报错</span><br><span class="line">var _ http.Handler = (*Handler)(nil)</span><br><span class="line">func (h *Handler) ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果 *Handler 与 http.Handler 的接口不匹配，<br>那么语句 var _ http.Handler &#x3D; (*Handler)(nil) 将无法编译通过。</li>
</ul>
<p>赋值的右边应该是断言类型的零值。<br>对于指针类型（如 *Handler）、切片和映射，这是 nil；<br>对于结构类型，这是空结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type LogHandler struct &#123;</span><br><span class="line">  h   http.Handler</span><br><span class="line">  log *zap.Logger</span><br><span class="line">&#125;</span><br><span class="line">var _ http.Handler = LogHandler&#123;&#125;</span><br><span class="line">func (h LogHandler) ServeHTTP(</span><br><span class="line">  w http.ResponseWriter,</span><br><span class="line">  r *http.Request,</span><br><span class="line">) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-接收器-receiver-与接口"><a href="#6-4-接收器-receiver-与接口" class="headerlink" title="6.4. 接收器 (receiver) 与接口"></a>6.4. 接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 addressable values 调用。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type S struct &#123;</span><br><span class="line">  data string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s S) Read() string &#123;</span><br><span class="line">  return s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *S) Write(str string) &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := map[int]S&#123;1: &#123;&quot;A&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 你只能通过值调用 Read</span><br><span class="line">sVals[1].Read()</span><br><span class="line"></span><br><span class="line">// 这不能编译通过：</span><br><span class="line">// sVals[1].Write(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">sPtrs := map[int]*S&#123;1: &#123;&quot;A&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 通过指针既可以调用 Read，也可以调用 Write 方法</span><br><span class="line">sPtrs[1].Read()</span><br><span class="line">sPtrs[1].Write(&quot;test&quot;)</span><br></pre></td></tr></table></figure>
<p>类似的，即使方法有了值接收器，也同样可以用指针接收器来满足接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type F interface &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S1 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s S1) f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">type S2 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (s *S2) f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line">var i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line">// 下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span><br><span class="line">// i = s2Val</span><br></pre></td></tr></table></figure>

<p>Effective Go 中有一段关于 pointers vs. values 的精彩讲解。</p>
<p>补充：</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集<ul>
<li>值接收器方法集是指针接收器方法集的子集，反之不是</li>
</ul>
</li>
<li>规则<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配 (或者叫实现)<ul>
<li>类型实现了接口的所有方法，叫匹配</li>
<li>具体的讲，要么是类型的值方法集匹配接口，要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种：</p>
<ul>
<li>值方法集和接口匹配<ul>
<li>给接口变量赋值的不管是值还是指针对象，都 ok，因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配<ul>
<li>只能将指针对象赋值给接口变量，因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量，会在编译期报错 (会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i &#x3D; s2Val 会报错，因为值方法集和接口不匹配。</p>
<h3 id="6-5-零值-Mutex-是有效的"><a href="#6-5-零值-Mutex-是有效的" class="headerlink" title="6.5. 零值 Mutex 是有效的"></a>6.5. 零值 Mutex 是有效的</h3><p>零值 sync.Mutex 和 sync.RWMutex 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := new(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure>
<p>如果你使用结构体指针，mutex 应该作为结构体的非指针字段。即使该结构体不被导出，也不要直接把 mutex 嵌入到结构体中。</p>
</li>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type SMap struct &#123;</span><br><span class="line">  sync.Mutex</span><br><span class="line"></span><br><span class="line">  data map[string]string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSMap() *SMap &#123;</span><br><span class="line">  return &amp;SMap&#123;</span><br><span class="line">    data: make(map[string]string),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *SMap) Get(k string) string &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  defer m.Unlock()</span><br><span class="line"></span><br><span class="line">  return m.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Mutex 字段， Lock 和 Unlock 方法是 SMap 导出的 API 中不刻意说明的一部分。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type SMap struct &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  data map[string]string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewSMap() *SMap &#123;</span><br><span class="line">  return &amp;SMap&#123;</span><br><span class="line">    data: make(map[string]string),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *SMap) Get(k string) string &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  defer m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  return m.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mutex 及其方法是 SMap 的实现细节，对其调用者不可见。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-6-在边界处拷贝-Slices-和-Maps"><a href="#6-6-在边界处拷贝-Slices-和-Maps" class="headerlink" title="6.6. 在边界处拷贝 Slices 和 Maps"></a>6.6. 在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="6-6-1-接收-Slices-和-Maps"><a href="#6-6-1-接收-Slices-和-Maps" class="headerlink" title="6.6.1. 接收 Slices 和 Maps"></a>6.6.1. 接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (d *Driver) SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line">// 你是要修改 d1.trips 吗？</span><br><span class="line">trips[0] = ...</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (d *Driver) SetTrips(trips []Trip) &#123;</span><br><span class="line">  d.trips = make([]Trip, len(trips))</span><br><span class="line">  copy(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span><br><span class="line">trips[0] = ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-6-2-返回-slices-或-maps"><a href="#6-6-2-返回-slices-或-maps" class="headerlink" title="6.6.2. 返回 slices 或 maps"></a>6.6.2. 返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">type Stats struct &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters map[string]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Snapshot 返回当前状态。</span><br><span class="line">func (s *Stats) Snapshot() map[string]int &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  defer s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  return s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// snapshot 不再受互斥锁保护</span><br><span class="line">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span><br><span class="line">// 影响 stats.counters</span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type Stats struct &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters map[string]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *Stats) Snapshot() map[string]int &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  defer s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := make(map[string]int, len(s.counters))</span><br><span class="line">  for k, v := range s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// snapshot 现在是一个拷贝</span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-7-使用-defer-释放资源"><a href="#6-7-使用-defer-释放资源" class="headerlink" title="6.7. 使用 defer 释放资源"></a>6.7. 使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line">if p.count &lt; 10 &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  return p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line">return newCount</span><br><span class="line"></span><br><span class="line">// 当有多个 return 分支时，很容易遗忘 unlock</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line">defer p.Unlock()</span><br><span class="line"></span><br><span class="line">if p.count &lt; 10 &#123;</span><br><span class="line">  return p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">return p.count</span><br><span class="line"></span><br><span class="line">// 更可读</span><br></pre></td></tr></table></figure>
Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 defer。</li>
</ul>
<h3 id="6-8-Channel-的-size-要么是-1，要么是无缓冲的"><a href="#6-8-Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="6.8. Channel 的 size 要么是 1，要么是无缓冲的"></a>6.8. Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 应该足以满足任何情况！</span><br><span class="line">c := make(chan int, 64)</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 大小：1</span><br><span class="line">c := make(chan int, 1) // 或者</span><br><span class="line">// 无缓冲 channel，大小为 0</span><br><span class="line">c := make(chan int)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-9-枚举从-1-开始"><a href="#6-9-枚举从-1-开始" class="headerlink" title="6.9. 枚举从 1 开始"></a>6.9. 枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Operation int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  Add Operation = iota</span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Add=0, Subtract=1, Multiply=2</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Operation int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  Add Operation = iota + 1</span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// Add=1, Subtract=2, Multiply=3</span><br></pre></td></tr></table></figure>
在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type LogOutput int</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">  LogToStdout LogOutput = iota</span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// LogToStdout=0, LogToFile=1, LogToRemote=2</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-10-使用-time-处理时间"><a href="#6-10-使用-time-处理时间" class="headerlink" title="6.10. 使用 time 处理时间"></a>6.10. 使用 time 处理时间</h3><p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ul>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li>还有更多</li>
</ul>
<p>例如，1 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 “time” 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<h4 id="6-10-1-使用-time-Time-表达瞬时时间"><a href="#6-10-1-使用-time-Time-表达瞬时时间" class="headerlink" title="6.10.1. 使用 time.Time 表达瞬时时间"></a>6.10.1. 使用 time.Time 表达瞬时时间</h4><p>在处理时间的瞬间时使用 time.Time，在比较、添加或减去时间时使用 time.Time 中的方法。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isActive(now, start, stop int) bool &#123;</span><br><span class="line">  return start &lt;= now &amp;&amp; now &lt; stop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isActive(now, start, stop time.Time) bool &#123;</span><br><span class="line">  return (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-10-2-使用-time-Duration-表达时间段"><a href="#6-10-2-使用-time-Duration-表达时间段" class="headerlink" title="6.10.2. 使用 time.Duration 表达时间段"></a>6.10.2. 使用 time.Duration 表达时间段</h4><p>在处理时间段时使用 time.Duration .</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func poll(delay int) &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">    // ...</span><br><span class="line">    time.Sleep(time.Duration(delay) * time.Millisecond)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(10) // 是几秒钟还是几毫秒？</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func poll(delay time.Duration) &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">    // ...</span><br><span class="line">    time.Sleep(delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">poll(10*time.Second)</span><br></pre></td></tr></table></figure>
回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日 (当前天的下一天) 的同一个时间点，我们应该使用 Time.AddDate。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 Time.Add。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)</span><br><span class="line">maybeNewDay := t.Add(24 * time.Hour)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-10-3-对外部系统使用-time-Time-和-time-Duration"><a href="#6-10-3-对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="6.10.3. 对外部系统使用 time.Time 和 time.Duration"></a>6.10.3. 对外部系统使用 time.Time 和 time.Duration</h4><p>尽可能在与外部系统的交互中使用 time.Duration 和 time.Time 例如 :</p>
<ul>
<li>Command-line 标志: flag 通过 time.ParseDuration 支持 time.Duration</li>
<li></li>
<li>JSON: encoding&#x2F;json 通过其 UnmarshalJSON method 方法支持将 time.Time 编码为 RFC 3339 字符串</li>
<li></li>
<li>SQL: database&#x2F;sql 支持将 DATETIME 或 TIMESTAMP 列转换为 time.Time，如果底层驱动程序支持则返回</li>
<li></li>
<li>YAML: gopkg.in&#x2F;yaml.v2 支持将 time.Time 作为 RFC 3339 字符串，并通过 time.ParseDuration 支持 time.Duration。</li>
</ul>
<p>当不能在这些交互中使用 time.Duration 时，请使用 int 或 float64，并在字段名称中包含单位。</p>
<p>例如，由于 encoding&#x2F;json 不支持 time.Duration，因此该单位包含在字段的名称中。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &#123;&quot;interval&quot;: 2&#125;</span><br><span class="line">type Config struct &#123;</span><br><span class="line">  Interval int `json:&quot;interval&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &#123;&quot;intervalMillis&quot;: 2000&#125;</span><br><span class="line">type Config struct &#123;</span><br><span class="line">  IntervalMillis int `json:&quot;intervalMillis&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当在这些交互中不能使用 time.Time 时，除非达成一致，否则使用 string 和 RFC 3339 中定义的格式时间戳。默认情况下，Time.UnmarshalText 使用此格式，并可通过 time.RFC3339 在 Time.Format 和 time.Parse 中使用。</li>
</ul>
<p>尽管这在实践中并不成问题，但请记住，”time” 包不支持解析闰秒时间戳（8728），也不在计算中考虑闰秒（15190）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<h3 id="6-11-Errors"><a href="#6-11-Errors" class="headerlink" title="6.11. Errors"></a>6.11. Errors</h3><h4 id="6-11-1-错误类型"><a href="#6-11-1-错误类型" class="headerlink" title="6.11.1. 错误类型"></a>6.11.1. 错误类型</h4><p>声明错误的选项很少。</p>
<p>在选择最适合您的用例的选项之前，请考虑以下事项。</p>
<ul>
<li><p>调用者是否需要匹配错误以便他们可以处理它？<br>如果是，我们必须通过声明顶级错误变量或自定义类型来支持 errors.Is 或 errors.As 函数。</p>
</li>
<li><p>错误消息是否为静态字符串，还是需要上下文信息的动态字符串？<br>如果是静态字符串，我们可以使用 errors.New，但对于后者，我们必须使用 fmt.Errorf 或自定义错误类型。</p>
</li>
<li><p>我们是否正在传递由下游函数返回的新错误？<br>如果是这样，请参阅错误包装部分。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>错误匹配？</th>
<th>错误消息</th>
<th>指导</th>
</tr>
</thead>
<tbody><tr>
<td>No</td>
<td>static</td>
<td>errors.New</td>
</tr>
<tr>
<td>No</td>
<td>dynamic</td>
<td>fmt.Errorf</td>
</tr>
<tr>
<td>Yes</td>
<td>static</td>
<td>top-level var with errors.New</td>
</tr>
<tr>
<td>Yes</td>
<td>dynamic</td>
<td>custom error type</td>
</tr>
</tbody></table>
<p>例如，<br>使用 errors.New 表示带有静态字符串的错误。<br>如果调用者需要匹配并处理此错误，则将此错误导出为变量以支持将其与 errors.Is 匹配。</p>
<ul>
<li>无错误匹配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// package foo</span><br><span class="line"></span><br><span class="line">func Open() error &#123;</span><br><span class="line">  return errors.New(&quot;could not open&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package bar</span><br><span class="line"></span><br><span class="line">if err := foo.Open(); err != nil &#123;</span><br><span class="line">  // Can&#x27;t handle the error.</span><br><span class="line">  panic(&quot;unknown error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>错误匹配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// package foo</span><br><span class="line"></span><br><span class="line">var ErrCouldNotOpen = errors.New(&quot;could not open&quot;)</span><br><span class="line"></span><br><span class="line">func Open() error &#123;</span><br><span class="line">  return ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package bar</span><br><span class="line"></span><br><span class="line">if err := foo.Open(); err != nil &#123;</span><br><span class="line">  if errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    // handle the error</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    panic(&quot;unknown error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于动态字符串的错误，<br>如果调用者不需要匹配它，则使用 fmt.Errorf，<br>如果调用者确实需要匹配它，则自定义 error。</li>
<li>无错误匹配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// package foo</span><br><span class="line"></span><br><span class="line">func Open(file string) error &#123;</span><br><span class="line">  return fmt.Errorf(&quot;file %q not found&quot;, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// package bar</span><br><span class="line"></span><br><span class="line">if err := foo.Open(&quot;testfile.txt&quot;); err != nil &#123;</span><br><span class="line">  // Can&#x27;t handle the error.</span><br><span class="line">  panic(&quot;unknown error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>错误匹配<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// package foo</span><br><span class="line"></span><br><span class="line">type NotFoundError struct &#123;</span><br><span class="line">  File string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *NotFoundError) Error() string &#123;</span><br><span class="line">  return fmt.Sprintf(&quot;file %q not found&quot;, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Open(file string) error &#123;</span><br><span class="line">  return &amp;NotFoundError&#123;File: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// package bar</span><br><span class="line"></span><br><span class="line">if err := foo.Open(&quot;testfile.txt&quot;); err != nil &#123;</span><br><span class="line">  var notFound *NotFoundError</span><br><span class="line">  if errors.As(err, &amp;notFound) &#123;</span><br><span class="line">    // handle the error</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    panic(&quot;unknown error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
请注意，如果您从包中导出错误变量或类型，<br>它们将成为包的公共 API 的一部分。</li>
</ul>
<h4 id="6-11-2-错误包装"><a href="#6-11-2-错误包装" class="headerlink" title="6.11.2. 错误包装"></a>6.11.2. 错误包装</h4><p>如果调用失败，有三种主要的错误调用选项：</p>
<ul>
<li>按原样返回原始错误</li>
<li>add context with fmt.Errorf and the %w verb</li>
<li>使用fmt.Errorf和%w</li>
<li>使用 fmt.Errorf 和 %v</li>
</ul>
<p>如果没有要添加的其他上下文，则按原样返回原始错误。<br>这将保留原始错误类型和消息。<br>这非常适合底层错误消息有足够的信息来追踪它来自哪里的错误。  </p>
<p>否则，尽可能在错误消息中添加上下文<br>这样就不会出现诸如“连接被拒绝”之类的模糊错误，<br>您会收到更多有用的错误，例如“呼叫服务 foo：连接被拒绝”。  </p>
<p>使用 fmt.Errorf 为你的错误添加上下文，<br>根据调用者是否应该能够匹配和提取根本原因，在 %w 或 %v 动词之间进行选择。  </p>
<ul>
<li>如果调用者应该可以访问底层错误，请使用 %w。<br>对于大多数包装错误，这是一个很好的默认值，<br>但请注意，调用者可能会开始依赖此行为。因此，对于包装错误是已知var或类型的情况，请将其作为函数契约的一部分进行记录和测试。</li>
<li>使用 %v 来混淆底层错误。<br>调用者将无法匹配它，但如果需要，您可以在将来切换到 %w。<br>在为返回的错误添加上下文时，通过避免使用”failed to”之类的短语来保持上下文简洁，当错误通过堆栈向上渗透时，它会一层一层被堆积起来：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return fmt.Errorf(</span><br><span class="line">        &quot;failed to create new store: %w&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return fmt.Errorf(</span><br><span class="line">        &quot;new store: %w&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// x: y: new store: the error</span><br></pre></td></tr></table></figure>
<p>然而，一旦错误被发送到另一个系统，应该清楚消息是一个错误（例如err 标签或日志中的”Failed”前缀）。</p>
<p>另见 不要只检查错误，优雅地处理它们。</p>
<h4 id="6-11-3-错误命名"><a href="#6-11-3-错误命名" class="headerlink" title="6.11.3. 错误命名"></a>6.11.3. 错误命名</h4><p>对于存储为全局变量的错误值，<br>根据是否导出，使用前缀 Err 或 err。<br>请看指南 对于未导出的顶层常量和变量，使用_作为前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">  // 导出以下两个错误，以便此包的用户可以将它们与 errors.Is 进行匹配。</span><br><span class="line"></span><br><span class="line">  ErrBrokenLink = errors.New(&quot;link is broken&quot;)</span><br><span class="line">  ErrCouldNotOpen = errors.New(&quot;could not open&quot;)</span><br><span class="line"></span><br><span class="line">  // 这个错误没有被导出，因为我们不想让它成为我们公共 API 的一部分。 我们可能仍然在带有错误的包内使用它。</span><br><span class="line"></span><br><span class="line">  errNotFound = errors.New(&quot;not found&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于自定义错误类型，请改用后缀 Error。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 同样，这个错误被导出，以便这个包的用户可以将它与 errors.As 匹配。</span><br><span class="line"></span><br><span class="line">type NotFoundError struct &#123;</span><br><span class="line">  File string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *NotFoundError) Error() string &#123;</span><br><span class="line">  return fmt.Sprintf(&quot;file %q not found&quot;, e.File)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 并且这个错误没有被导出，因为我们不想让它成为公共 API 的一部分。 我们仍然可以在带有 errors.As 的包中使用它。</span><br><span class="line">type resolveError struct &#123;</span><br><span class="line">  Path string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *resolveError) Error() string &#123;</span><br><span class="line">  return fmt.Sprintf(&quot;resolve %q&quot;, e.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-12-处理断言失败"><a href="#6-12-处理断言失败" class="headerlink" title="6.12. 处理断言失败"></a>6.12. 处理断言失败</h3><p>类型断言 将会在检测到不正确的类型时，以单一返回值形式返回 panic。 因此，请始终使用“逗号 ok”习语。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(string)</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(string)</span><br><span class="line">if !ok &#123;</span><br><span class="line">  // 优雅地处理错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-13-不要使用-panic"><a href="#6-13-不要使用-panic" class="headerlink" title="6.13. 不要使用 panic"></a>6.13. 不要使用 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 级联失败 的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func run(args []string) &#123;</span><br><span class="line">  if len(args) == 0 &#123;</span><br><span class="line">    panic(&quot;an argument is required&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  run(os.Args[1:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Godd<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func run(args []string) error &#123;</span><br><span class="line">  if len(args) == 0 &#123;</span><br><span class="line">    return errors.New(&quot;an argument is required&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">  return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  if err := run(os.Args[1:]); err != nil &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
panic&#x2F;recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</li>
</ul>
<p>即使在测试代码中，也优先使用t.Fatal或者t.FailNow而不是 panic 来确保失败被标记。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// func TestFoo(t *testing.T)</span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(&quot;&quot;, &quot;test&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">  panic(&quot;failed to set up test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// func TestFoo(t *testing.T)</span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(&quot;&quot;, &quot;test&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">  t.Fatal(&quot;failed to set up test&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-14-使用-go-uber-org-x2F-atomic"><a href="#6-14-使用-go-uber-org-x2F-atomic" class="headerlink" title="6.14. 使用 go.uber.org&#x2F;atomic"></a>6.14. 使用 go.uber.org&#x2F;atomic</h3><p>使用 sync&#x2F;atomic 包的原子操作对原始类型 (int32, int64等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p>go.uber.org&#x2F;atomic 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的atomic.Bool类型。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">  running int32  // atomic</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f* foo) start() &#123;</span><br><span class="line">  if atomic.SwapInt32(&amp;f.running, 1) == 1 &#123;</span><br><span class="line">     // already running…</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  // start the Foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *foo) isRunning() bool &#123;</span><br><span class="line">  return f.running == 1  // race!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *foo) start() &#123;</span><br><span class="line">  if f.running.Swap(true) &#123;</span><br><span class="line">     // already running…</span><br><span class="line">     return</span><br><span class="line">  &#125;</span><br><span class="line">  // start the Foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *foo) isRunning() bool &#123;</span><br><span class="line">  return f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-15-避免可变全局变量"><a href="#6-15-避免可变全局变量" class="headerlink" title="6.15. 避免可变全局变量"></a>6.15. 避免可变全局变量</h3><p>使用选择依赖注入方式避免改变全局变量。<br>既适用于函数指针又适用于其他值类型</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// sign.go</span><br><span class="line">var _timeNow = time.Now</span><br><span class="line">func sign(msg string) string &#123;</span><br><span class="line">  now := _timeNow()</span><br><span class="line">  return signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sign_test.go</span><br><span class="line">func TestSign(t *testing.T) &#123;</span><br><span class="line">  oldTimeNow := _timeNow</span><br><span class="line">  _timeNow = func() time.Time &#123;</span><br><span class="line">    return someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  defer func() &#123; _timeNow = oldTimeNow &#125;()</span><br><span class="line">  assert.Equal(t, want, sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// sign.go</span><br><span class="line">type signer struct &#123;</span><br><span class="line">  now func() time.Time</span><br><span class="line">&#125;</span><br><span class="line">func newSigner() *signer &#123;</span><br><span class="line">  return &amp;signer&#123;</span><br><span class="line">    now: time.Now,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (s *signer) Sign(msg string) string &#123;</span><br><span class="line">  now := s.now()</span><br><span class="line">  return signWithTime(msg, now)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// sign_test.go</span><br><span class="line">func TestSigner(t *testing.T) &#123;</span><br><span class="line">  s := newSigner()</span><br><span class="line">  s.now = func() time.Time &#123;</span><br><span class="line">    return someFixedTime</span><br><span class="line">  &#125;</span><br><span class="line">  assert.Equal(t, want, s.Sign(give))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-16-避免在公共结构中嵌入类型"><a href="#6-16-避免在公共结构中嵌入类型" class="headerlink" title="6.16. 避免在公共结构中嵌入类型"></a>6.16. 避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 AbstractList 实现了多种列表类型，请避免在具体的列表实现中嵌入 AbstractList。<br>相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type AbstractList struct &#123;&#125;</span><br><span class="line">// 添加将实体添加到列表中。</span><br><span class="line">func (l *AbstractList) Add(e Entity) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// 移除从列表中移除实体。</span><br><span class="line">func (l *AbstractList) Remove(e Entity) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ConcreteList 是一个实体列表。</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  *AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ConcreteList 是一个实体列表。</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  list *AbstractList</span><br><span class="line">&#125;</span><br><span class="line">// 添加将实体添加到列表中。</span><br><span class="line">func (l *ConcreteList) Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line">// 移除从列表中移除实体。</span><br><span class="line">func (l *ConcreteList) Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Go 允许 类型嵌入 作为继承和组合之间的折衷。外部类型获取嵌入类型的方法的隐式副本。默认情况下，这些方法委托给嵌入实例的同一方法。</li>
</ul>
<p>结构还获得与类型同名的字段。<br>所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。<br>这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 interface，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AbstractList 是各种实体列表的通用实现。</span><br><span class="line">type AbstractList interface &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line">// ConcreteList 是一个实体列表。</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  AbstractList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// AbstractList 是各种实体列表的通用实现。</span><br><span class="line">type AbstractList interface &#123;</span><br><span class="line">  Add(Entity)</span><br><span class="line">  Remove(Entity)</span><br><span class="line">&#125;</span><br><span class="line">// ConcreteList 是一个实体列表。</span><br><span class="line">type ConcreteList struct &#123;</span><br><span class="line">  list AbstractList</span><br><span class="line">&#125;</span><br><span class="line">// 添加将实体添加到列表中。</span><br><span class="line">func (l *ConcreteList) Add(e Entity) &#123;</span><br><span class="line">  l.list.Add(e)</span><br><span class="line">&#125;</span><br><span class="line">// 移除从列表中移除实体。</span><br><span class="line">func (l *ConcreteList) Remove(e Entity) &#123;</span><br><span class="line">  l.list.Remove(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是使用嵌入结构还是嵌入接口，都会限制类型的演化。</p>
</li>
<li><p>向嵌入接口添加方法是一个破坏性的改变。</p>
</li>
<li><p>从嵌入结构体删除方法是一个破坏性改变。</p>
</li>
<li><p>删除嵌入类型是一个破坏性的改变。</p>
</li>
<li><p>即使使用满足相同接口的类型替换嵌入类型，也是一个破坏性的改变。</p>
</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<p>直白点说，就是不希望结构体暴露不必要的实现（方法和属性），符号最小依赖原则</p>
<h3 id="6-17-避免使用内置名称"><a href="#6-17-避免使用内置名称" class="headerlink" title="6.17. 避免使用内置名称"></a>6.17. 避免使用内置名称</h3><p>Go 语言规范 概述了几个内置的，<br>不应在 Go 项目中使用的 预先声明的标识符。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，<br>将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。<br>在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var error string</span><br><span class="line">// `error` 作用域隐式覆盖</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">func handleErrorMessage(error string) &#123;</span><br><span class="line">    // `error` 作用域隐式覆盖</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Foo struct &#123;</span><br><span class="line">    // 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。</span><br><span class="line">    error  error</span><br><span class="line">    string string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f Foo) Error() error &#123;</span><br><span class="line">    // `error` 和 `f.error` 在视觉上是相似的</span><br><span class="line">    return f.error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f Foo) String() string &#123;</span><br><span class="line">    // `string` and `f.string` 在视觉上是相似的</span><br><span class="line">    return f.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var errorMessage string</span><br><span class="line">// `error` 指向内置的非覆盖</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">func handleErrorMessage(msg string) &#123;</span><br><span class="line">    // `error` 指向内置的非覆盖</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Foo struct &#123;</span><br><span class="line">    // `error` and `string` 现在是明确的。</span><br><span class="line">    err error</span><br><span class="line">    str string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f Foo) Error() error &#123;</span><br><span class="line">    return f.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f Foo) String() string &#123;</span><br><span class="line">    return f.str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意，编译器在使用预先分隔的标识符时不会生成错误，<br>但是诸如go vet之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="6-18-追加时优先指定切片容量"><a href="#6-18-追加时优先指定切片容量" class="headerlink" title="6.18. 追加时优先指定切片容量"></a>6.18. 追加时优先指定切片容量</h3><p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为make()提供一个容量值。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := make([]int, 0)</span><br><span class="line">  for k := 0; k &lt; size; k++&#123;</span><br><span class="line">    data = append(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := make([]int, 0, size)</span><br><span class="line">  for k := 0; k &lt; size; k++&#123;</span><br><span class="line">    data = append(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-19-主函数退出方式-Exit"><a href="#6-19-主函数退出方式-Exit" class="headerlink" title="6.19. 主函数退出方式 (Exit)"></a>6.19. 主函数退出方式 (Exit)</h3><p>Go 程序使用 os.Exit 或者 log.Fatal* 立即退出 (使用panic不是退出程序的好方法，请 不要使用 panic。)</p>
<p>仅在main() 中调用其中一个 os.Exit 或者 log.Fatal*。所有其他函数应将错误返回到信号失败中。</p>
<ul>
<li><p>Bad</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  body := readFile(path)</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line">func readFile(path string) string &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  return string(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Good</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">  body, err := readFile(path)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(body)</span><br><span class="line">&#125;</span><br><span class="line">func readFile(path string) (string, error) &#123;</span><br><span class="line">  f, err := os.Open(path)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return &quot;&quot;, err</span><br><span class="line">  &#125;</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return &quot;&quot;, err</span><br><span class="line">  &#125;</span><br><span class="line">  return string(b), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则上： 有多个退出入口的程序存在一些问题：</p>
</li>
<li><p>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</p>
</li>
<li><p>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 go test 尚未运行的其他测试的风险。</p>
</li>
<li><p>跳过清理：当函数退出程序时，会跳过已经进入defer队列里的函数调用。这增加了跳过重要清理任务的风险。</p>
</li>
</ul>
<h5 id="1-6-19-1-一次性退出"><a href="#1-6-19-1-一次性退出" class="headerlink" title="1.6.19.1. 一次性退出"></a>1.6.19.1. 一次性退出</h5><p>如果可能的话，你的main（）函数中 最多一次 调用 os.Exit或者log.Fatal。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。<br>这会缩短 main() 函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">  args := os.Args[1:]</span><br><span class="line">  if len(args) != 1 &#123;</span><br><span class="line">    log.Fatal(&quot;missing file&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[0]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  defer f.Close()</span><br><span class="line">  // 如果我们调用 log.Fatal 在这条线之后</span><br><span class="line">  // f.Close 将会被执行。</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">  if err := run(); err != nil &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func run() error &#123;</span><br><span class="line">  args := os.Args[1:]</span><br><span class="line">  if len(args) != 1 &#123;</span><br><span class="line">    return errors.New(&quot;missing file&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  name := args[0]</span><br><span class="line">  f, err := os.Open(name)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line">  defer f.Close()</span><br><span class="line">  b, err := ioutil.ReadAll(f)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-性能"><a href="#7-性能" class="headerlink" title="7. 性能"></a>7. 性能</h2><p>性能方面的特定准则只适用于高频场景。普通场景下<strong>【非强制】</strong></p>
<h3 id="7-1-优先使用-strconv-而不是-fmt"><a href="#7-1-优先使用-strconv-而不是-fmt" class="headerlink" title="7.1. 优先使用 strconv 而不是 fmt"></a>7.1. 优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，strconv速度比fmt快。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkFmtSprint-4    143 ns/op    2 allocs/op</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-2-避免字符串到字节的转换"><a href="#7-2-避免字符串到字节的转换" class="headerlink" title="7.2. 避免字符串到字节的转换"></a>7.2. 避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]byte(&quot;Hello world&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data := []byte(&quot;Hello world&quot;)</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-指定容器容量"><a href="#7-3-指定容器容量" class="headerlink" title="7.3. 指定容器容量"></a>7.3. 指定容器容量</h3><p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="7-3-1-指定-Map-容量提示"><a href="#7-3-1-指定-Map-容量提示" class="headerlink" title="7.3.1. 指定 Map 容量提示"></a>7.3.1. 指定 Map 容量提示</h4><p>在尽可能的情况下，在使用 make() 初始化的时候提供容量信息</p>
<p>make(map[T1]T2, hint)</p>
<p>向make()提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。</p>
<p>注意，与 slices 不同。map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量。<br>因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(&quot;./files&quot;)</span><br><span class="line">for _, f := range files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">files, _ := ioutil.ReadDir(&quot;./files&quot;)</span><br><span class="line"></span><br><span class="line">m := make(map[string]os.FileInfo, len(files))</span><br><span class="line">for _, f := range files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// m 是有大小提示创建的；在运行时可能会有更少的分配。</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-3-2-指定切片容量"><a href="#7-3-2-指定切片容量" class="headerlink" title="7.3.2. 指定切片容量"></a>7.3.2. 指定切片容量</h4><p>在尽可能的情况下，在使用make()初始化切片时提供容量信息，特别是在追加切片时。</p>
<p>make([]T, length, capacity)</p>
<p>与 maps 不同，slice capacity 不是一个提示：编译器将为提供给make()的 slice 的容量分配足够的内存，<br>这意味着后续的 append()&#96;操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。</p>
<ul>
<li>Bad<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := make([]int, 0)</span><br><span class="line">  for k := 0; k &lt; size; k++&#123;</span><br><span class="line">    data = append(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkBad-4    100000000    2.48s</span><br></pre></td></tr></table></figure></li>
<li>Good<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for n := 0; n &lt; b.N; n++ &#123;</span><br><span class="line">  data := make([]int, 0, size)</span><br><span class="line">  for k := 0; k &lt; size; k++&#123;</span><br><span class="line">    data = append(data, k)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BenchmarkGood-4   100000000    0.21s</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-代码检查工具"><a href="#8-代码检查工具" class="headerlink" title="8. 代码检查工具"></a>8. 代码检查工具</h2><p>比任何 “blessed” linter 集更重要的是，lint 在一个代码库中始终保持一致。</p>
<p>要求至少使用以下 linters，因为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li><p>errcheck 以确保错误得到处理</p>
</li>
<li><p>goimports 格式化代码和管理 imports</p>
</li>
<li><p>golint 指出常见的文体错误</p>
</li>
<li><p>govet 分析代码中的常见错误</p>
</li>
</ul>

    </div>
    
  </div>
</article>
<div id="toc" class="toc-article">
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go-checklist"><span class="toc-text">go checklist</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2. 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%A7%84%E8%8C%83%E5%AE%9E%E6%96%BD%E6%96%B9%E6%B3%95"><span class="toc-text">3. 规范实施方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B7%A5%E7%A8%8B%E8%A6%81%E6%B1%82"><span class="toc-text">4. 工程要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%84%E8%8C%83"><span class="toc-text">5. 规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9F%BA%E6%9C%AC%E7%BA%A6%E5%AE%9A"><span class="toc-text">5.1. 基本约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%88%86%E7%BB%84%E8%A7%84%E8%8C%83"><span class="toc-text">5.2. 分组规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">5.3. 命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83"><span class="toc-text">5.4. 注释规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E6%B3%A8%E9%87%8A%E9%A3%8E%E6%A0%BC"><span class="toc-text">5.4.1. 注释风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A7%84%E8%8C%83"><span class="toc-text">5.5. 单元测试规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E8%A7%84%E8%8C%83"><span class="toc-text">5.6. 代码逻辑规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-2-1-%E9%81%BF%E5%85%8D%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%E4%B8%8D%E6%98%8E%E7%A1%AE-Avoid-Naked-Parameters"><span class="toc-text">5.6.2.1. 避免参数语义不明确 (Avoid Naked Parameters)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8C%87%E5%AF%BC%E5%8E%9F%E5%88%99"><span class="toc-text">6. 指导原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97"><span class="toc-text">6.1. 减少嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%9B%BF%E6%8D%A2%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84-else"><span class="toc-text">6.2. 替换不必要的 else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Interface-%E5%90%88%E7%90%86%E6%80%A7%E9%AA%8C%E8%AF%81"><span class="toc-text">6.3. Interface 合理性验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%8E%A5%E6%94%B6%E5%99%A8-receiver-%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.4. 接收器 (receiver) 与接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E9%9B%B6%E5%80%BC-Mutex-%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84"><span class="toc-text">6.5. 零值 Mutex 是有效的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%9C%A8%E8%BE%B9%E7%95%8C%E5%A4%84%E6%8B%B7%E8%B4%9D-Slices-%E5%92%8C-Maps"><span class="toc-text">6.6. 在边界处拷贝 Slices 和 Maps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E4%BD%BF%E7%94%A8-defer-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-text">6.7. 使用 defer 释放资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-Channel-%E7%9A%84-size-%E8%A6%81%E4%B9%88%E6%98%AF-1%EF%BC%8C%E8%A6%81%E4%B9%88%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84"><span class="toc-text">6.8. Channel 的 size 要么是 1，要么是无缓冲的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%9E%9A%E4%B8%BE%E4%BB%8E-1-%E5%BC%80%E5%A7%8B"><span class="toc-text">6.9. 枚举从 1 开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E4%BD%BF%E7%94%A8-time-%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="toc-text">6.10. 使用 time 处理时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-Errors"><span class="toc-text">6.11. Errors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-%E5%A4%84%E7%90%86%E6%96%AD%E8%A8%80%E5%A4%B1%E8%B4%A5"><span class="toc-text">6.12. 处理断言失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-13-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-panic"><span class="toc-text">6.13. 不要使用 panic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-14-%E4%BD%BF%E7%94%A8-go-uber-org-x2F-atomic"><span class="toc-text">6.14. 使用 go.uber.org&#x2F;atomic</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-15-%E9%81%BF%E5%85%8D%E5%8F%AF%E5%8F%98%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">6.15. 避免可变全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-16-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84%E4%B8%AD%E5%B5%8C%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">6.16. 避免在公共结构中嵌入类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-17-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE%E5%90%8D%E7%A7%B0"><span class="toc-text">6.17. 避免使用内置名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-18-%E8%BF%BD%E5%8A%A0%E6%97%B6%E4%BC%98%E5%85%88%E6%8C%87%E5%AE%9A%E5%88%87%E7%89%87%E5%AE%B9%E9%87%8F"><span class="toc-text">6.18. 追加时优先指定切片容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-19-%E4%B8%BB%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F-Exit"><span class="toc-text">6.19. 主函数退出方式 (Exit)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%A7%E8%83%BD"><span class="toc-text">7. 性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-strconv-%E8%80%8C%E4%B8%8D%E6%98%AF-fmt"><span class="toc-text">7.1. 优先使用 strconv 而不是 fmt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%81%BF%E5%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%B0%E5%AD%97%E8%8A%82%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">7.2. 避免字符串到字节的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8%E5%AE%B9%E9%87%8F"><span class="toc-text">7.3. 指定容器容量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7"><span class="toc-text">8. 代码检查工具</span></a></li></ol></li></ol>
</div></section>
        </div>
        <!-- <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            Dalin &copy; 2023 
            <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a target="_blank" rel="noopener" href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            
        </div>
    </div>
</footer> -->
        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>
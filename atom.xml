<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dalin blog</title>
  
  
  <link href="https://tianxiafeiyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://tianxiafeiyu.github.io/"/>
  <updated>2022-12-15T16:14:36.455Z</updated>
  <id>https://tianxiafeiyu.github.io/</id>
  
  <author>
    <name>Dalin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/Linux%20shell%20%E5%90%84%E7%A7%8D%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/Linux%20shell%20%E5%90%84%E7%A7%8D%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、小括号，圆括号（）"><a href="#一、小括号，圆括号（）" class="headerlink" title="一、小括号，圆括号（）"></a>一、小括号，圆括号（）</h1><h2 id="1、单小括号"><a href="#1、单小括号" class="headerlink" title="1、单小括号 ()"></a>1、单小括号 ()</h2><p>①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</p><p>②命令替换。等同于cmd，shell扫描一遍命令行，发现了结构，便将(cmd)结构，便将(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</p><p>③用于初始化数组。如：array&#x3D;(a b c d)</p><h2 id="2、双小括号"><a href="#2、双小括号" class="headerlink" title="2、双小括号 (( ))"></a>2、双小括号 (( ))</h2><p>①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</p><p>②只要括号中的运算符、表达式符合C语言运算规则，都可用在((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo((16#5f)) 结果为95 (16进位转十进制)</p><p>③单纯用 (( )) 也可重定义变量值，比如 a&#x3D;5; ((a++)) 可将 $a 重定义为6</p><p>④常用于算术运算比较，双括号中的变量可以不使用符号前缀。括号内支持多个表达式用逗号分开。只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i&#x3D;0;i&lt;5;i++)),如果不使用双括号,则为foriin‘seq04‘或者foriin0..4。再如可以直接使用if((i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。</p><h1 id="二、中括号，方括号"><a href="#二、中括号，方括号" class="headerlink" title="二、中括号，方括号[]"></a>二、中括号，方括号[]</h1><h2 id="1、单中括号"><a href="#1、单中括号" class="headerlink" title="1、单中括号 []"></a>1、单中括号 []</h2><p>①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if&#x2F;test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if&#x2F;test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</p><p>②Test和[]中可用的比较运算符只有&#x3D;&#x3D;和!&#x3D;，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</p><p>③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</p><p>④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</p><h2 id="2、双中括号"><a href="#2、双中括号" class="headerlink" title="2、双中括号[[ ]]"></a>2、双中括号[[ ]]</h2><p>①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</p><p>②支持字符串的模式匹配，使用&#x3D;~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello &#x3D;&#x3D; hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</p><p>③使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a !&#x3D; 1 &amp;&amp; $a !&#x3D; 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a !&#x3D; 2 ]或者if [ $a -ne 1 -a $a !&#x3D; 2 ]。</p><p>④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ($i&lt;5) </span><br><span class="line">if [ $i -lt 5 ] </span><br><span class="line">if [ $a -ne 1 -a $a != 2 ] </span><br><span class="line">if [ $a -ne 1] &amp;&amp; [ $a != 2 ] </span><br><span class="line">if [[ $a != 1 &amp;&amp; $a != 2 ]] </span><br><span class="line">for i in $(seq 0 4);do echo $i;done</span><br><span class="line">for i in `seq 0 4`;do echo $i;done</span><br><span class="line">for ((i=0;i&lt;5;i++));do echo $i;done</span><br><span class="line">for i in &#123;0..4&#125;;do echo $i;done</span><br></pre></td></tr></table></figure><h1 id="三、大括号、花括号"><a href="#三、大括号、花括号" class="headerlink" title="三、大括号、花括号 {}"></a>三、大括号、花括号 {}</h1><h2 id="1、常规用法"><a href="#1、常规用法" class="headerlink" title="1、常规用法"></a>1、常规用法</h2><p>①大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ls &#123;ex1,ex2&#125;.sh </span><br><span class="line">ex1.sh ex2.sh </span><br><span class="line"># ls &#123;ex&#123;1..3&#125;,ex4&#125;.sh </span><br><span class="line">ex1.sh ex2.sh ex3.sh ex4.sh </span><br><span class="line"># ls &#123;ex[1-3],ex4&#125;.sh </span><br><span class="line">ex1.sh ex2.sh ex3.sh ex4.sh</span><br></pre></td></tr></table></figure><p>②代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，QQ号码买卖即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</p><h2 id="2、几种特殊的替换结构"><a href="#2、几种特殊的替换结构" class="headerlink" title="2、几种特殊的替换结构"></a>2、几种特殊的替换结构</h2><p>${var:-string},${var:+string},${var:&#x3D;string},${var:?string}</p><p>①${var:-string}和${var:&#x3D;string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:&#x3D;string}的替换规则和${var:-string}是一样的，所不同之处是${var:&#x3D;string}若var为空时，用string替换${var:&#x3D;string}的同时，把string赋给变量var：${var:&#x3D;string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</p><p>② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) </p><p>③${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。</p><p>补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p><h2 id="3、四种模式匹配替换结构"><a href="#3、四种模式匹配替换结构" class="headerlink" title="3、四种模式匹配替换结构"></a>3、四种模式匹配替换结构</h2><p>模式匹配记忆方法：</p><p>#是去掉左边(在键盘上#在$之左边)</p><p>%是去掉右边(在键盘上%在$之右边)</p><p>#和%中的单一符号是最小匹配，两个相同符号是最大匹配。</p><p>${var%pattern},${var%%pattern},${var#pattern},${var##pattern}<br>第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式</p><p>第二种模式：${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p><p>第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式</p><p>第四种模式：${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式</p><p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了<em>匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，</em>表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># var=testcase </span><br><span class="line"># echo $var </span><br><span class="line">testcase </span><br><span class="line"># echo $&#123;var%s*e&#125; </span><br><span class="line">testca </span><br><span class="line"># echo $var </span><br><span class="line">testcase </span><br><span class="line"># echo $&#123;var%%s*e&#125; </span><br><span class="line">te </span><br><span class="line"># echo $&#123;var#?e&#125; </span><br><span class="line">stcase </span><br><span class="line"># echo $&#123;var##?e&#125; </span><br><span class="line">stcase </span><br><span class="line"># echo $&#123;var##*e&#125;</span><br><span class="line"># echo $&#123;var##*s&#125; </span><br><span class="line">e </span><br><span class="line"># echo $&#123;var##test&#125; </span><br><span class="line">case</span><br></pre></td></tr></table></figure><h2 id="4、字符串提取和替换"><a href="#4、字符串提取和替换" class="headerlink" title="4、字符串提取和替换"></a>4、字符串提取和替换</h2><p>${var:num},${var:num1:num2},${var&#x2F;pattern&#x2F;pattern},${var&#x2F;&#x2F;pattern&#x2F;pattern}</p><p>第一种模式：${var:num}，这种模式时，shell在 var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。       </p><p>第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。</p><p>第三种模式：${var&#x2F;pattern&#x2F;pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。</p><p>第四种模式：${var&#x2F;&#x2F;pattern&#x2F;pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# var=/home/centos </span><br><span class="line">[root@centos ~]# echo $var </span><br><span class="line">/home/centos</span><br><span class="line">[root@centos ~]# echo $&#123;var:5&#125; </span><br><span class="line">/centos</span><br><span class="line">[root@centos ~]# echo $&#123;var: -6&#125; </span><br><span class="line">centos </span><br><span class="line">[root@centos ~]# echo $&#123;var:(-6)&#125; </span><br><span class="line">centos </span><br><span class="line">[root@centos ~]# echo $&#123;var:1:4&#125; </span><br><span class="line">home </span><br><span class="line">[root@centos ~]# echo $&#123;var/o/h&#125; </span><br><span class="line">/hhme/centos</span><br><span class="line">[root@centos ~]# echo $&#123;var//o/h&#125; </span><br><span class="line">/hhme/cenths</span><br></pre></td></tr></table></figure><h1 id="四、符号-后的括号"><a href="#四、符号-后的括号" class="headerlink" title="四、符号$后的括号"></a>四、符号$后的括号</h1><p>（1）${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。</p><p>（2）$(cmd) 命令替换，和<code>cmd</code>效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。</p><p>（3）$((expression)) 和<code>exprexpression</code>效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、小括号，圆括号（）&quot;&gt;&lt;a href=&quot;#一、小括号，圆括号（）&quot; class=&quot;headerlink&quot; title=&quot;一、小括号，圆括号（）&quot;&gt;&lt;/a&gt;一、小括号，圆括号（）&lt;/h1&gt;&lt;h2 id=&quot;1、单小括号&quot;&gt;&lt;a href=&quot;#1、单小括号&quot; cla</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="os" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/lombok/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/lombok/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lombok简介"><a href="#lombok简介" class="headerlink" title="lombok简介"></a>lombok简介</h3><p>Lombok 是能自动接通编辑器和构建工具的一个Java库，对于简单的Java对象，通过注解的形式例如@Setter @Getter，可以替代代码中的getter和setter方法。Lombok中用到了注解，但是它并没有用到反射，而是在代码编译时期动态将注解替换为具体的代码。所以JVM实际运行的代码，和我们手动编写的包含了各种工具方法的类相同。</p><h4 id="lombok常用注解"><a href="#lombok常用注解" class="headerlink" title="lombok常用注解"></a>lombok常用注解</h4><ul><li>@Data：注解在类上，将类提供的所有属性都添加get、set方法，并添加、equals、canEquals、hashCode、toString方法</li><li>@Setter：注解在类上，为所有属性添加set方法、注解在属性上为该属性提供set方法</li><li>@Getter：注解在类上，为所有的属性添加get方法、注解在属性上为该属性提供get方法</li><li>@NotNull：在参数中使用时，如果调用时传了null值，就会抛出空指针异常</li><li>@NoArgsConstructor：创建一个无参构造函数</li><li>@toString：创建toString方法。</li><li>@UtilityClass:工具类</li></ul><h4 id="idea项目中使用lombok"><a href="#idea项目中使用lombok" class="headerlink" title="idea项目中使用lombok"></a>idea项目中使用lombok</h4><p>第一步： pom.xml中加入lombok依赖包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.20&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure><p>第二步：加入lombok插件<br>File —&gt; Settings —&gt; Plugins：搜索lombok，点击安装install。然后会提示重启，重启。</p><p>第三步：idea配置<br>File —&gt; Settings —&gt; Build, Execution, Deployment —&gt; Compiler —&gt; Java Compiler —&gt; User compiler：选择javac<br>File —&gt; Settings —&gt; Build, Execution, Deployment —&gt; Compiler —&gt; Annotation Processors -&gt; Enable annotation processors -&gt; 勾选</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>1、使用 lombok.Data 注解实体类时，boolean类型的get方法，会变成is方法；若需要get方法，使用封装类Boolean。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;lombok简介&quot;&gt;&lt;a href=&quot;#lombok简介&quot; class=&quot;headerlink&quot; title=&quot;lombok简介&quot;&gt;&lt;/a&gt;lombok简介&lt;/h3&gt;&lt;p&gt;Lombok 是能自动接通编辑器和构建工具的一个Java库，对于简单的Java对象，通过注解</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/null==obj%20or%20obj==null%20%EF%BC%9F/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/null==obj%20or%20obj==null%20%EF%BC%9F/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>在比较操作中，有人提倡常量前置的写法，但是读起来就会怪怪的。</p><p>据说在 c++ 中，<code>if(obj = null)</code>是可以通过编译的，但是在运行时会报错，为了防止这种情况发生，所以提倡常量前置的写法。</p><p>但是在 Java 中 <code>if(obj = null)</code>是在编译时会报错的，所以不存在这一隐患。时候判断常量前置真的没有必要了呢？其实有两面性，有好有坏，具体要看个人和规范的要求。</p><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><ol><li>可以避免<code>if(obj = null)</code>类似错误</li><li>类似<code>&quot;str&quot;.equals(obj)</code>的写法可以避免空指针错误</li></ol><h4 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h4><ol><li>影响代码可读性</li><li>使得代码存在隐患。出现了预料之外的空指针，应该积极去处理，而不是掩盖</li></ol><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><p>Boolean 类情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Boolean obj = Boolean.FALSE;</span><br><span class="line">        if(null = obj)&#123;     // 编译器报错</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Boolean obj = Boolean.FALSE;</span><br><span class="line">        if(obj = null)&#123;     // 编译器不报错，运行时报错</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算是 Java 中的特例，值得注意</p><p>反正我是喜欢常量前置的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在比较操作中，有人提倡常量前置的写法，但是读起来就会怪怪的。&lt;/p&gt;
&lt;p&gt;据说在 c++ 中，&lt;code&gt;if(obj = null)&lt;/code&gt;是可以通过编译的，但是在运行时会报错，为了防止这种情况发生，所以提倡常量前置的写法。&lt;/p&gt;
&lt;p&gt;但是在 Java 中 &lt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/skywalking%20Jdbc%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/skywalking%20Jdbc%E6%8F%92%E4%BB%B6%E5%88%86%E6%9E%90/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql-8-x-plugin"><a href="#mysql-8-x-plugin" class="headerlink" title="mysql-8.x-plugin"></a>mysql-8.x-plugin</h2><table>   <tr>      <td>拦截形式</td>      <td>增强的类</td>      <td>增强方法</td>      <td>类型</td>      <td>方法说明</td>      <td>拦截器</td>      <td>执行前</td>      <td>执行后</td>      <td>报错</td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.CallableInstrumentation</td>      <td>com.mysql.cj.jdbc.CallableStatement</td>      <td>execute、executeQuery、executeUpdate</td>      <td>实例方法</td>      <td>调用存储过程类增强，拦截存储过程的执行方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.PreparedStatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>ContextManager.stopSpan()，结束追踪</td>      <td>ContextManager.activeSpan().errorOccurred().log(t)，记录异常堆栈</td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionImplCreateInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>getInstance</td>      <td>静态方法</td>      <td>拦截获取数据库连接方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.ConnectionCreateInterceptor</td>      <td></td>      <td>记录数据库连接信息connectionInfo (dbType,dbName,dbPeer...)</td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>prepareStatement</td>      <td>实例方法</td>      <td>创建一个PreparedStatement对象，该对象用于预编译和发送sql,获得执行结果</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.CreatePreparedStatementInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>prepareCall</td>      <td>实例方法</td>      <td>创建一个CallableStatement。此对象用于调用数据库存储过程</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.CreateCallableStatementInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>createStatement,参数数量为2</td>      <td>实例方法</td>      <td>创建一个Statement对象，Statement用于发送sql语句到数据库和获得返回结果</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.CreateStatementInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName...）</td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>commit、rollback、close、releaseSavepoint</td>      <td>实例方法</td>      <td>事务相关操作</td>      <td>org.apache.skywalking.apm.plugin.jdbc.ConnectionServiceMethodInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>ContextManager.stopSpan()，结束追踪</td>      <td>ContextManager.activeSpan().errorOccurred().log(t)，记录异常堆栈</td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.ConnectionInstrumentation</td>      <td>com.mysql.cj.jdbc.ConnectionImpl</td>      <td>setCatalog</td>      <td>实例方法</td>      <td>设置给定目录名称，以便选择要在其中进行工作的此 Connection 对象数据库的子空间</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.SetCatalogInterceptor</td>      <td>获取connectionInfo，调用setDatabaseName(),记录目录名称catalog</td>      <td></td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.PreparedStatementInstrumentation</td>      <td>com.mysql.cj.jdbc.ClientPreparedStatement、com.mysql.cj.jdbc.ServerPreparedStatement</td>      <td>execute、executeQuery、executeUpdate、executeLargeUpdate</td>      <td>实例方法</td>      <td>ClientPreparedStatement是PreparedStatement接口的实现类，StatementImpl的子类；ServerPreparedStatement是ClientPreparedStatement的子类，预编译和发送sql的类</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.PreparedStatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>ContextManager.stopSpan()，结束追踪</td>      <td>ContextManager.activeSpan().errorOccurred().log(t)，记录异常堆栈</td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.PreparedStatementIgnoredSetterInstrumentation</td>      <td>com.mysql.cj.jdbc.ClientPreparedStatement、com.mysql.cj.jdbc.ServerPreparedStatement</td>      <td>setAsciiStream, setBinaryStream, setBlob, setBytes, setCharacterStream, setClob, setNCharacterStream, setNClob, setRef, setSQLXML, setUnicodeStream</td>      <td>实例方法</td>      <td>参数绑定（长文本）</td>      <td>org.apache.skywalking.apm.plugin.jdbc.JDBCPreparedStatementIgnorableSetterInterceptor</td>      <td>statementEnhanceInfos.setParameter(index, "?")，记录参数信息，避免数据太大，用”?“代替</td>      <td></td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.PreparedStatementNullSetterInstrumentation</td>      <td>com.mysql.cj.jdbc.ClientPreparedStatement、com.mysql.cj.jdbc.ServerPreparedStatement</td>      <td>setNull</td>      <td>实例方法</td>      <td>参数绑定（null）</td>      <td>org.apache.skywalking.apm.plugin.jdbc.JDBCPreparedStatementNullSetterInterceptor</td>      <td>statementEnhanceInfos.setParameter(index, "NULL")，记录参数信息</td>      <td></td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.PreparedStatementSetterInstrumentation</td>      <td>com.mysql.cj.jdbc.ClientPreparedStatement、com.mysql.cj.jdbc.ServerPreparedStatement</td>      <td>setArray, setBigDecimal, setBoolean, setByte, setDate, setDouble, setFloat, setInt, setLong, setNString, setObject, setRowId, setShort, setString, setTime, setTimestamp, setURL</td>      <td>实例方法</td>      <td>参数绑定</td>      <td>org.apache.skywalking.apm.plugin.jdbc.JDBCPreparedStatementSetterInterceptor</td>      <td>statementEnhanceInfos.setParameter(index, parameter)，记录参数信息</td>      <td></td>      <td></td>   </tr>   <tr>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.v8.define.StatementInstrumentation</td>      <td>com.mysql.cj.jdbc.StatementImpl</td>      <td>execute、executeQuery、executeUpdate、executeLargeUpdate、executeBatchInternal、executeUpdateInternal、executeQuery、executeBatch</td>      <td>实例方法</td>      <td>StatementImpl是Statement接口的实现类，用于发送sql命令，获得查询结果。</td>      <td>org.apache.skywalking.apm.plugin.jdbc.mysql.StatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>ContextManager.stopSpan()，结束追踪</td>      <td>ContextManager.activeSpan().errorOccurred().log(t)，记录异常堆栈</td>   </tr>   <tr>      <td></td>   </tr></table><h2 id="postgresql-8-x-plugin"><a href="#postgresql-8-x-plugin" class="headerlink" title="postgresql-8.x-plugin"></a>postgresql-8.x-plugin</h2><table>   <tr>      <td>拦截形式</td>      <td>增强的类</td>      <td>增强方法</td>      <td>类型</td>      <td>方法说明</td>      <td>拦截器</td>      <td>执行前</td>      <td>执行后</td>      <td>报错</td>   </tr>   <tr>      <td>AbstractJdbc2StatementInstrumentation</td>      <td>org.postgresql.jdbc2.AbstractJdbc2Statement（发行版中该类已废弃）</td>      <td>无参的execute，executeQuery，executeUpdate</td>      <td>实例方法</td>      <td>sql语句执行方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.PreparedStatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>结束追踪</td>      <td>记录错误堆栈</td>   </tr>   <tr>      <td></td>      <td></td>      <td>入参数目为1的execute，executeQuery，executeUpdate</td>      <td>实例方法</td>      <td>sql语句执行方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.StatementExecuteMethodsInterceptor</td>      <td>同上</td>      <td>同上</td>      <td>同上</td>   </tr>   <tr>      <td>ConnectionInstrumentation</td>      <td>"org.postgresql.jdbc.PgConnection，</td>   </tr>   <tr>      <td>org.postgresql.jdbc42.Jdbc42Connection（已废弃），</td>   </tr>   <tr>      <td>org.postgresql.jdbc3g.Jdbc3gConnection（已废弃），</td>   </tr>   <tr>      <td>org.postgresql.jdbc4.Jdbc4Connection（已废弃）</td>   </tr>   <tr>      <td></td>   </tr>   <tr>      <td>"</td>      <td>入参数目为4的prepareStatement</td>      <td>实例方法</td>      <td>创建一个PgPreparedStatement对象，该对象用于预编译和发送sql,获得执行结果</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.CreatePreparedStatementInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td></td>      <td></td>      <td>第二个参数类型为String[]的prepareStatement</td>      <td>实例方法</td>      <td>同上</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.JDBCPrepareStatementWithStringArrayInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td></td>      <td></td>      <td>入参数目为4的prepareCall</td>      <td>实例方法</td>      <td>创建一个CPgCallableStatement。此对象用于调用数据库存储过程</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.CreateCallableStatementInterceptor</td>      <td></td>      <td>创建PreparedStatement的代理SWPreparedStatement，记录（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td></td>      <td></td>      <td>入参数目为3的createStatement</td>      <td>实例方法</td>      <td>创建一个PgStatement，该对象用于预编译和发送sql,获得执行结果</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.CreateStatementInterceptor</td>      <td></td>      <td>记录statement信息StatementEnhanceInfos（connectionInfo,statementName,sql...）</td>      <td></td>   </tr>   <tr>      <td></td>      <td></td>      <td>commit,rollback,close,releaseSavepoint</td>      <td>实例方法</td>      <td>数据库事务相关方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.ConnectionServiceMethodInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>结束追踪</td>      <td>记录错误堆栈</td>   </tr>   <tr>      <td>Jdbc3ConnectionInstrumentation</td>      <td>org.postgresql.jdbc3.Jdbc3Connection（已废弃）</td>      <td>同ConnectionInstrumentation,应该是重复的</td>      <td>实例方法</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>Jdbc4ConnectionInstrumentation</td>      <td>org.postgresql.jdbc4.Jdbc4Connection（已废弃）</td>      <td>同上</td>      <td>实例方法</td>      <td></td>      <td></td>      <td></td>      <td></td>      <td></td>   </tr>   <tr>      <td>PgCallableStatementInstrumentation</td>      <td>org.postgresql.jdbc.PgCallableStatement</td>      <td>"第一个参数为int的executeWithFlags，</td>   </tr>   <tr>      <td>executeUpdate"</td>      <td>实例方法</td>      <td>执行sql方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.PreparedStatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>结束追踪</td>      <td>记录错误堆栈</td>   </tr>   <tr>      <td>PgPreparedStatementInstrumentation</td>      <td>org.postgresql.jdbc.PgPreparedStatement</td>      <td>"第一个参数为string的execute，</td>   </tr>   <tr>      <td>第一个参数为int的executeWithFlags,</td>   </tr>   <tr>      <td>executeQuery,</td>   </tr>   <tr>      <td>executeUpdate</td>   </tr>   <tr>      <td>"</td>      <td>实例方法</td>      <td>执行sql方法</td>      <td>同上</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>结束追踪</td>      <td>记录错误堆栈</td>   </tr>   <tr>      <td>PgPreparedStatementSetterInstrumentation</td>      <td>org.postgresql.jdbc.PgPreparedStatement</td>      <td>setAsciiStream, setBinaryStream, setBlob, setBytes, setCharacterStream, setClob, setNCharacterStream, setNClob, setRef, setSQLXML, setUnicodeStream</td>      <td>实例方法</td>      <td>参数绑定（长文本）</td>      <td>org.apache.skywalking.apm.plugin.jdbc.JDBCPreparedStatementIgnorableSetterInterceptor</td>      <td>statementEnhanceInfos.setParameter(index, "?")，记录参数信息，避免数据太大，用”?“代替</td>      <td></td>      <td></td>   </tr>   <tr>      <td>PgStatementInstrumentation</td>      <td>org.postgresql.jdbc.PgStatement</td>      <td>"第一个参数为stirng或string[]的execute，</td>   </tr>   <tr>      <td>executeQuery，</td>   </tr>   <tr>      <td>第一个参数为stirng或string[]的executeUpdate，</td>   </tr>   <tr>      <td>executeLargeUpdate，"</td>      <td>实例方法</td>      <td>执行sql方法</td>      <td>org.apache.skywalking.apm.plugin.jdbc.postgresql.StatementExecuteMethodsInterceptor</td>      <td>创建ExitSpan，追踪本次数据库调用</td>      <td>结束追踪</td>      <td>记录错误堆栈</td>   </tr>   <tr>      <td></td>   </tr></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mysql-8-x-plugin&quot;&gt;&lt;a href=&quot;#mysql-8-x-plugin&quot; class=&quot;headerlink&quot; title=&quot;mysql-8.x-plugin&quot;&gt;&lt;/a&gt;mysql-8.x-plugin&lt;/h2&gt;&lt;table&gt;
   &lt;tr&gt;
 </summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%20+%20jasypt%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%20+%20jasypt%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件敏感信息的加密，对于生产环境来说还是很有必要的。之前自己实现了一个粗糙的配置文件加密方案，详见<a href="https://note.youdao.com/ynoteshare1/index.html?id=0d316c739a394177dd492a8ff4710257&type=note">spring boot中代码修改配置文件</a>。后面有老师傅提出了有更成熟通过的方案，jasypt，本次就来使用它。</p><p>1、添加Maven依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>最新版本是2.1.1，但是只能spring-boot-2.x以上使用。因为我的程序中使用的是spring-boot-1.5.3,所以选择1.8版本。</p><p>2、编写加密脚本</p><p>下载jasypt-1.9.2.jar，添加依赖后，也可以从本地仓库中获取，如：LocalRepository\org\jasypt\jasypt\1.9.2</p><p>Windows脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">cd /d %~dp0</span><br><span class="line">cd ..</span><br><span class="line">set /p user=请输入要加密的账户名称: </span><br><span class="line">java -cp lib/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=%user% password=apusic.net algorithm=PBEWithMD5AndDES</span><br><span class="line">set /p password=请输入要加密的密码: </span><br><span class="line">java -cp lib/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=%password% password=apusic.net algorithm=PBEWithMD5AndDES</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>Linux脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">BASE_DIR=$(cd `dirname $0`; pwd)/..</span><br><span class="line">cd $BASE_DIR</span><br><span class="line"></span><br><span class="line">read -p &quot;输入要加密的账户名称：&quot; user</span><br><span class="line">java -cp $BASE_DIR/lib/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=$user password=apsuic.net algorithm=PBEWithMD5AndDES</span><br><span class="line"></span><br><span class="line">read -p &quot;输入要加密的账号密码：&quot; password</span><br><span class="line">java -cp $BASE_DIR/lib/jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=$password password=apsuic.net algorithm=PBEWithMD5AndDES</span><br></pre></td></tr></table></figure><p>运行脚本，根据提示输入账号密码后可以获得加密串</p><p>3、使用加密字符串</p><p>程序入口（main）添加注解：@EnableConfigurationProperties</p><p>配置文件中如下格式填写加密串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.user=ENC(40+Fa4B+kj2wbOQHa+JuWQ==)</span><br><span class="line">client.password=ENC(qX2Its/37OKPVUgxM38I7qgEhitVnuPV)</span><br></pre></td></tr></table></figure><p>加密串用ENC()标注</p><p>填写加密key,即jasypt.encryptor.password，可以在注入到程序运行时变量中，也可以写在配置文件中，不推荐。</p><p>运行时变量方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar lib/exporter-aas-v9-0.0.1-SNAPSHOT.jar --spring.config.location=conf/application.properties --jasypt.encryptor.password=apusic.net</span><br></pre></td></tr></table></figure><p>配置文件方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asypt.encryptor.password=apusic.net</span><br></pre></td></tr></table></figure><p>这样在程序运行时候jasypt就会先解析加密串，程序获取到的是解析后的账号密码。</p><p>完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置文件敏感信息的加密，对于生产环境来说还是很有必要的。之前自己实现了一个粗糙的配置文件加密方案，详见&lt;a href=&quot;https://note.youdao.com/ynoteshare1/index.html?id=0d316c739a394177dd492a8ff47</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%97%9B/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%97%9B/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式好处多多，是工具类中经常使用的设计模式，但是笔者在spring boot中使用单例模式中，尝到了许多痛苦的滋味。。。</p><p>Spring注解给开发带来了很多便利，要使用到这种便利，就需要使用spring的IOC注入，即类的创建需要交由spring来管理。如@Autowired，一个类如果在使用@Autowired注入了另一个类，但是当这个类被new时，@Autowired注入将会失效，出现NPE报错。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B&#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    A a;</span><br><span class="line">    </span><br><span class="line">    private static volatile B instance;</span><br><span class="line">    private B();</span><br><span class="line">    public static B getInstance()&#123;</span><br><span class="line">        if(null == instance)&#123;</span><br><span class="line">             synchronized (B.class) &#123;</span><br><span class="line">                 instance = new B(); //B的@Autowired不生效，b.a==null</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些spring辅助类是必须要交由spring注入的，比如Environment，单例模式就很不方便了。</p><p>当然，办法也是有的，可以使用<code>ApplicationContext</code>来注入Bean：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SpringUtil implements ApplicationContextAware &#123;</span><br><span class="line">    private static ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        SpringUtil.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //beanName是类名，第一个字母小写</span><br><span class="line">    public static &lt;T&gt; T getBean(String beanName) &#123;</span><br><span class="line">        if(applicationContext.containsBean(beanName))&#123;</span><br><span class="line">            return (T) applicationContext.getBean(beanName);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; baseType)&#123;</span><br><span class="line">        return applicationContext.getBeansOfType(baseType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用某一个类的时候<code>SpringUtil.getBean(beanName)</code>就可以的，坏处也是有的，无法使用全局变量，每个方法使用这个类时都需要注入一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式好处多多，是工具类中经常使用的设计模式，但是笔者在spring boot中使用单例模式中，尝到了许多痛苦的滋味。。。&lt;/p&gt;
&lt;p&gt;Spring注解给开发带来了很多便利，要使用到这种便利，就需要使用spring的IOC注入，即类的创建需要交由spring来管理。如@</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%B8%AD%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%B8%AD%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>配置文件中有用户的账号密码等信息，需要为用户保护信息。</p><p>怎么做呢？暂时没有想到很好的办法，现在设想是用户第一次使用程序时候，配置文件中明文填写账号密码等信息。启用程序连接成功后加密账号密码，输出加密字符串到配置文件中，以后使用密文进行连接。其实这也只是表面功夫，因为实际的连接需要用到明文的账号密码，必须使用对称加密还原账号密码，加密key是写在程序中的，解包后就能获取到。但是怎么说呢，世界上没有攻破不了的防御，只是这个成本问题而已，增加信息被泄漏成本，加密的本质而已。</p><p>废话不多说，开始实现：</p><ol><li>网上找到加密工具类EncryptUtil，这个加密工具类的好处是不用第三方jar包，简单方便，功能全面：</li><li></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用账号密码长度判断是否已经加密，当然也可以加密后向配置文件中加入额外加密标识</span></span><br><span class="line"><span class="keyword">if</span>(clientConfig.getUser().length() &gt; <span class="number">30</span> &amp;&amp; clientConfig.getPassword().length() &gt; <span class="number">30</span>)&#123;</span><br><span class="line">                    <span class="comment">//尝试使用解码后的账号密码进行连接</span></span><br><span class="line">                    user.put(JMXConnector.CREDENTIALS, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;encryptUtil.AESdecode(clientConfig.getUser(), ENCRYPT_AES_KEY), encryptUtil.AESdecode(clientConfig.getPassword(), ENCRYPT_AES_KEY) &#125;);</span><br><span class="line">                    jmxc = JMXConnectorFactory.connect(url,user);</span><br><span class="line">                    mbsc = jmxc.getMBeanServerConnection();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//尝试直接使用配置文件账号密码信息连接</span></span><br><span class="line">                    user.put(JMXConnector.CREDENTIALS, <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; clientConfig.getUser(), clientConfig.getPassword() &#125;);</span><br><span class="line">                    jmxc = JMXConnectorFactory.connect(url,user);</span><br><span class="line">                    mbsc = jmxc.getMBeanServerConnection();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 若是能够连接成功，加密账号密码，输出到配置文件中</span></span><br><span class="line">                        <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> SpringUtil.getBean(<span class="string">&quot;environment&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">profilepath</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;application.file.path&quot;</span>);</span><br><span class="line">                        <span class="type">LinkedProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedProperties</span>();</span><br><span class="line">                        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(profilepath);</span><br><span class="line">                        properties.load(fileReader);</span><br><span class="line">                        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(profilepath);</span><br><span class="line"></span><br><span class="line">                        properties.setProperty(<span class="string">&quot;client.user&quot;</span>, encryptUtil.AESencode(clientConfig.getUser(), ENCRYPT_AES_KEY));</span><br><span class="line">                        properties.setProperty(<span class="string">&quot;client.password&quot;</span>, encryptUtil.AESencode(clientConfig.getPassword(), ENCRYPT_AES_KEY));</span><br><span class="line">                        properties.store(fileWriter, <span class="string">&quot;account and password is encrypted&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        fileReader.close();</span><br><span class="line">                        fileWriter.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">                        var2.printStackTrace();</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>这里我使用了自定义的 LinkedProperties ，如果使用Properties读写配置文件的话会乱序。查看Properties源码，可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Properties其实是一个Hashtable，所以里面的键值对会乱序。要想实现顺序也比较简单，写入我们额外使用一个LinkHashMap来保存键值对，写出时使用LinkHashMap里的数据写出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedProperties</span> <span class="keyword">extends</span> <span class="title class_">Properties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; linkedPropertiesMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">getLinkedPropertiesMap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> linkedPropertiesMap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        linkedPropertiesMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">setProperty</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        linkedPropertiesMap.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(Writer writer, String comments)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : linkedPropertiesMap.entrySet())&#123;&#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EncryptUtil工具类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.impl.dv.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MD5</span> <span class="operator">=</span> <span class="string">&quot;MD5&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SHA1</span> <span class="operator">=</span> <span class="string">&quot;SHA1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HmacMD5</span> <span class="operator">=</span> <span class="string">&quot;HmacMD5&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HmacSHA1</span> <span class="operator">=</span> <span class="string">&quot;HmacSHA1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DES</span> <span class="operator">=</span> <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AES</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**编码格式；默认使用uft-8*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">charset</span> <span class="operator">=</span> <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line">    <span class="comment">/**DES*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">keysizeDES</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**AES*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">keysizeAES</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EncryptUtil me;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EncryptUtil</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//单例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双重锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EncryptUtil <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (me==<span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (EncryptUtil.class) &#123;</span><br><span class="line">               <span class="keyword">if</span>(me == <span class="literal">null</span>)&#123;</span><br><span class="line">                   me = <span class="keyword">new</span> <span class="title class_">EncryptUtil</span>();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> me;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用MessageDigest进行单向加密（无密码）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 被加密的文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm 加密算法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">messageDigest</span><span class="params">(String res,String algorithm)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(algorithm);</span><br><span class="line">            <span class="type">byte</span>[] resBytes = charset==<span class="literal">null</span>?res.getBytes():res.getBytes(charset);</span><br><span class="line">            <span class="keyword">return</span> base64(md.digest(resBytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用KeyGenerator进行单向/双向加密（可设密码）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 被加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm  加密使用的算法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 加密使用的秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">keyGeneratorMac</span><span class="params">(String res,String algorithm,String key)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">sk</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(algorithm);</span><br><span class="line">                sk = kg.generateKey();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] keyBytes = charset==<span class="literal">null</span>?key.getBytes():key.getBytes(charset);</span><br><span class="line">                sk = <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keyBytes, algorithm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(algorithm);</span><br><span class="line">            mac.init(sk);</span><br><span class="line">            <span class="type">byte</span>[] result = mac.doFinal(res.getBytes());</span><br><span class="line">            <span class="keyword">return</span> base64(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用KeyGenerator双向加密，DES/AES，注意这里转化为字符串的时候是将2进制转为16进制格式的字符串，不是直接转，因为会出错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> algorithm 加密使用的算法名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  加密的秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keysize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isEncode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">keyGeneratorES</span><span class="params">(String res,String algorithm,String key,<span class="type">int</span> keysize,<span class="type">boolean</span> isEncode)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyGenerator</span> <span class="variable">kg</span> <span class="operator">=</span> KeyGenerator.getInstance(algorithm);</span><br><span class="line">            <span class="keyword">if</span> (keysize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">byte</span>[] keyBytes = charset==<span class="literal">null</span>?key.getBytes():key.getBytes(charset);</span><br><span class="line">                kg.init(<span class="keyword">new</span> <span class="title class_">SecureRandom</span>(keyBytes));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">                kg.init(keysize);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] keyBytes = charset==<span class="literal">null</span>?key.getBytes():key.getBytes(charset);</span><br><span class="line">                kg.init(keysize, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">sk</span> <span class="operator">=</span> kg.generateKey();</span><br><span class="line">            <span class="type">SecretKeySpec</span> <span class="variable">sks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(sk.getEncoded(), algorithm);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(algorithm);</span><br><span class="line">            <span class="keyword">if</span> (isEncode) &#123;</span><br><span class="line">                cipher.init(Cipher.ENCRYPT_MODE, sks);</span><br><span class="line">                <span class="type">byte</span>[] resBytes = charset==<span class="literal">null</span>?res.getBytes():res.getBytes(charset);</span><br><span class="line">                <span class="keyword">return</span> parseByte2HexStr(cipher.doFinal(resBytes));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cipher.init(Cipher.DECRYPT_MODE, sks);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(parseHexStr2Byte(res)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">base64</span><span class="params">(<span class="type">byte</span>[] res)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**将二进制转换成16进制 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseByte2HexStr</span><span class="params">(<span class="type">byte</span> buf[])</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hex</span> <span class="operator">=</span> Integer.toHexString(buf[i] &amp; <span class="number">0xFF</span>);</span><br><span class="line">            <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                hex = <span class="string">&#x27;0&#x27;</span> + hex;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(hex.toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**将16进制转换为二进制*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] parseHexStr2Byte(String hexStr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hexStr.length() &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[hexStr.length()/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt; hexStr.length()/<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Integer.parseInt(hexStr.substring(i*<span class="number">2</span>, i*<span class="number">2</span>+<span class="number">1</span>), <span class="number">16</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.parseInt(hexStr.substring(i*<span class="number">2</span>+<span class="number">1</span>, i*<span class="number">2</span>+<span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">            result[i] = (<span class="type">byte</span>) (high * <span class="number">16</span> + low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密算法进行加密（不可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">MD5</span><span class="params">(String res)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageDigest(res, MD5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密算法进行加密（不可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res  需要加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">MD5</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorMac(res, HmacMD5, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用SHA1加密算法进行加密（不可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">SHA1</span><span class="params">(String res)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageDigest(res, SHA1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用SHA1加密算法进行加密（不可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">SHA1</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorMac(res, HmacSHA1, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用DES加密算法进行加密（可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的原文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">DESencode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, DES, key, keysizeDES, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对使用DES加密算法的密文进行解密（可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要解密的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">DESdecode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, DES, key, keysizeDES, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用AES加密算法经行加密（可逆）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">AESencode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, AES, key, keysizeAES, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对使用AES加密算法的密文进行解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要解密的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">AESdecode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> keyGeneratorES(res, AES, key, keysizeAES, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用异或进行加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要加密的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">XORencode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = res.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">            bs[i] = (<span class="type">byte</span>) ((bs[i]) ^ key.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parseByte2HexStr(bs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用异或进行解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 需要解密的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">XORdecode</span><span class="params">(String res, String key)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = parseHexStr2Byte(res);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bs.length; i++) &#123;</span><br><span class="line">            bs[i] = (<span class="type">byte</span>) ((bs[i]) ^ key.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接使用异或（第一调用加密，第二次调用解密）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">XOR</span><span class="params">(<span class="type">int</span> res, String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res ^ key.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Base64进行加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Base64Encode</span><span class="params">(String res)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encode(res.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用Base64进行解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Base64Decode</span><span class="params">(String res)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Base64.decode(res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置文件中有用户的账号密码等信息，需要为用户保护信息。&lt;/p&gt;
&lt;p&gt;怎么做呢？暂时没有想到很好的办法，现在设想是用户第一次使用程序时候，配置文件中明文填写账号密码等信息。启用程序连接成功后加密账号密码，输出加密字符串到配置文件中，以后使用密文进行连接。其实这也只是表面功夫</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20boot%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>业务场景：查询数据分页，每条数据需要添加上概览信息，获取概览信息需要调用一些http接口，有一定的等待时间，单线程查询效率较慢。现在需要在查出了数据库持久化数据的基础上，使用多线程给数据添加概览信息，而且在所有异步线程都完成后，再返回分页信息给前端。</p><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p>应用主程序添加注解 @EnableAsync 来开启 Springboot 对于异步任务的支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p>配置类实现接口 AsyncConfigurator，返回一个 ThreadPoolTaskExecutor 线程池对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTaskConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThredPoolTaskExcutor的处理流程</span></span><br><span class="line">    <span class="comment">// 当池子大小小于corePoolSize，就新建线程，并处理请求</span></span><br><span class="line">    <span class="comment">// 当池子大小等于corePoolSize，把请求放入workQueue中，池子里的空闲线程就去workQueue中取任务并处理</span></span><br><span class="line">    <span class="comment">// 当workQueue放不下任务时，就新建线程入池，并处理请求，如果池子大小撑到了maximumPoolSize，就用RejectedExecutionHandler来做拒绝处理</span></span><br><span class="line">    <span class="comment">// 当池子的线程数大于corePoolSize时，多余的线程会等待keepAliveTime长时间，如果无请求可处理就自行销毁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">//设置核心线程数</span></span><br><span class="line">        threadPool.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//设置最大线程数</span></span><br><span class="line">        threadPool.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//线程池所使用的缓冲队列</span></span><br><span class="line">        threadPool.setQueueCapacity(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 等待时间 （默认为0，此时立即停止），并没等待xx秒后强制停止</span></span><br><span class="line">        threadPool.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//  线程名称前缀</span></span><br><span class="line">        threadPool.setThreadNamePrefix(<span class="string">&quot;my-Async-&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化线程</span></span><br><span class="line">        threadPool.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p>异步调用的方法上添加注解@Async，表明该方法是异步方法，如果注解在类上，那表明这个类里面的所有方法都是异步的。异步方法必须是public修饰的，而且需要在另一个类中调用才会生效，否则无法实现异步。  </p><p>Service层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Long&gt; <span class="title function_">addOverViewInfo</span><span class="params">(K8sClusterDTO k8sClusterDTO)</span> <span class="keyword">throws</span> ApiException &#123;</span><br><span class="line">    <span class="comment">// 添加概览信息</span></span><br><span class="line">    <span class="comment">// return CompletableFuture.completedFuture(k8sClusterId);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result = 查询数据库得到的分页数据</span></span><br><span class="line">List&lt;CompletableFuture&lt;Long&gt;&gt; completableFutureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 多线程添加集群概览数据</span></span><br><span class="line"><span class="keyword">for</span> (K8sClusterDTO k8sClusterDTO : result.getObjectList())&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        CompletableFuture&lt;Long&gt; completableFuture = k8sClusterService.addOverViewInfo(k8sClusterDTO);</span><br><span class="line">        completableFutureList.add(completableFuture);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Long&gt;[] completableFutureArray = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[completableFutureList.size()];</span><br><span class="line"><span class="comment">// 合并线程，确保子线程全部执行完</span></span><br><span class="line">CompletableFuture.allOf(completableFutureList.toArray(completableFutureArray)).join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p>至此，功能完成。查询效率确实有所提高。<br>这算是第一次成功在实际项目中使用多线程，网上查询了很多博客，spring boot中使用多线程是很方便的，但是关键是如何等待所有子线程执行完，像这种直接使用注解来声明一个异步方法，很多网上的方案都行不通，最后看到简书上的一篇文章才有了思路。  </p><p>使用了异步编程后，接口调用顺序大概是这样的：  </p><p>查询数据库分页数据<br>返回分页数据给前端<br>第一次调用异步方法<br>第二次调用异步方法<br>……</p><p>所以还没等到数据添加上概览信息，就已经返回了结果，这肯定是行不通的。</p><p>使用了CompletableFuture.allOf(…).jion() 方法后，顺序大概就是：</p><p>查询数据库分页数据<br>第一次调用异步方法<br>第二次调用异步方法<br>……<br>最后一个异步方法执行完毕<br>返回分页数据给前端</p><p>这样才能返回正确的结果</p><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p>CompletableFuture allOf().jion():<br>法实现多实例的同时返回，如果allOf里面的所有线程未执行完毕，主线程会阻塞，直到allOf里面的所有线程都执行，主线程就会被唤醒，继续向下运行。总的来说就是保证了子线程之间的异步，又保证了主线程和子线程的同步。</p><h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p>参考资料：  </p><ol><li>Spring Boot 创建及使用多线程。<a href="https://blog.csdn.net/asd136912/article/details/87716215">https://blog.csdn.net/asd136912/article/details/87716215</a></li><li>SpringBoot 多线程异步调用-提高程序执行效率。<a href="https://www.jianshu.com/p/d919f4372351">https://www.jianshu.com/p/d919f4372351</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务场景：查询数据分页，每条数据需要添加上概览信息，获取概览信息需要调用一些http接口，有一定的等待时间，单线程查询效率较慢。现在需要在查出了数据库持久化数据的基础上，使用多线程给数据添加概览信息，而且在所有异步线程都完成后，再返回分页信息给前端。&lt;/p&gt;
&lt;h4 id=</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E3%80%8AOn%20Java%208%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E3%80%8AOn%20Java%208%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《On-Java-8》读书笔记"><a href="#《On-Java-8》读书笔记" class="headerlink" title="《On Java 8》读书笔记"></a>《On Java 8》读书笔记</h1><h3 id="1-java-8-接口可以有默认方法和静态方法"><a href="#1-java-8-接口可以有默认方法和静态方法" class="headerlink" title="1. java 8 接口可以有默认方法和静态方法"></a>1. java 8 接口可以有默认方法和静态方法</h3><p>增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下，在接口中增加新的方法。默认方法有时也被称为守卫方法或虚拟扩展方法。</p><p>默认方法的最佳实践是 java 8 的 stream api。</p><p>接口使用了默认方法，继承了这个接口的类可以不用实现接口中的默认方法。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnInterface.java</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/AnImplementation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnImplementation</span> <span class="keyword">implements</span> <span class="title class_">AnInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnInterface</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnImplementation</span>();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在 AnInterface 中增加一个新方法 newMethod()，而在 AnImplementation 中没有实现它，编译器就会报错。如果我们使用关键字 default 为 newMethod() 方法提供默认的实现，那么所有与接口有关的代码能正常工作，不受影响，而且这些代码还可以调用新的方法 newMethod()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/InterfaceWithDefault.java</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceWithDefault</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">newMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;newMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要修改接口，不用修改实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces/Implementation2.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Implementation2</span> <span class="keyword">implements</span> <span class="title class_">InterfaceWithDefault</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;firstMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">secondMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;secondMethod&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InterfaceWithDefault</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Implementation2</span>();</span><br><span class="line">        i.firstMethod();</span><br><span class="line">        i.secondMethod();</span><br><span class="line">        i.newMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-java-8-多继承"><a href="#2-java-8-多继承" class="headerlink" title="2. java 8 多继承"></a>2. java 8 多继承</h3><p>类可以实现多个接口，由于默认方法的加入，java class 有了多继承的特性，如果一个类实现的接口中有重复的方法签名相同（方法签名包括方法名和参数类型）的默认方法，类就需要覆写冲突的方法，或者重新实现方法。</p><h3 id="3-数组是保存一组对象最有效的方式"><a href="#3-数组是保存一组对象最有效的方式" class="headerlink" title="3. 数组是保存一组对象最有效的方式"></a>3. 数组是保存一组对象最有效的方式</h3><h3 id="4-关于集合类（Collection-）的写法"><a href="#4-关于集合类（Collection-）的写法" class="headerlink" title="4. 关于集合类（Collection ）的写法"></a>4. 关于集合类（Collection ）的写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Apple&gt; apples = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>请注意， ArrayList 已经被向上转型为了 List接口，这是大多数情况下的写法。但是如果需要用到具体的集合类的功能特性时，就不能将它们向上转型为更通用的接口。</p><h3 id="5-优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）"><a href="#5-优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）" class="headerlink" title="5. 优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）"></a>5. 优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）</h3><h3 id="6-集合类中迭代器（Iterators）的理解"><a href="#6-集合类中迭代器（Iterators）的理解" class="headerlink" title="6 . 集合类中迭代器（Iterators）的理解"></a>6 . 集合类中迭代器（Iterators）的理解</h3><p>迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。ava 的 Iterator 只能单向移动。这个 Iterator 只能用来：</p><ol><li>使用 iterator() 方法要求集合返回一个 Iterator。 Iterator 将准备好返回序列中的第一个元素。</li><li>使用 next() 方法获得序列中的下一个元素。</li><li>使用 hasNext() 方法检查序列中是否还有元素。</li><li>使用 remove() 方法将迭代器最近返回的那个元素删除。</li></ol><p>有了 Iterator ，就不必再为集合中元素的数量操心了。这是由 hasNext() 和 next() 关心的事情。也可以不用考虑到集合的确切类型。迭代器能够将遍历序列的操作与该序列的底层结构分离，统一了对集合的访问方式。</p><p>用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/CrossCollectionIteration.java</span></span><br><span class="line"><span class="keyword">import</span> typeinfo.pets.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrossCollectionIteration</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Iterator&lt;Pet&gt; it)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">      <span class="type">Pet</span> <span class="variable">p</span> <span class="operator">=</span> it.next();</span><br><span class="line">      System.out.print(p.id() + <span class="string">&quot;:&quot;</span> + p + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.list(<span class="number">8</span>);</span><br><span class="line">    LinkedList&lt;Pet&gt; petsLL = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(pets);</span><br><span class="line">    HashSet&lt;Pet&gt; petsHS = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(pets);</span><br><span class="line">    TreeSet&lt;Pet&gt; petsTS = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(pets);</span><br><span class="line">    display(pets.iterator());</span><br><span class="line">    display(petsLL.iterator());</span><br><span class="line">    display(petsHS.iterator());</span><br><span class="line">    display(petsTS.iterator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug</span></span><br><span class="line"><span class="comment">7:Manx</span></span><br><span class="line"><span class="comment">5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug</span></span><br><span class="line"><span class="comment">0:Rat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>ListIterator 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。 Iterator 只能向前移动，而 ListIterator 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一个元素。</p><h3 id="7-Java8-中的堆栈声明为"><a href="#7-Java8-中的堆栈声明为" class="headerlink" title="7. Java8 中的堆栈声明为"></a>7. Java8 中的堆栈声明为</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>之所以是 Deque 而不是Stack，这是因为 Java 1.0 中附带了一个 Stack 类，结果设计得很糟糕（为了向后兼容，后续保留了这个类）。Java 6 添加了 ArrayDeque。</p><h3 id="8-队列"><a href="#8-队列" class="headerlink" title="8. 队列"></a>8. 队列</h3><p>LinkedList 实现了 Queue 接口，并且提供了一些方法以支持队列行为，因此 LinkedList 可以用作 Queue 的一种实现。 通过将 LinkedList 向上转换为 Queue 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="9-for-in-语法糖"><a href="#9-for-in-语法糖" class="headerlink" title="9. for-in 语法糖"></a>9. for-in 语法糖</h3><p>Java 5 引入了一个名为 Iterable 的接口，该接口包含一个能够生成 Iterator 的 iterator() 方法。for-in 使用此 Iterable 接口来遍历序列。因此，如果创建了任何实现了 Iterable 的类，都可以将它用于 for-in 语句中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// collections/IterableClass.java</span></span><br><span class="line"><span class="comment">// Anything Iterable works with for-in</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterableClass</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> String[] words = (<span class="string">&quot;And that is how &quot;</span> +</span><br><span class="line">    <span class="string">&quot;we know the Earth to be banana-shaped.&quot;</span></span><br><span class="line">    ).split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;String&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123; <span class="keyword">return</span> words[index++]; &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; <span class="comment">// Not implemented</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String s : <span class="keyword">new</span> <span class="title class_">IterableClass</span>())</span><br><span class="line">      System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">And that is how we know the Earth to be banana-shaped.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="10-不要在新代码中使用遗留类-Vector-，Hashtable-和-Stack-。"><a href="#10-不要在新代码中使用遗留类-Vector-，Hashtable-和-Stack-。" class="headerlink" title="10. 不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。"></a>10. 不要在新代码中使用遗留类 Vector ，Hashtable 和 Stack 。</h3><h3 id="11-Lambda-表达式"><a href="#11-Lambda-表达式" class="headerlink" title="11. Lambda 表达式"></a>11. Lambda 表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Body</span> <span class="variable">bod</span> <span class="operator">=</span> h -&gt; h + <span class="string">&quot; No Parens!&quot;</span>; <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Body</span> <span class="variable">bod2</span> <span class="operator">=</span> (h) -&gt; h + <span class="string">&quot; More details&quot;</span>; <span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Description</span> <span class="variable">desc</span> <span class="operator">=</span> () -&gt; <span class="string">&quot;Short info&quot;</span>; <span class="comment">// [3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Multi</span> <span class="variable">mult</span> <span class="operator">=</span> (h, n) -&gt; h + n; <span class="comment">// [4]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">Description</span> <span class="variable">moreLines</span> <span class="operator">=</span> () -&gt; &#123; <span class="comment">// [5]</span></span><br><span class="line">    System.out.println(<span class="string">&quot;moreLines()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;from moreLines()&quot;</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>Lambda 表达式基本语法：</p><ul><li><ol><li>参数。</li><li>接着 -&gt;，可视为“产出”。</li><li>-&gt; 之后的内容都是方法体。</li></ol></li><li><p>当只用一个参数，可以不需要括号 ()。 然而，这是一个特例。</p></li><li><p>正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。</p></li><li><p>如果没有参数，则必须使用括号 () 表示空参数列表。</p></li><li><p>对于多个参数，将参数列表放在括号 () 中。</p></li><li><p>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 return 关键字是非法的。 这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。</p></li><li><p>如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就 需要使用 return。Lambda 表达式通常比匿名内部类产生更易读的代码，尽可能使用它们。</p></li></ul><p>Fibonacci 序列改为使用递归 Lambda 表达式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IntCall</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">call</span><span class="params">(<span class="type">int</span> arg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursiveFibonacci</span> &#123;</span><br><span class="line">  IntCall fib;</span><br><span class="line"></span><br><span class="line">  RecursiveFibonacci() &#123;</span><br><span class="line">    fib = n -&gt; n == <span class="number">0</span> ? <span class="number">0</span> :</span><br><span class="line">               n == <span class="number">1</span> ? <span class="number">1</span> :</span><br><span class="line">               fib.call(n - <span class="number">1</span>) + fib.call(n - <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">return</span> fib.call(n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">RecursiveFibonacci</span> <span class="variable">rf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RecursiveFibonacci</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">      System.out.println(rf.fibonacci(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-流操作"><a href="#12-流操作" class="headerlink" title="12. 流操作"></a>12. 流操作</h3><p>流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations），收集流元素（通常是到集合中）。</p><h3 id="13-异常处理"><a href="#13-异常处理" class="headerlink" title="13. 异常处理"></a>13. 异常处理</h3><p>finally 子句永远会执行，即使前面有 return 语句。由于 Java 有垃圾回收机制，所以 finally 语句主要是用来恢复内存之外的资源回到初始状态，需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关。</p><h3 id="14-永恒真理"><a href="#14-永恒真理" class="headerlink" title="14. 永恒真理"></a>14. 永恒真理</h3><p><a href="https://lingcoder.github.io/OnJava8/#/book/16-Validating-Your-Code?id=%E4%BD%A0%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%EF%BC%8C%E4%BD%A0%E5%8F%AA%E8%83%BD%E8%AF%81%E6%98%8E%E5%AE%83%E6%98%AF%E9%94%99%E7%9A%84%E3%80%82">你永远不能保证你的代码是正确的，你只能证明它是错的。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《On-Java-8》读书笔记&quot;&gt;&lt;a href=&quot;#《On-Java-8》读书笔记&quot; class=&quot;headerlink&quot; title=&quot;《On Java 8》读书笔记&quot;&gt;&lt;/a&gt;《On Java 8》读书笔记&lt;/h1&gt;&lt;h3 id=&quot;1-java-8-接口可以</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>关于线程安全（摘自<a href="https://www.cnblogs.com/nizuimeiabc1/p/4254127.html%EF%BC%89">https://www.cnblogs.com/nizuimeiabc1/p/4254127.html）</a></p><p>1）常量始终是线程安全的，因为只存在读操作。 </p><p>2）每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。</p><p>3）局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于线程安全（摘自&lt;a href=&quot;https://www.cnblogs.com/nizuimeiabc1/p/4254127.html%EF%BC%89&quot;&gt;https://www.cnblogs.com/nizuimeiabc1/p/4254127.html）&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20security%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/spring%20security%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/</id>
    <published>2022-12-15T16:14:36.455Z</published>
    <updated>2022-12-15T16:14:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.cnblogs.com/wutianqi/p/9174227.html">spring-security-4介绍</a></p><p>虽然现在已经到了5.x版本了，但是大同小异，知识还是不会过时的。。。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程主要分为个部分：</p><ul><li>spring security Java配置的搭建</li><li>spring security过滤器的创建与注册原理</li><li>spring security Java配置搭建中认证与授权的分析</li><li>spring security Java配置实现自定义的表单认证与授权</li></ul><p>这篇教程主要是用来教会你以下几点：</p><ul><li>怎么搭建spring security</li><li>spring secuirty过滤器的创建与注册原理（工作的基本原理）</li><li>简单的认证与授权的原理</li><li>在明白如何实现简单的认证与授权的基础上实现自定义的认证与授权</li></ul><p>环境说明：</p><ul><li>版本：本教程使用的spring security版本是4.2.3.RELEASE，对应的spring版本是4.3.11.RELEASE。</li><li>工具：开发工具为eclipse，构建工具为maven</li></ul><h2 id="一、什么是spring-security"><a href="#一、什么是spring-security" class="headerlink" title="一、什么是spring security?"></a>一、什么是spring security?</h2><p>spring security是基于spring开发的为JavaEE企业级应用提供安全服务的框架。安全服务主要是指 认证（Authentication）和 授权（Authorization）。</p><h2 id="二、spring-security的模块"><a href="#二、spring-security的模块" class="headerlink" title="二、spring security的模块"></a>二、spring security的模块</h2><p>　搭建spring security首先我们要导入必须的jar，即maven的依赖。spring security按模块划分，一个模块对应一个jar。</p><p>spring security分为以下九个模块：</p><p>　　　　1. Core spring-security-core.jar：核心模块。包含核心的认证（authentication）和授权（authorization）的类和接口，远程支持和基础配置API。</p><p>　　　　2. Remoting spring-security-remoting.jar：提供与spring remoting整合的支持。</p><p>　　　　3. Web spring-security-web.jar：包含过滤器和相关的网络安全的代码。用于我们进行web安全验证和基于URL的访问控制。</p><p>　　　　4. Config spring-security-config.jar：包含security namepace的解析代码。</p><p>　　　　5. LDAP spring-security-ldap.jar：提供LDAP验证和配置的支持。</p><p>　　　　6. ACL spring-security-acl.jar：提供对特定domain对象的ACL（访问控制列表）实现。用来限定对特定对象的访问</p><p>　　　　7. CAS sprig-security-cas.jar：提供与spring security CAS客户端集成</p><p>　　　　8. OpenID spring-security-openid.jar：提供OpenId Web验证支持。基于一个外部OpenId服务器对用户进行验证。</p><p>　　　　9. Test spring-security-test.jar：提供spring security的测试支持。</p><p>　　一般情况下，Core和Config模块都是需要的，因为我们本教程只是用于Java web应用表单的验证登录，所以这里我们还需要引入Web。</p><p>　　说明：本篇教程的代码已上传github，地址：<a href="https://github.com/wutianqi/spring_security_create">https://github.com/wutianqi/spring_security_create</a></p><h2 id="三、工程搭建"><a href="#三、工程搭建" class="headerlink" title="三、工程搭建"></a>三、工程搭建</h2><h4 id="1-项目工程结构"><a href="#1-项目工程结构" class="headerlink" title="1.项目工程结构"></a>1.项目工程结构</h4><p><img src="https://note.youdao.com/yws/api/personal/file/3186B9EC554D41A297D00EF2B4FEA930?method=getImage&version=5756&cstk=szLZezq4" alt="工程结构"></p><h4 id="2-代码展示"><a href="#2-代码展示" class="headerlink" title="2. 代码展示"></a>2. 代码展示</h4><p>2.1 pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;com.wuqi&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring_security_create&lt;/artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;name&gt;spring_security_create Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">      &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">      &lt;!-- web --&gt;</span><br><span class="line">      &lt;jsp.version&gt;2.2&lt;/jsp.version&gt;</span><br><span class="line">      &lt;servlet.version&gt;3.1.0&lt;/servlet.version&gt;</span><br><span class="line">      &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;</span><br><span class="line">      &lt;!-- spring 和 spring security --&gt;</span><br><span class="line">      &lt;spring-security.version&gt;4.2.3.RELEASE&lt;/spring-security.version&gt;</span><br><span class="line">      &lt;spring-framework.version&gt;4.3.11.RELEASE&lt;/spring-framework.version&gt;</span><br><span class="line">      &lt;!-- Logging --&gt;</span><br><span class="line">      &lt;logback.version&gt;1.0.13&lt;/logback.version&gt;</span><br><span class="line">      &lt;slf4j.version&gt;1.7.5&lt;/slf4j.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">       &lt;!-- spring --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;    </span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;   </span><br><span class="line">            &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt; </span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- spring security --&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring-security.version&#125;&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 其他一些依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;    </span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    </span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    </span><br><span class="line">        &lt;version&gt;$&#123;servlet.version&#125;&lt;/version&gt;    </span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;   </span><br><span class="line">    &lt;/dependency&gt;    </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    </span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;    </span><br><span class="line">            &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; </span><br><span class="line">     &lt;/dependency&gt; </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;    </span><br><span class="line">            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;    </span><br><span class="line">            &lt;version&gt;$&#123;jsp.version&#125;&lt;/version&gt; </span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;   </span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;2.5.3&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- 日志 --&gt;</span><br><span class="line">    &lt;!-- 使用SLF4J和LogBack作为日志 --&gt; </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    </span><br><span class="line">         &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    </span><br><span class="line">         &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;    </span><br><span class="line">     &lt;/dependency&gt; </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">         &lt;groupId&gt;log4j&lt;/groupId&gt;    </span><br><span class="line">         &lt;artifactId&gt;log4j&lt;/artifactId&gt;    </span><br><span class="line">         &lt;version&gt;1.2.16&lt;/version&gt;    </span><br><span class="line">     &lt;/dependency&gt; </span><br><span class="line">     &lt;dependency&gt;    </span><br><span class="line">         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    </span><br><span class="line">         &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;    </span><br><span class="line">         &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;    </span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;!--logback日志--&gt;    </span><br><span class="line">      &lt;dependency&gt;    </span><br><span class="line">          &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    </span><br><span class="line">          &lt;artifactId&gt;logback-core&lt;/artifactId&gt;    </span><br><span class="line">          &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;    </span><br><span class="line">      &lt;/dependency&gt;    </span><br><span class="line">      &lt;!--实现slf4j接口并整合--&gt;    </span><br><span class="line">      &lt;dependency&gt;    </span><br><span class="line">          &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    </span><br><span class="line">          &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    </span><br><span class="line">          &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;    </span><br><span class="line">      &lt;/dependency&gt;  </span><br><span class="line">      &lt;dependency&gt;    </span><br><span class="line">          &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    </span><br><span class="line">          &lt;artifactId&gt;logback-access&lt;/artifactId&gt;    </span><br><span class="line">          &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;    </span><br><span class="line">      &lt;/dependency&gt;  </span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;spring_security_create&lt;/finalName&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;!-- 配置maven的内嵌的tomcat，通过内置的tomcat启动 --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">            &lt;uriEncoding&gt;utf8&lt;/uriEncoding&gt;</span><br><span class="line">            &lt;!-- 配置启动的端口为9090 --&gt;</span><br><span class="line">            &lt;port&gt;9090&lt;/port&gt;</span><br><span class="line">            &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">         &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>　该pom文件除了包括了spring security的依赖外，还包括了spring、springmvc、日志的一些依赖，除了spring security的依赖，其他的你没必要太过于纠结。直接拿过来用就可以了。日志我使用了logback，这个你也直接拿过来用就行了，直接将logback.xml放在你的类路径下就可以起作用了。而且这些知识也不是本篇教程所讨论的。<br>　<br>2.2  MyWebConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuqi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.JstlView;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MVC配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuqi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wuqi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置mvc视图解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> InternalResourceViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InternalResourceViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalResourceViewResolver</span>();</span><br><span class="line">        viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/classes/views/&quot;</span>);</span><br><span class="line">        viewResolver.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">        viewResolver.setViewClass(JstlView.class);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyWebConfig是SpringMvc的配置类，这里只配置了视图解析器</p><p>2.3 WebInitializer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuqi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替代web.xml的配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuqi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;MyWebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">//将DispatcherServlet映射到 /</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebInitializer相当于在web.xml中注册DispatcherServlet，以及配置Spring Mvc的配置文件</p><p>2.4 MySecurityConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuqi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spring security配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuqi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configUser</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                <span class="comment">//创建用户名为user，密码为password的用户</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySecurityConfig是spring security的配置类，定制spring security的一些行为就在这里。其中@EnableWebSecurity用于创建过滤器</p><p>2.5 SecurityInitializer </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wuqi.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * security初始化类，用户注册过滤器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wuqi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/06/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityInitializer主要就是用于注册spring secuirty的过滤器</p><p>2.6 logback.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt;  </span><br><span class="line">    &lt;contextListener class=&quot;ch.qos.logback.classic.jul.LevelChangePropagator&quot;&gt;</span><br><span class="line">        &lt;resetJUL&gt;true&lt;/resetJUL&gt;</span><br><span class="line">    &lt;/contextListener&gt;</span><br><span class="line">    &lt;jmxConfigurator /&gt;</span><br><span class="line">  &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  </span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;logbak: %d&#123;HH:mm:ss.SSS&#125; %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt; </span><br><span class="line">  &lt;/appender&gt;  </span><br><span class="line">  </span><br><span class="line">  &lt;logger name=&quot;org.springframework.security.web&quot; level=&quot;DEBUG&quot; /&gt;  </span><br><span class="line">  &lt;logger name=&quot;org.springframework.security&quot; level=&quot;DEBUG&quot; /&gt;  </span><br><span class="line">  &lt;logger name=&quot;org.springframework.security.config&quot; level=&quot;DEBUG&quot; /&gt;  </span><br><span class="line">  </span><br><span class="line">  &lt;root level=&quot;INFO&quot;&gt;  </span><br><span class="line">    &lt;appender-ref ref=&quot;console&quot; /&gt;  </span><br><span class="line">  &lt;/root&gt;  </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>该日志文件就是将web、core、config模块的日志级别调为debug模式。</p><h4 id="3-运行展示"><a href="#3-运行展示" class="headerlink" title="3. 运行展示"></a>3. 运行展示</h4><p>3.1 通过maven内置的Tomcat启动项目（不知道的网上看下，有很多资料），访问端口为9090。地址栏访问  <a href="http://localhost:9090/">http://localhost:9090</a></p><p><img src="https://note.youdao.com/yws/api/personal/file/4C189F378ED642D29B1CFEB7E0710953?method=getImage&version=5821&cstk=szLZezq4" alt="运行展示1"></p><p>由此可以看到当访问我们的项目时，spring security将我们的项目保护了起来，并提供了一个默认的登录页面，让我们去登录。我们在MySecurityConfig中配置了一个用户。用户名为”user”，密码为”password”，输入这个用户名和密码，即可正常访问我们的项目。</p><p>3.2 输入用户名和密码</p><p><img src="https://note.youdao.com/yws/api/personal/file/024CBDB6050549E2AEE13B3AB7C3D507?method=getImage&version=5747&cstk=szLZezq4" alt="运行展示2"></p><h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h4><p>到现在为止，我们已经搭建了一个基于spring(spring mvc)的spring security项目。可能你会很疑惑，为什么会产生这种效果。那个输入用户名和密码的页面，我们在项目中也没有创建，是怎么出来的呢？</p><p>其实这一切都是经过我们上述的配置，我们创建并注册了spring security的过滤器。是这些过滤器为我们做到的。除此之外，spring security还为我们做了额外的其他的保护。总的来说，经过我们上述的配置后，spring security为我们的应用提供了以下默认功能：</p><ol><li>访问应用中的每个URL都需要进行验证</li><li>生成一个登陆表单</li><li>允许用户使用username和password来登陆</li><li>允许用户注销</li><li>CSRF攻击拦截</li><li>Session Fixation（session固定攻击）</li><li>安全Header集成<br> 7.1 HTTP Strict Transport Security for secure requests<br> 7.2 X-Content-Type-Options integration<br> 7.3 缓存控制 (can be overridden later by your application to allow caching of your static resources)<br> 7.4 X-XSS-Protection integration<br> 7.5 X-Frame-Options integration to help prevent Clickjacking  </li><li>Integrate with the following Servlet API methods<br> 8.1 HttpServletRequest#getRemoteUser()<br> 8.2 HttpServletRequest.html#getUserPrincipal()<br> 8.3 HttpServletRequest.html#isUserInRole(java.lang.String)<br> 8.4 HttpServletRequest.html#login(java.lang.String, java.lang.String)<br> 8.5 HttpServletRequest.html#logout()</li></ol><p>下一节，通过spring security过滤器的创建和注册源码的分析，你将会了解这一切！</p><h2 id="四、spring-security过滤器的创建与注册原理"><a href="#四、spring-security过滤器的创建与注册原理" class="headerlink" title="四、spring security过滤器的创建与注册原理"></a>四、spring security过滤器的创建与注册原理</h2><h4 id="1-Spring-Security过滤器的创建原理"><a href="#1-Spring-Security过滤器的创建原理" class="headerlink" title="1. Spring Security过滤器的创建原理"></a>1. Spring Security过滤器的创建原理</h4><p>让我们首先看下MySecurityConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configUser</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                <span class="comment">//创建用户名为user，密码为password的用户</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到MySecurityConfig上的@EnableWebSecurity注解，查看该注解的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123; WebSecurityConfiguration.class,</span></span><br><span class="line"><span class="meta">        SpringWebMvcImportSelector.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Controls debugging support for Spring Security. Default is false.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> if true, enables debug support with Spring Security</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">debug</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableWebSecurity上的@Import注解引入了两个类WebSecurityConfiguration和SpringWebMvcImportSelector，spring security的过滤器正是由WebSecurityConfiguration创建。让我们看下WebSecurityConfiguration的部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">//查看AbstractSecurityWebApplicationInitializer的源码可以看到</span></span><br><span class="line">    <span class="comment">//AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME = &quot;springSecurityFilterChain&quot;</span></span><br><span class="line">    <span class="meta">@Bean(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> Filter <span class="title function_">springSecurityFilterChain</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasConfigurers</span> <span class="operator">=</span> webSecurityConfigurers != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class="line">        <span class="comment">//如果没有配置类那么就new一个WebSecurityConfigurerAdapter,也就是说我们没有配置MySecurityConfig或者说其没有被spring扫描到</span></span><br><span class="line">        <span class="keyword">if</span> (!hasConfigurers) &#123;</span><br><span class="line">            <span class="type">WebSecurityConfigurerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> objectObjectPostProcessor</span><br><span class="line">                    .postProcess(<span class="keyword">new</span> <span class="title class_">WebSecurityConfigurerAdapter</span>() &#123;</span><br><span class="line">                    &#125;);</span><br><span class="line">            webSecurity.apply(adapter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建Filter</span></span><br><span class="line">        <span class="keyword">return</span> webSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从源码中可以看到通过WebSecurity.build()创建出名字为springSecurityFilterChain的Filter对象。（特别说明一下，一定要保证我们的MySecurityConfig类注解了@Configuration并可以被spring扫描到，如果没有被sping扫描到，那么spring security会认为没有配置类，就会新new 出一个WebSecurityConfigureAdapter对象，这会导致我们配置的用户名和密码失效。）那么该Filter的类型是什么呢？别着急，我们先来看下WeSecurity的继承体系。</p><p><img src="https://note.youdao.com/yws/api/personal/file/965F9F015CED49ED9A230290E48E7C48?method=getImage&version=5961&cstk=szLZezq4" alt="WeSecurity的继承体系"></p><p>build方法定义在AbstractSecurityBuilder中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> O <span class="title function_">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.building.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="comment">//通过doBuild方法创建</span></span><br><span class="line">            <span class="built_in">this</span>.object = doBuild();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AlreadyBuiltException</span>(<span class="string">&quot;This object has already been built&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>doBuild方法定义在AbstractConfiguredSecurityBuilder中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> O <span class="title function_">doBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">            buildState = BuildState.INITIALIZING;</span><br><span class="line"></span><br><span class="line">            beforeInit();</span><br><span class="line">            init();</span><br><span class="line"></span><br><span class="line">            buildState = BuildState.CONFIGURING;</span><br><span class="line"></span><br><span class="line">            beforeConfigure();</span><br><span class="line">            configure();</span><br><span class="line"></span><br><span class="line">            buildState = BuildState.BUILDING;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//performBuild方法创建</span></span><br><span class="line">            <span class="type">O</span> <span class="variable">result</span> <span class="operator">=</span> performBuild();</span><br><span class="line"></span><br><span class="line">            buildState = BuildState.BUILT;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>performBuild()方法定义在WebSecurity中，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">protected</span> Filter <span class="title function_">performBuild</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Assert.state(</span><br><span class="line">            !securityFilterChainBuilders.isEmpty(),</span><br><span class="line">            <span class="string">&quot;At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. More advanced users can invoke &quot;</span></span><br><span class="line">                    + WebSecurity.class.getSimpleName()</span><br><span class="line">                    + <span class="string">&quot;.addSecurityFilterChainBuilder directly&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">chainSize</span> <span class="operator">=</span> ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">    List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SecurityFilterChain&gt;(</span><br><span class="line">            chainSize);</span><br><span class="line">    <span class="keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">        securityFilterChains.add(<span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(ignoredRequest));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SecurityBuilder&lt;? <span class="keyword">extends</span> <span class="title class_">SecurityFilterChain</span>&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">        securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建FilterChainProxy</span></span><br><span class="line">    <span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterChainProxy</span>(securityFilterChains);</span><br><span class="line">    <span class="keyword">if</span> (httpFirewall != <span class="literal">null</span>) &#123;</span><br><span class="line">        filterChainProxy.setFirewall(httpFirewall);</span><br><span class="line">    &#125;</span><br><span class="line">    filterChainProxy.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">result</span> <span class="operator">=</span> filterChainProxy;</span><br><span class="line">    <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;\n\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;********************************************************************\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;**********        Security debugging is enabled.       *************\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;**********    This may include sensitive information.  *************\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;**********      Do not use in a production system!     *************\n&quot;</span></span><br><span class="line">                + <span class="string">&quot;********************************************************************\n\n&quot;</span>);</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">DebugFilter</span>(filterChainProxy);</span><br><span class="line">    &#125;</span><br><span class="line">    postBuildAction.run();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>不关心其具体实现，我们从源码中看到spring security创建的过滤器类型为FilterChainProxy。由此完成过滤器的创建。</p><h4 id="2-Spring-Security过滤器的注册原理"><a href="#2-Spring-Security过滤器的注册原理" class="headerlink" title="2. Spring Security过滤器的注册原理"></a>2. Spring Security过滤器的注册原理</h4><p>看下我们创建的SecurityInitializer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractSecurityWebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然很简单，但却是注册过滤器所必须的。</p><p>根据Servlet3.0中，提供了ServletContainerInitializer接口，该接口提供了一个onStartup方法，用于在容器启动时动态注册Servlet,Filter,Listener等。因为我们建立的是web项目，那我们的依赖中肯定是由spring-web依赖的</p><p><img src="https://note.youdao.com/yws/api/personal/file/2B4C6161418B43D982F07F70858FE880?method=getImage&version=5962&cstk=szLZezq4" alt="ServletContainerInitializer"></p><p>根据Servlet 3.0规范，Servlet容器在启动时，会负责创建图中红色箭头所指的类，即SpringServletContainerInitializer，该类是ServletContainerInitializer的实现类。那么该类必有onStartup方法。让我们看下它的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContainerInitializer;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotationAwareOrderComparator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HandlesTypes(WebApplicationInitializer.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title class_">ServletContainerInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (webAppInitializerClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">                <span class="comment">//如果waiClass不为接口，抽象类，并且属于WebApplicationInitializer类型</span></span><br><span class="line">                <span class="comment">//那么通过反射构造该接口的实例。</span></span><br><span class="line">                <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;Failed to instantiate WebApplicationInitializer class&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initializers.isEmpty()) &#123;</span><br><span class="line">            servletContext.log(<span class="string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">        servletContext.log(<span class="string">&quot;Spring WebApplicationInitializers detected on classpath: &quot;</span> + initializers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">            <span class="comment">//调用所有WebApplicationInitializer实例的onStartup方法</span></span><br><span class="line">            initializer.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意该类上的@HandlesTypes(WebApplicationInitializer.class)注解，根据Sevlet3.0规范，Servlet容器要负责以Set集合的方式注入指定类的子类（包括接口，抽象类）。其中AbstractSecurityWebApplicationInitializer是WebApplicationInitializer的抽象子类，我我们看下它的onStartup方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        beforeSpringSecurityFilterChain(servletContext);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.configurationClasses != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">rootAppContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">            rootAppContext.register(<span class="built_in">this</span>.configurationClasses);</span><br><span class="line">            servletContext.addListener(<span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(rootAppContext));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (enableHttpSessionEventPublisher()) &#123;</span><br><span class="line">            servletContext.addListener(</span><br><span class="line">                    <span class="string">&quot;org.springframework.security.web.session.HttpSessionEventPublisher&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        servletContext.setSessionTrackingModes(getSessionTrackingModes());</span><br><span class="line">        <span class="comment">//注册过滤器</span></span><br><span class="line">        insertSpringSecurityFilterChain(servletContext);</span><br><span class="line">        afterSpringSecurityFilterChain(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>该类中的insertSpringSecurityFilterChain(servletContext)就是在注册过滤器。因为在过滤器创建中所说的springSecurityFilterChain，它其实是spring中的bean，而servletContext也必定可以获取到该bean。我们接着看insertSpringSecurityFilterChain的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_FILTER_NAME</span> <span class="operator">=</span> <span class="string">&quot;springSecurityFilterChain&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSpringSecurityFilterChain</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> DEFAULT_FILTER_NAME;</span><br><span class="line">    <span class="comment">//通过DelegatingFilterProxy代理</span></span><br><span class="line">    <span class="type">DelegatingFilterProxy</span> <span class="variable">springSecurityFilterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingFilterProxy</span>(</span><br><span class="line">            filterName);</span><br><span class="line">    <span class="type">String</span> <span class="variable">contextAttribute</span> <span class="operator">=</span> getWebApplicationContextAttribute();</span><br><span class="line">    <span class="keyword">if</span> (contextAttribute != <span class="literal">null</span>) &#123;</span><br><span class="line">        springSecurityFilterChain.setContextAttribute(contextAttribute);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成过滤器的注册</span></span><br><span class="line">    registerFilter(servletContext, <span class="literal">true</span>, filterName, springSecurityFilterChain);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一开始我们就提到了调用过滤器链springSecurityFilterChain需要DelegatingFilterProxy进行代理，将其与web.xml联系起来。这段代码就是很好的证明。DelegatingFilterProxy中维护了一个类型为String，名字叫做targetBeanName的字段，targetBeanName就是DelegatingFilterProxy所代理的类的名称。最后通过registerFilter最终完成过滤器的注册。</p><h2 id="五、spring-security-认证和授权原理"><a href="#五、spring-security-认证和授权原理" class="headerlink" title="五、spring security 认证和授权原理"></a>五、spring security 认证和授权原理</h2><p>在上一节我们讨论了spring security过滤器的创建和注册原理。请记住springSecurityFilterChain（类型为FilterChainProxy）是实际起作用的过滤器链，DelegatingFilterProxy起到代理作用。</p><p>但是这还没有解决我们最初的所有问题，那就是虽然创建了springSecurityFilterChain过滤器链，那么过滤器链中的过滤器是如何一一创建的？这些过滤器是如何实现认证和授权的？本节我们来讨论这个问题。</p><p>注意：本节代码示例，采用的依然第二节中基于Java配置的搭建中的代码为例。</p><h4 id="1-过滤器的创建"><a href="#1-过滤器的创建" class="headerlink" title="1. 过滤器的创建"></a>1. 过滤器的创建</h4><p>我们创建的MySecurityConfig继承了WebSecurityConfigurerAdapter。WebSecurityConfigurerAdapter中有个configure(HttpSecurity http)的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests() <span class="comment">//拦截请求，创建FilterSecurityInterceptor</span></span><br><span class="line">                .anyRequest().authenticated() <span class="comment">//在创建过滤器的基础上的一些自定义配置</span></span><br><span class="line">                .and() <span class="comment">//用and来表示配置过滤器结束，以便进行下一个过滤器的创建和配置</span></span><br><span class="line">            .formLogin().and() <span class="comment">//设置表单登录，创建UsernamePasswordAuthenticationFilter</span></span><br><span class="line">            .httpBasic(); <span class="comment">//basic验证，创建BasicAuthenticationFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用来实现spring security的一些自定义的配置，其中就包括Filter的创建。其中http.authorizeRequests()、http.formLogin()、http.httpBasic()分别创建了ExpressionUrlAuthorizationConfigurer，FormLoginConfigurer，HttpBasicConfigurer。在三个类从父级一直往上找，会发现它们都是SecurityConfigurer的子类。SecurityConfigurer中又有configure方法。该方法被子类实现就用于创建各个过滤器，并将过滤器添加进HttpSecurity中维护的装有Filter的List中，比如HttpBasicConfigurer中的configure方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(B http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">AuthenticationManager</span> <span class="variable">authenticationManager</span> <span class="operator">=</span> http</span><br><span class="line">                .getSharedObject(AuthenticationManager.class);</span><br><span class="line">        <span class="comment">//创建BasicAuthenticationFilter过滤器</span></span><br><span class="line">        <span class="type">BasicAuthenticationFilter</span> <span class="variable">basicAuthenticationFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicAuthenticationFilter</span>(</span><br><span class="line">                authenticationManager, <span class="built_in">this</span>.authenticationEntryPoint);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.authenticationDetailsSource != <span class="literal">null</span>) &#123;</span><br><span class="line">            basicAuthenticationFilter</span><br><span class="line">                    .setAuthenticationDetailsSource(<span class="built_in">this</span>.authenticationDetailsSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RememberMeServices</span> <span class="variable">rememberMeServices</span> <span class="operator">=</span> http.getSharedObject(RememberMeServices.class);</span><br><span class="line">        <span class="keyword">if</span>(rememberMeServices != <span class="literal">null</span>) &#123;</span><br><span class="line">            basicAuthenticationFilter.setRememberMeServices(rememberMeServices);</span><br><span class="line">        &#125;</span><br><span class="line">        basicAuthenticationFilter = postProcess(basicAuthenticationFilter);</span><br><span class="line">        <span class="comment">//添加过滤器</span></span><br><span class="line">        http.addFilter(basicAuthenticationFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，并非所有的过滤器都是在configure中进行创建的，比如UsernamePasswordAuthenticationFilter是在调用FormLoginConfigurer的构造方法时创建的。FormLoginConfigurer部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FormLoginConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span>(), <span class="literal">null</span>);</span><br><span class="line">        usernameParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        passwordParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpSecurity的父类是AbstractConfiguredSecurityBuilder，该类中有个configure方法用来获取所有SecurityConfigurer，并调用所有SecurityConfigurer的configure方法。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取所有SecurityConfigurer类</span></span><br><span class="line">        Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">            <span class="comment">//调用所有SecurityConfigurer的configure方法</span></span><br><span class="line">            configurer.configure((B) <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是过滤器的创建过程。当我们的MySecurityConfig继承了WebSecurityConfigurerAdapter以后，就默认有了configure(HttpSecurity http)方法。我们也可以在MySecurityConfig中重写此方法来进行更灵活的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">        .authorizeRequests() <span class="comment">//注册FilterSecurityInterceptor</span></span><br><span class="line">             .antMatchers(<span class="string">&quot;/index.html&quot;</span>).permitAll()<span class="comment">//访问index.html不要权限验证</span></span><br><span class="line">             .anyRequest().authenticated()<span class="comment">//其他所有路径都需要权限校验</span></span><br><span class="line">        .and()</span><br><span class="line">             .csrf().disable()<span class="comment">//默认开启，可以显示关闭</span></span><br><span class="line">        .formLogin()  <span class="comment">//内部注册 UsernamePasswordAuthenticationFilter</span></span><br><span class="line">            .loginPage(<span class="string">&quot;/login.html&quot;</span>) <span class="comment">//表单登录页面地址</span></span><br><span class="line">            .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)<span class="comment">//form表单POST请求url提交地址，默认为/login</span></span><br><span class="line">            .passwordParameter(<span class="string">&quot;password&quot;</span>)<span class="comment">//form表单用户名参数名</span></span><br><span class="line">            .usernameParameter(<span class="string">&quot;username&quot;</span>) <span class="comment">//form表单密码参数名</span></span><br><span class="line">            .successForwardUrl(<span class="string">&quot;/success.html&quot;</span>)  <span class="comment">//登录成功跳转地址</span></span><br><span class="line">            .failureForwardUrl(<span class="string">&quot;/error.html&quot;</span>) <span class="comment">//登录失败跳转地址</span></span><br><span class="line">            <span class="comment">//.defaultSuccessUrl()//如果用户没有访问受保护的页面，默认跳转到页面</span></span><br><span class="line">            <span class="comment">//.failureUrl()</span></span><br><span class="line">            <span class="comment">//.failureHandler(AuthenticationFailureHandler)</span></span><br><span class="line">            <span class="comment">//.successHandler(AuthenticationSuccessHandler)</span></span><br><span class="line">            <span class="comment">//.failureUrl(&quot;/login?error&quot;)</span></span><br><span class="line">            .permitAll();<span class="comment">//允许所有用户都有权限访问loginPage，loginProcessingUrl，failureForwardUrl</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然我们上面仅仅看到了三种过滤器的创建，但是真正创建的远不止三种，spring secuirty会默认帮我们注册一些过滤器。比如SecurityContextPersistenceFilter，该过滤器用于在我们请求到来时，将SecurityContext从Session中取出放入SecuirtyContextHolder中供我们使用。并在请求结束时将SecuirtyContext存进Session中便于下次使用。还有DefaultLoginPageGeneratingFilter，该过滤器在我们没有自定义配置loginPage时会自动生成，用于生成我们默认的登录页面，也就是我们一开始在搭建中看到的登录页面。对于自定义配置spring security详细参考javaDoc。spring secuirty核心过滤器以及其顺序如下（并未包括所有）：</p><p><img src="https://note.youdao.com/yws/api/personal/file/D8B7253A683B4EBD90D352719615FEF1?method=getImage&version=5960&cstk=szLZezq4" alt="spring secuirty核心过滤器以及其顺序"></p><h4 id="2-认证与授权"><a href="#2-认证与授权" class="headerlink" title="2. 认证与授权"></a>2. 认证与授权</h4><p>　认证(Authentication)：确定一个用户的身份的过程。授权(Authorization)：判断一个用户是否有访问某个安全对象的权限。下面讨论一下spring security中最基本的认证与授权。</p><p>首先明确一下在认证与授权中关键的三个过滤器，其他过滤器不讨论：</p><pre><code>1. UsernamePasswordAuthenticationFilter：该过滤器用于拦截我们表单提交的请求（默认为/login），进行用户的认证过程吧。2. ExceptionTranslationFilter：该过滤器主要用来捕获处理spring security抛出的异常，异常主要来源于FilterSecurityInterceptor。3. FilterSecurityInterceptor：该过滤器主要用来进行授权判断。</code></pre><p>下面根据我们访问应用的顺序并结合源码分析一下spring security的认证与授权。代码仍然是前面基于Java配置的搭建中的</p><ol><li>我们在浏览器中输入<a href="http://localhost:9090/">http://localhost:9090/</a> 访问应用，因为我们的路径被spring secuirty保护起来了，我们是没有权限访问的，所以我们会被引导至登录页面进行登录。</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/4C189F378ED642D29B1CFEB7E0710953?method=getImage&version=5821&cstk=szLZezq4" alt="登陆界面"></p><p>此路径因为不是表单提交的路径(&#x2F;login)，该过程主要起作用的过滤器为FilterSecurityInterceptor。其部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">FilterInvocation</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FilterInvocation</span>(request, response, chain);</span><br><span class="line">        invoke(fi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//过滤器对每个请求只处理一次</span></span><br><span class="line">        <span class="keyword">if</span> ((fi.getRequest() != <span class="literal">null</span>)</span><br><span class="line">                &amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="literal">null</span>)</span><br><span class="line">                &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">            <span class="comment">// filter already applied to this request and user wants us to observe</span></span><br><span class="line">            <span class="comment">// once-per-request handling, so don&#x27;t re-do security checking</span></span><br><span class="line">            fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">            <span class="keyword">if</span> (fi.getRequest() != <span class="literal">null</span>) &#123;</span><br><span class="line">                fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//前处理</span></span><br><span class="line">            <span class="type">InterceptorStatusToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="built_in">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//使SecurityContextHolder中的Authentication保持原样，因为RunAsManager会暂时改变</span></span><br><span class="line">                <span class="comment">//其中的Authentication</span></span><br><span class="line">                <span class="built_in">super</span>.finallyInvocation(token);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用后的处理</span></span><br><span class="line">            <span class="built_in">super</span>.afterInvocation(token, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>真正进行权限判断的为beforeInvocation，该方法定义在FilterSecurityInterceptor的父类AbstractSecurityInterceptor中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">protected</span> InterceptorStatusToken <span class="title function_">beforeInvocation</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        Assert.notNull(object, <span class="string">&quot;Object was null&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断object是否为过滤器支持的类型，在这里是FilterInvocation(里面记录包含了请求的request,response,FilterChain)</span></span><br><span class="line">        <span class="comment">//这里可以把FilterInvocation看做是安全对象，因为通过它可以获得request,通过request可以获得请求的URI。</span></span><br><span class="line">        <span class="comment">//而实际的安全对象就是URI</span></span><br><span class="line">        <span class="keyword">if</span> (!getSecureObjectClass().isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;Security invocation attempted for object &quot;</span></span><br><span class="line">                            + object.getClass().getName()</span><br><span class="line">                            + <span class="string">&quot; but AbstractSecurityInterceptor only configured to support secure objects of type: &quot;</span></span><br><span class="line">                            + getSecureObjectClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取安全对象所对应的ConfigAttribute，ConfigAtrribute实际就是访问安全所应该有的权限集。</span></span><br><span class="line">        Collection&lt;ConfigAttribute&gt; attributes = <span class="built_in">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">                .getAttributes(object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断安全对象是否拥有权限集，没有的话说明所访问的安全对象是一个公共对象，就是任何人都可以访问的。</span></span><br><span class="line">        <span class="keyword">if</span> (attributes == <span class="literal">null</span> || attributes.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//如果rejectPublicInvocations为true,说明不支持公共对象的访问，此时会抛出异常。</span></span><br><span class="line">            <span class="keyword">if</span> (rejectPublicInvocations) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;Secure object invocation &quot;</span></span><br><span class="line">                                + object</span><br><span class="line">                                + <span class="string">&quot; was denied as public invocations are not allowed via this interceptor. &quot;</span></span><br><span class="line">                                + <span class="string">&quot;This indicates a configuration error because the &quot;</span></span><br><span class="line">                                + <span class="string">&quot;rejectPublicInvocations property is set to &#x27;true&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Public object - authentication not attempted&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">PublicInvocationEvent</span>(object));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// no further work post-invocation</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Secure object: &quot;</span> + object + <span class="string">&quot;; Attributes: &quot;</span> + attributes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断SecurityCntext中是否存在Authentication,不存在则说明访问着根本没登录</span></span><br><span class="line">        <span class="comment">//调用下面的credentialsNotFound()方法则会抛出一个AuthenticationException，</span></span><br><span class="line">        <span class="comment">//该异常会被ExceptionTranslationFilter捕获，并做出处理。</span></span><br><span class="line">        <span class="comment">//不过默认情况下Authentication不会为null,因为AnonymouseFilter会默认注册到</span></span><br><span class="line">        <span class="comment">//过滤链中，如果用户没登录的话，会将其当做匿名用户(Anonymouse User)来对待。</span></span><br><span class="line">        <span class="comment">//除非你自己将AnonymouseFilter从过滤链中去掉。</span></span><br><span class="line">        <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="literal">null</span>) &#123;</span><br><span class="line">            credentialsNotFound(messages.getMessage(</span><br><span class="line">                    <span class="string">&quot;AbstractSecurityInterceptor.authenticationNotFound&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;An Authentication object was not found in the SecurityContext&quot;</span>),</span><br><span class="line">                    object, attributes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Autentication存在，则说明用户已经被认证（但是不表示已登录，因为匿名用户也是相当于被认证的），</span></span><br><span class="line">        <span class="comment">//判断用户是否需要再次被认证，如果你配置了每次访问必须重新验证，那么就会再次调用AuthenticationManager</span></span><br><span class="line">        <span class="comment">//的authenticate方法进行验证。</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticated</span> <span class="operator">=</span> authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt authorization</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断用户是否有访问被保护对象的权限。</span></span><br><span class="line">            <span class="comment">//ed。默认的AccessDesicisonManager的实现类是AffirmativeBased</span></span><br><span class="line">            <span class="comment">//AffirmativeBased采取投票的形式判断用户是否有访问安全对象的权限</span></span><br><span class="line">            <span class="comment">//票就是配置的Role。AffirmativeBased采用WebExpressionVoter进行投票</span></span><br><span class="line">            <span class="built_in">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizationFailureEvent</span>(object, attributes, authenticated,</span><br><span class="line">                    accessDeniedException));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Authorization successful&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (publishAuthorizationSuccess) &#123;</span><br><span class="line">            publishEvent(<span class="keyword">new</span> <span class="title class_">AuthorizedEvent</span>(object, attributes, authenticated));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to run as a different user</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">runAs</span> <span class="operator">=</span> <span class="built_in">this</span>.runAsManager.buildRunAs(authenticated, object,</span><br><span class="line">                attributes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runAs == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;RunAsManager did not change Authentication object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// no further work post-invocation</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(SecurityContextHolder.getContext(), <span class="literal">false</span>,</span><br><span class="line">                    attributes, object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Switching to RunAs Authentication: &quot;</span> + runAs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">SecurityContext</span> <span class="variable">origCtx</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line">            SecurityContextHolder.setContext(SecurityContextHolder.createEmptyContext());</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(runAs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// need to revert to token.Authenticated post-invocation</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptorStatusToken</span>(origCtx, <span class="literal">true</span>, attributes, object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看这段代码，请明确几点:</p><ul><li><p>beforeInvocation(Object object)中的object为安全对象，类型为FilterInvocation。安全对象就是受spring security保护的对象。虽然按道理来说安全对象应该是我们访问的url，但是FilterInvocation中封装了request，那么url也可以获取到。</p></li><li><p>Collection<ConfigAttribute> attributes &#x3D; this.obtainSecurityMetadataSource().getAttributes(object) 每个安全对象都会有对应的访问权限集(Collection<ConfigAttribute>)，而且在容器启动后所有安全对象的所有权限集就已经被获取到并被放在安全元数据中（SecurityMetadataSource中），通过安全元数据可以获取到各个安全对象的权限集。因为我们每个安全对象都是登录才可以访问的（anyRequest().authenticated()），这里我们只需要知道此时每个对象的权限集只有一个元素，并且是authenticated。如果一个对象没有权限集，说明它是一个公共对象，不受spring security保护。</p></li><li><p>当我们没有登录时，我们会被当做匿名用户（Anonymouse）来看待。被当做匿名用户对待是AnonymouseAuthenticationFilter来拦截封装成一个Authentication对象，当用户被认证后就会被封装成一个Authentication对象。Authentication对象中封装了用户基本信息，该对象会在认证中做详细介绍。AnonymouseAuthenticationFilter也是默认被注册的。</p></li><li><p>最中进行授权判断的是AccessDecisionManager的子类AffirmativeBased的decide方法。我在来看其decide的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object object,</span></span><br><span class="line"><span class="params">            Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="keyword">throws</span> AccessDeniedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">deny</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (AccessDecisionVoter voter : getDecisionVoters()) &#123;</span><br><span class="line">            <span class="comment">//根据用户的authenticton和权限集得出能否访问的结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> voter.vote(authentication, object, configAttributes);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Voter: &quot;</span> + voter + <span class="string">&quot;, returned: &quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> AccessDecisionVoter.ACCESS_GRANTED:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> AccessDecisionVoter.ACCESS_DENIED:</span><br><span class="line">                deny++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deny &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果deny&gt;0说明没有足够的权限去访问安全对象，此时抛出的</span></span><br><span class="line">            <span class="comment">//AccessDeniedException会被ExceptionTranslationFilter捕获处理。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(messages.getMessage(</span><br><span class="line">                    <span class="string">&quot;AbstractAccessDecisionManager.accessDenied&quot;</span>, <span class="string">&quot;Access is denied&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To get this far, every AccessDecisionVoter abstained</span></span><br><span class="line">        checkAllowIfAllAbstainDecisions();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为我们首次登录，所以会抛出AccessDeniedexception。此异常会被ExceptionTranslationFilter捕获并进行处理的。其部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">&quot;Chain processed normally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// Try to extract a SpringSecurityException from the stacktrace</span></span><br><span class="line">            Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">ase</span> <span class="operator">=</span> (AuthenticationException) throwableAnalyzer</span><br><span class="line">                    .getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ase == <span class="literal">null</span>) &#123;</span><br><span class="line">                ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(</span><br><span class="line">                        AccessDeniedException.class, causeChain);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ase != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//真正处理异常的地方</span></span><br><span class="line">                handleSpringSecurityException(request, response, chain, ase);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Rethrow ServletExceptions and RuntimeExceptions as-is</span></span><br><span class="line">                <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ServletException) ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Wrap other Exceptions. This shouldn&#x27;t actually happen</span></span><br><span class="line">                <span class="comment">// as we&#x27;ve already covered all the possibilities for doFilter</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleSpringSecurityException</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response, FilterChain chain, RuntimeException exception)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">&quot;Authentication exception occurred; redirecting to authentication entry point&quot;</span>,</span><br><span class="line">                    exception);</span><br><span class="line">            <span class="comment">//未被认证，引导去登录</span></span><br><span class="line">            sendStartAuthentication(request, response, chain,</span><br><span class="line">                    (AuthenticationException) exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">            <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">            <span class="keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) &#123;</span><br><span class="line">                logger.debug(</span><br><span class="line">                        <span class="string">&quot;Access is denied (user is &quot;</span> + (authenticationTrustResolver.isAnonymous(authentication) ? <span class="string">&quot;anonymous&quot;</span> : <span class="string">&quot;not fully authenticated&quot;</span>) + <span class="string">&quot;); redirecting to authentication entry point&quot;</span>,</span><br><span class="line">                        exception);</span><br><span class="line">                <span class="comment">//如果为匿名用户说明未登录，引导去登录</span></span><br><span class="line">                sendStartAuthentication(</span><br><span class="line">                        request,</span><br><span class="line">                        response,</span><br><span class="line">                        chain,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">InsufficientAuthenticationException</span>(</span><br><span class="line">                                <span class="string">&quot;Full authentication is required to access this resource&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(</span><br><span class="line">                        <span class="string">&quot;Access is denied (user is not anonymous); delegating to AccessDeniedHandler&quot;</span>,</span><br><span class="line">                        exception);</span><br><span class="line">                <span class="comment">//用户已登录，但是没有足够权限去访问安全对象，说明权限不足。进行</span></span><br><span class="line">                <span class="comment">//权限不足的提醒</span></span><br><span class="line">                accessDeniedHandler.handle(request, response,</span><br><span class="line">                        (AccessDeniedException) exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为我们是以匿名用户的身份进行登录的，所以，会被引导去登录页面。登录页面的创建是由默认注册的过滤器DefaultLoginPageGeneratingFilter产生的。具体怎么产生的这里不做分析。我们只需要是谁做的就可以了。实际在使用时我们也不大可能去用默认生成的登录页面，因为太丑了。。。</p></li></ul><br><p>2、在被引导至登录页面后，我们将输入用户名和密码，提交至应用。应用会校验用户名和密码，校验成功后，我们成功访问应用。</p><p><img src="https://note.youdao.com/yws/api/personal/file/024CBDB6050549E2AEE13B3AB7C3D507?method=getImage&version=5747&cstk=szLZezq4" alt="登陆成功"></p><p>此时访问的路径为&#x2F;login，这是UsernamePasswordAuthenticationFilter将拦截请求进行认证。UsernamePasswordAuthenticationFilter的doFilter方法定义在其父类AbstractAuthenticationProcessingFilter中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断请求是否需要进行验证处理。默认对/login并且是POST请求的路径进行拦截</span></span><br><span class="line">        <span class="keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Request is to process authentication&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Authentication authResult;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用UsernamePasswordAuthenticationFilter的attemptAuthentication方法进行验证，并返回</span></span><br><span class="line">            <span class="comment">//完整的被填充的Authentication对象</span></span><br><span class="line">            authResult = attemptAuthentication(request, response);</span><br><span class="line">            <span class="keyword">if</span> (authResult == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// return immediately as subclass has indicated that it hasn&#x27;t completed</span></span><br><span class="line">                <span class="comment">// authentication</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行session固定攻击的处理</span></span><br><span class="line">            sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">            logger.error(</span><br><span class="line">                    <span class="string">&quot;An internal error occurred while trying to authenticate the user.&quot;</span>,</span><br><span class="line">                    failed);</span><br><span class="line">            unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">            <span class="comment">// 认证失败后的处理</span></span><br><span class="line">            unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Authentication success</span></span><br><span class="line">        <span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证成功后的处理</span></span><br><span class="line">        successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际认证发生在UsernamePasswordAuthenticationFilter的attemptAuthentication中，如果认证失败，则会调用unsuccessfulAuthentication进行失败后的处理，一般是提示用户认证失败，要求重新输入用户名和密码，如果认证成功，那么会调用successfulAuthentication进行成功后的处理，一般是将Authentication存进SecurityContext中并跳转至之前访问的页面或者默认页面（这部分在读者读完本节后自行去看源码是怎么处理的，这里不做讨论，现在只需知道会跳到一开始我们访问的页面中）。下面我们来看认证即attemptAuthentication的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">            HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(</span><br><span class="line">                    <span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> obtainUsername(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> obtainPassword(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">            username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">            password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        username = username.trim();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将用户名和密码封装在Authentication的实现UsernamePasswordAuthenticationToken</span></span><br><span class="line">        <span class="comment">//以便于AuthentictionManager进行认证</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(</span><br><span class="line">                username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">        setDetails(request, authRequest);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得AuthenticationManager进行认证</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>spring security在进行认证时，会将用户名和密码封装成一个Authentication对象，在进行认证后，会将Authentication的权限等信息填充完全返回。Authentication会被存在SecurityContext中，供应用之后的授权等操作使用。此处介绍下Authentication，Authentication存储的就是访问应用的用户的一些信息。下面是Authentication源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">    <span class="comment">//用户的权限集合</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户登录的凭证，一般指的就是密码</span></span><br><span class="line">    Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户的一些额外的详细信息，一般不用</span></span><br><span class="line">    Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里认为Principal就为登录的用户</span></span><br><span class="line">    Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否已经被认证了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置认证的状态</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲解了Authentication后，我们回过头来再看attemptAuthentication方法，该方法会调用AuthenticationManager的authenticate方法进行认证并返回一个填充完整的Authentication对象。</p><p>在这里我们又要讲解一下认证的几个核心的类，很重要！</p><p>a). AuthenticationManager　　b).ProviderManager　　c).AuthenticationProvider　　d).UserDetailsService　　e).UserDetails</p><p>现在来说一下这几个类的作用以及关联关系。</p><p>a). AuthenticationManager是一个接口，提供了authenticate方法用于认证。</p><p>b). AuthenticationManager有一个默认的实现ProviderManager，其实现了authenticate方法。</p><p>c). ProviderManager内部维护了一个存有AuthenticationProvider的集合，ProviderManager实现的authenticate方法再调用这些AuthenticationProvider的authenticate方法去认证，表单提交默认用的AuthenticationProvider实现是DaoAuthenticationProvider。</p><p>d). AuthenticationProvider中维护了UserDetailsService，我们使用内存中的用户，默认的实现是InMemoryUserDetailsManager。UserDetailsService用来查询用户的详细信息，该详细信息就是UserDetails。UserDetails的默认实现是User。查询出来UserDetails后再对用户输入的密码进行校验。校验成功则将UserDetails中的信息填充进Authentication中返回。校验失败则提醒用户密码错误。</p><p>以上说的这些接口的实现类是由我们在MySecurityConfig中配置时生成的，即下面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configUser</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        builder</span><br><span class="line">            .inMemoryAuthentication()</span><br><span class="line">                <span class="comment">//创建用户名为user，密码为password的用户</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="string">&quot;password&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里不再讨论具体是怎么生成的，记住即可。因为我们实际在项目中一般都会用自定义的这些核心认证类。</p><p>下面我们来分析源码，先来看ProviderManager的authenticate方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">        <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有AuthenticationProvider，循环进行认证</span></span><br><span class="line">        <span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span></span><br><span class="line">                        + provider.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//对authentication进行认证</span></span><br><span class="line">                result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//填充成完整的Authentication</span></span><br><span class="line">                    copyDetails(authentication, result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AccountStatusException e) &#123;</span><br><span class="line">                prepareException(e, authentication);</span><br><span class="line">                <span class="comment">// SEC-546: Avoid polling additional providers if auth failure is due to</span></span><br><span class="line">                <span class="comment">// invalid account status</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InternalAuthenticationServiceException e) &#123;</span><br><span class="line">                prepareException(e, authentication);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">                lastException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Allow the parent to try.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = parent.authenticate(authentication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ProviderNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ignore as we will throw below if no other exception occurred prior to</span></span><br><span class="line">                <span class="comment">// calling parent and the parent</span></span><br><span class="line">                <span class="comment">// may throw ProviderNotFound even though a provider in the child already</span></span><br><span class="line">                <span class="comment">// handled the request</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">                lastException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">                    &amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">                <span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line">                <span class="comment">// from authentication</span></span><br><span class="line">                ((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parent was null, or didn&#x27;t authenticate (or throw an exception).</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果所有的AuthenticationProvider进行认证完result仍然为null</span></span><br><span class="line">            <span class="comment">//此时表示为提供AuthenticationProvider，抛出ProviderNotFoundException异常</span></span><br><span class="line">            lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(messages.getMessage(</span><br><span class="line">                    <span class="string">&quot;ProviderManager.providerNotFound&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; toTest.getName() &#125;,</span><br><span class="line">                    <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prepareException(lastException, authentication);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>ProviderManager用AuthenticationProvider对authentication进行认证。如果没有提供AuthenticationProvider，那么最终将抛出ProviderNotFoundException。</p><p>我们表单提交认证时，AuthenticationProvider默认的实现是DaoAuthenticationProvider，DaoAuthenticationProvider的authenticate方法定义在其父类AbstractUserDetailsAuthenticationProvider中，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,</span><br><span class="line">                messages.getMessage(</span><br><span class="line">                        <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine username</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (authentication.getPrincipal() == <span class="literal">null</span>) ? <span class="string">&quot;NONE_PROVIDED&quot;</span></span><br><span class="line">                : authentication.getName();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取UserDetails，即用户详细信息</span></span><br><span class="line">                user = retrieveUser(username,</span><br><span class="line">                        (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(messages.getMessage(</span><br><span class="line">                            <span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> notFound;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Assert.notNull(user,</span><br><span class="line">                    <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            preAuthenticationChecks.check(user);</span><br><span class="line">            <span class="comment">//进行密码校验</span></span><br><span class="line">            additionalAuthenticationChecks(user,</span><br><span class="line">                    (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">                <span class="comment">// There was a problem, so try again after checking</span></span><br><span class="line">                <span class="comment">// we&#x27;re using latest data (i.e. not from the cache)</span></span><br><span class="line">                cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">                user = retrieveUser(username,</span><br><span class="line">                        (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">                preAuthenticationChecks.check(user);</span><br><span class="line">                additionalAuthenticationChecks(user,</span><br><span class="line">                        (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//认证失败抛出认证异常</span></span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">            <span class="built_in">this</span>.userCache.putUserInCache(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">            principalToReturn = user.getUsername();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证成功，返回装有用户权限等信息的authentication对象</span></span><br><span class="line">        <span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>retrieveUser方法定义在DaoAuthenticationProvider中，用来获取UserDetails这里不再展示源码，请读者自行去看。你会发现获取获取UserDetails正是由其中维护的UserDetailsService来完成的。获取到UserDetails后再调用其</p><p>additionalAuthenticationChecks方法进行密码的验证。如果认证失败，则抛出AuthenticationException，如果认证成功则返回装有权限等信息的Authentication对象。</p><br><p>3、小节<br>到目前为止，我们结合我们创建的项目和spring security的源码分析了web应用认证和授权的原理。内容比较多，现在理一下重点。</p><ol><li><p>springSecurityFilterChain中各个过滤器怎么创建的只需了解即可。不要太过关注。</p></li><li><p>重点记忆UsernamePasswordAuthenticationFilter，ExceptionTranslationFilter，FilterSecurityInterceptor这三个过滤器的作用及源码分析。</p></li><li><p>重要记忆认证中Authentication，AuthenticationManager，ProviderManager，AuthenticationProvider，UserDetailsService，UserDetails这些类的作用及源码分析。</p></li><li><p>重点记忆授权中FilterInvoction，SecurityMetadataSource，AccessDecisionManager的作用。</p></li><li><p>将这些类理解的关键是建立起关联，建立起关联的方式就是跟着本节中的案例走下去，一步步看代码如何实现的。</p></li></ol><h2 id="六、spring-security-Java配置实现自定义表单认证与授权"><a href="#六、spring-security-Java配置实现自定义表单认证与授权" class="headerlink" title="六、spring security Java配置实现自定义表单认证与授权"></a>六、spring security Java配置实现自定义表单认证与授权</h2><p>前面三节讲解了spring security的搭建以及简单的表单认证与授权原理。本篇将实现我们自定义的表单登录与认证。</p><p>本篇不会再讲项目的搭建过程，因为跟第二节的搭建如出一辙。本篇也不会将项目中所有的代码全部给出，因为代码量有点大。项目的代码被放在了github上，请拉下来根据讲解去看代码，代码的注释写的也比较详细。github地址<a href="https://github.com/wutianqi/spring_security_extend.git%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86mysql%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%AF%B9%E4%BA%8E%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%99%E9%87%8C%E6%88%AA%E5%9B%BE%E4%BC%9A%E5%BE%88%E6%98%8E%E7%99%BD%E7%9A%84%E7%BB%99%E5%87%BA%E3%80%82">https://github.com/wutianqi/spring_security_extend.git。另外，因为项目中使用了mysql数据库，对于表结构和数据这里截图会很明白的给出。</a></p><h4 id="1-项目结构及表结构"><a href="#1-项目结构及表结构" class="headerlink" title="1. 项目结构及表结构"></a>1. 项目结构及表结构</h4><p>1.1 项目结构</p><p><img src="https://note.youdao.com/yws/api/personal/file/A6099E24CA39482B93CA8EC9C865C20E?method=getImage&version=5975&cstk=szLZezq4" alt="项目结构"></p><p><img src="https://note.youdao.com/yws/api/personal/file/7A3EDE91423B417FA39C3FE1C7A01643?method=getImage&version=5974&cstk=szLZezq4" alt="项目结构2"></p><p>1.2 表结构</p><p>创建名称为<code>spring_security</code>的数据库，创建三张表：user、role、user_role</p><p>用户表（user）：</p><table><thead><tr><th>id</th><th>user_name</th><th>password</th></tr></thead><tbody><tr><td>1</td><td>admin</td><td>admin</td></tr><tr><td>2</td><td>test</td><td>test</td></tr></tbody></table><p>角色表（role）：</p><table><thead><tr><th>id</th><th>role_name</th></tr></thead><tbody><tr><td>1</td><td>user</td></tr><tr><td>2</td><td>admin</td></tr></tbody></table><p>用户角色表（user_role）：</p><table><thead><tr><th>id</th><th>user_id</th><th>role_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>2</td></tr></tbody></table><h4 id="2-项目功能"><a href="#2-项目功能" class="headerlink" title="2. 项目功能"></a>2. 项目功能</h4><p>在讲解代码之前还是要介绍一下本项目利用spring security实现的功能，便于读者分析代码。</p><p>2.1 本项目围绕着admin.jsp，user.jsp，other.jsp展开。</p><ul><li><p>admin.jsp只有admin角色的用户才可以访问，ls拥有admin角色。</p></li><li><p>user.jsp有user角色或admin角色都可以访问，zs拥有user角色。</p></li><li><p>other.jsp只要用户登录就可以访问，ww什么角色都没有。为了简单起见，项目中other.jsp就代表其他任何登录后就可以访问的路径</p></li></ul><h4 id="3-代码解读"><a href="#3-代码解读" class="headerlink" title="3. 代码解读"></a>3. 代码解读</h4><p>关于spring security认证与授权原理的讲解在前一篇讲的比较清楚了，这里不再详细介绍，这里只介绍一下自己认为比较重要的代码。</p><p>3.1 MySecurityConfig</p><p>spring secuirty提供了一种后处理bean方式提供一个自定义配置过滤器的口子，就是下面这段代码：</p><p><img src="https://note.youdao.com/yws/api/personal/file/99D529E5C8FB4F9FA3283DFE02F91E07?method=getImage&version=6030&cstk=szLZezq4" alt="自定义配置过滤器"></p><p>这段代码对FilterSecurityInterceptor的AccessDecisionManager属性进行了自定义的配置。目的是让spring security用我们自定义的AccessDecisionManager。</p><p>3.2 MyAccessDecisionManager</p><p>在用户没有登录时，decide中的authentication参数是AnonymousAuthenticationToken，此时他会有ROLE_ANONYMOUS的角色，就是匿名角色。这是AnonymousAuthenticationFilter来做的。</p><p>这样下面这段代码就好理解了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(authorityString.contains(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//未登录</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.3 MyAuthenticationProvider</p><p>我们的MyAuthenticationProvider继承了AbstractUserDetailsAuthenticationProvider，我们自定义provider的真正认证过程实际发生在AbstractUserDetailsAuthenticationProvider的authenticate中。我们的MyAuthenticationProvider只是实现了retrieveUser来获取用户信息并在其中检查用户名是否存在，以及实现了additionalAuthenticationChecks检验用户输入的密码。其他一些诸如填充完整的Authentication的行为交给父类来做了。因为父类处理的很好所以我们无须自己再做。MySuccessHandler也是将认证成功后的处理都交给父类去处理了。</p><h4 id="4-小节"><a href="#4-小节" class="headerlink" title="4. 小节"></a>4. 小节</h4><p>本spring security系列，只是对我们web应用中常见的表单认证与登录进行了讲解。spring security还有很多安全功能。比如方法安全，域安全等。本文没有进行讲解。想了解更多，可以查看官方文档。自己以后也会再学，到时候也会再写相关博文。</p><p>项目地址 <a href="https://github.com/wutianqi/spring_security_extend.git">https://github.com/wutianqi/spring_security_extend.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://www.cnblogs.com/wutianqi/p/9174227.html&quot;&gt;spring-security-4介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然现在已经到了5.x版本了，但是大同小异，知识还是不会过时的。。。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Apdex%20%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%95%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Apdex%20%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%95%B0/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<p>Apdex 应用性能指数是站在用户角度衡量用户对应用满意度的数值。</p><p>假设用户对于服务的响应容忍度权值为 T</p><table><thead><tr><th>满意（1分）</th><th>容忍（0.5分）</th><th>失望（0分）</th></tr></thead><tbody><tr><td>0~T</td><td>T~4T</td><td>4T~</td></tr></tbody></table><p>Apdex指数 &#x3D; (满意样本 x 1 + 容忍样本 x 0.5)&#x2F; 样本总数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Apdex 应用性能指数是站在用户角度衡量用户对应用满意度的数值。&lt;/p&gt;
&lt;p&gt;假设用户对于服务的响应容忍度权值为 T&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;满意（1分）&lt;/th&gt;
&lt;th&gt;容忍（0.5分）&lt;/th&gt;
&lt;th&gt;失望（0分）&lt;/th&gt;
&lt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Elasticsearch%20Java%20Rest%20Client/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Elasticsearch%20Java%20Rest%20Client/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Elasticsearch 6.x</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Rest client 分成两部分：</p><ul><li>Java Low Level REST Client<br>官方低级别 es 客户端，使用 http 协议与 Elastiicsearch 集群通信，与所有 es 版本兼容。</li><li>Java High level REST Client<br>官方高级别 es 客户端，基于低级别的客户端，它会暴露 API 特定的方法。</li></ul><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">6.3</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">        RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br></pre></td></tr></table></figure><h2 id="文档-Document-API"><a href="#文档-Document-API" class="headerlink" title="文档(Document) API"></a>文档(Document) API</h2><p>单文档 API</p><ul><li>index API</li><li>Get API</li><li>Delete API</li><li>Update API</li></ul><p>多文档 API</p><ul><li>Bulk API</li><li>Multi-Get API</li></ul><h3 id="Index-API"><a href="#Index-API" class="headerlink" title="Index API"></a>Index API</h3><h4 id="IndexRequest"><a href="#IndexRequest" class="headerlink" title="IndexRequest"></a>IndexRequest</h4><p>四种方式构建 IndexRequest：</p><ol><li>json</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>,  <span class="comment">// 索引 Index</span></span><br><span class="line">        <span class="string">&quot;doc&quot;</span>,  <span class="comment">// Type </span></span><br><span class="line">        <span class="string">&quot;1&quot;</span>);  <span class="comment">// 文档 Document Id </span></span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;user\&quot;:\&quot;kimchy\&quot;,&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;message\&quot;:\&quot;trying out Elasticsearch\&quot;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">indexRequest.source(jsonString, XContentType.JSON); <span class="comment">// 文档源格式为 json string</span></span><br></pre></td></tr></table></figure><ol><li>Map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">jsonMap.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>);</span><br><span class="line">jsonMap.put(<span class="string">&quot;postDate&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">jsonMap.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;trying out Elasticsearch&quot;</span>);</span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .source(jsonMap);  <span class="comment">// 会自动将 Map 转换为 JSON 格式</span></span><br></pre></td></tr></table></figure><ol><li>XContentBuilder : Document Source 提供的帮助类，专门用来产生 json 格式的数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XContentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> XContentFactory.jsonBuilder();</span><br><span class="line">builder.startObject();</span><br><span class="line">&#123;</span><br><span class="line">    builder.field(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>);</span><br><span class="line">    builder.timeField(<span class="string">&quot;postDate&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    builder.field(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;trying out Elasticsearch&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">builder.endObject();</span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .source(builder); </span><br></pre></td></tr></table></figure><ol><li>Object 键值对</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .source(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>,</span><br><span class="line">                <span class="string">&quot;postDate&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">                <span class="string">&quot;message&quot;</span>, <span class="string">&quot;trying out Elasticsearch&quot;</span>); </span><br></pre></td></tr></table></figure><h4 id="同步索引"><a href="#同步索引" class="headerlink" title="同步索引"></a>同步索引</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.index(indexRequest);</span><br></pre></td></tr></table></figure><h4 id="异步索引"><a href="#异步索引" class="headerlink" title="异步索引"></a>异步索引</h4><p>异步执行函数需要添加 listener 作为回调函数, 而对于 index 而言，这个 listener 的类型就是 ActionListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;IndexResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;IndexResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(IndexResponse indexResponse)</span> &#123; <span class="comment">//执行成功，调用 onResponse 函数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123; <span class="comment">//执行失败，调用 onFailure 函数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> client.indexAsync(indexRequest, listener); </span><br></pre></td></tr></table></figure><h4 id="IndexResponse"><a href="#IndexResponse" class="headerlink" title="IndexResponse"></a>IndexResponse</h4><p>不管是同步还是异步，如果调用成功，都会返回 IndexRespose 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">tring</span> <span class="variable">index</span> <span class="operator">=</span> indexResponse.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> indexResponse.getType();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> indexResponse.getId();</span><br><span class="line"><span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> indexResponse.getVersion();</span><br><span class="line"><span class="keyword">if</span> (indexResponse.getResult() == DocWriteResponse.Result.CREATED) &#123;</span><br><span class="line">   <span class="comment">// 文档第一次创建 </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexResponse.getResult() == DocWriteResponse.Result.UPDATED) &#123;</span><br><span class="line">   <span class="comment">// 文档之前已存在，当前是重写</span></span><br><span class="line">&#125;</span><br><span class="line">ReplicationResponse.<span class="type">ShardInfo</span> <span class="variable">shardInfo</span> <span class="operator">=</span> indexResponse.getShardInfo();</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getTotal() != shardInfo.getSuccessful()) &#123;</span><br><span class="line">    <span class="comment">// 成功的分片数量少于总分片数量 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getFailed() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> failure.reason();  <span class="comment">// 处理潜在的失败信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GET-API"><a href="#GET-API" class="headerlink" title="GET API"></a>GET API</h3><h4 id="GetRequest"><a href="#GetRequest" class="headerlink" title="GetRequest"></a>GetRequest</h4><p>每个 GET 请求都必须需传入下面 3 个参数：</p><ul><li>Index</li><li>Type</li><li>Document id</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>, </span><br><span class="line">        <span class="string">&quot;doc&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;1&quot;</span>);   </span><br></pre></td></tr></table></figure><p>可选参数：</p><ol><li>不获取源数据，默认是获取的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRequest.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE); </span><br></pre></td></tr></table></figure><ol><li>配置返回数据中包含指定字段</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] includes = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;message&quot;</span>, <span class="string">&quot;*Date&quot;</span>&#125;;</span><br><span class="line">String[] excludes = Strings.EMPTY_ARRAY;</span><br><span class="line"><span class="type">FetchSourceContext</span> <span class="variable">fetchSourceContext</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">true</span>, includes, excludes);</span><br><span class="line">getRequest.fetchSourceContext(fetchSourceContext); </span><br></pre></td></tr></table></figure><ol><li>配置返回数据中排除指定字段</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] includes = Strings.EMPTY_ARRAY;</span><br><span class="line">String[] excludes = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;message&quot;</span>&#125;;</span><br><span class="line"><span class="type">FetchSourceContext</span> <span class="variable">fetchSourceContext</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">true</span>, includes, excludes);</span><br><span class="line">getRequest.fetchSourceContext(fetchSourceContext); </span><br></pre></td></tr></table></figure><ol><li>实时 默认为 true</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRequest.realtime(false);</span><br></pre></td></tr></table></figure><ol><li>版本</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRequest.version(2); </span><br></pre></td></tr></table></figure><ol><li>版本类型</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getRequest.versionType(VersionType.EXTERNAL);</span><br></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>同步执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetResponse getResponse = client.get(getRequest);</span><br></pre></td></tr></table></figure><p>异步执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;IndexResponse&gt; listener = new ActionListener&lt;IndexResponse&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onResponse(IndexResponse indexResponse) &#123; //执行成功，调用 onResponse 函数</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFailure(Exception e) &#123; //执行失败，调用 onFailure 函数</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GetResponse getResponse = client.indexAsync(indexRequest, listener); </span><br></pre></td></tr></table></figure><h4 id="GetResponse"><a href="#GetResponse" class="headerlink" title="GetResponse"></a>GetResponse</h4><p>返回的 GetResponse 对象包含要请求的文档数据（包含元数据和字段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> getResponse.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> getResponse.getType();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> getResponse.getId();</span><br><span class="line"><span class="keyword">if</span> (getResponse.isExists()) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> getResponse.getVersion();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> getResponse.getSourceAsString(); <span class="comment">// string 形式   </span></span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = getResponse.getSourceAsMap(); <span class="comment">// map </span></span><br><span class="line">    <span class="type">byte</span>[] sourceAsBytes = getResponse.getSourceAsBytes(); <span class="comment">// 字节形式 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 没有发现请求的文档 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Exists-API"><a href="#Exists-API" class="headerlink" title="Exists API"></a>Exists API</h3><p>如果文档存在 Exists API 返回 true, 否则返回 fasle。</p><h4 id="GetRequest-1"><a href="#GetRequest-1" class="headerlink" title="GetRequest"></a>GetRequest</h4><p>用法和 Get API 差不多，两个对象的可选参数是相同的。由于 exists() 方法只返回 true 或者 false， 应该将获取 _source 以及任何存储字段的值关闭，尽量使请求轻量级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetRequest</span> <span class="variable">getRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(</span><br><span class="line">    <span class="string">&quot;posts&quot;</span>,  <span class="comment">// Index</span></span><br><span class="line">    <span class="string">&quot;doc&quot;</span>,    <span class="comment">// Type</span></span><br><span class="line">    <span class="string">&quot;1&quot;</span>);     <span class="comment">// Document id</span></span><br><span class="line">getRequest.fetchSourceContext(<span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">false</span>));  <span class="comment">// 禁用 _source 字段</span></span><br><span class="line">getRequest.storedFields(<span class="string">&quot;_none_&quot;</span>); <span class="comment">// 禁止存储任何字段   </span></span><br></pre></td></tr></table></figure><h4 id="执行-1"><a href="#执行-1" class="headerlink" title="执行"></a>执行</h4><p>同步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.exists(getRequest);</span><br></pre></td></tr></table></figure><p>异步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;Boolean&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Boolean exists)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.existsAsync(getRequest, listener); </span><br></pre></td></tr></table></figure><h3 id="Delete-API"><a href="#Delete-API" class="headerlink" title="Delete API"></a>Delete API</h3><h4 id="DeleteRequest"><a href="#DeleteRequest" class="headerlink" title="DeleteRequest"></a>DeleteRequest</h4><p>DeleteRequest 必须传入下面参数：</p><ul><li>Index</li><li>Type</li><li>Document id</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteRequest</span> <span class="variable">deleteRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>,   <span class="comment">// index </span></span><br><span class="line">        <span class="string">&quot;doc&quot;</span>,     <span class="comment">// doc</span></span><br><span class="line">        <span class="string">&quot;1&quot;</span>);      <span class="comment">// document id</span></span><br></pre></td></tr></table></figure><p>可选参数：</p><ol><li>超时时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteRequest.timeout(TimeValue.timeValueMinutes(<span class="number">2</span>)); </span><br><span class="line">deleteRequest.timeout(<span class="string">&quot;2m&quot;</span>); </span><br></pre></td></tr></table></figure><ol><li>刷新策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); </span><br><span class="line">deleteRequest.setRefreshPolicy(<span class="string">&quot;wait_for&quot;</span>);    </span><br></pre></td></tr></table></figure><ol><li>版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteRequest.version(<span class="number">2</span>); </span><br></pre></td></tr></table></figure><ol><li>版本类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteRequest.versionType(VersionType.EXTERNAL); </span><br></pre></td></tr></table></figure><h4 id="执行-2"><a href="#执行-2" class="headerlink" title="执行"></a>执行</h4><p>同步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.delete(deleteRequest);</span><br></pre></td></tr></table></figure><p>异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;DeleteResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;DeleteResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(DeleteResponse deleteResponse)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> client.deleteAsync(deleteResponse, listener);</span><br></pre></td></tr></table></figure><h4 id="DeleteResponse"><a href="#DeleteResponse" class="headerlink" title="DeleteResponse"></a>DeleteResponse</h4><p>DeleteResponse 可以检索执行操作的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> deleteResponse.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> deleteResponse.getType();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> deleteResponse.getId();</span><br><span class="line"><span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> deleteResponse.getVersion();</span><br><span class="line">ReplicationResponse.<span class="type">ShardInfo</span> <span class="variable">shardInfo</span> <span class="operator">=</span> deleteResponse.getShardInfo();</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getTotal() != shardInfo.getSuccessful()) &#123;</span><br><span class="line">    <span class="comment">// 成功分片数目小于总分片</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getFailed() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> failure.reason(); <span class="comment">// 处理潜在失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Update-API"><a href="#Update-API" class="headerlink" title="Update API"></a>Update API</h3><h4 id="UpdateRequest"><a href="#UpdateRequest" class="headerlink" title="UpdateRequest"></a>UpdateRequest</h4><p>UpdateRequest 必须传入下面参数：</p><ul><li>Index</li><li>Type</li><li>Document id</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(</span><br><span class="line">        <span class="string">&quot;posts&quot;</span>,   <span class="comment">// index </span></span><br><span class="line">        <span class="string">&quot;doc&quot;</span>,     <span class="comment">// doc</span></span><br><span class="line">        <span class="string">&quot;1&quot;</span>);      <span class="comment">// document id</span></span><br></pre></td></tr></table></figure><p>和 index api 类似，UpdateRequest 也支持四种文档格式：</p><ol><li>json</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> <span class="string">&quot;&#123;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;updated\&quot;:\&quot;2017-01-01\&quot;,&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\&quot;reason\&quot;:\&quot;daily update\&quot;&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">request.doc(jsonString, XContentType.JSON); </span><br></pre></td></tr></table></figure><ol><li>map</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; jsonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">jsonMap.put(<span class="string">&quot;updated&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">jsonMap.put(<span class="string">&quot;reason&quot;</span>, <span class="string">&quot;daily update&quot;</span>);</span><br><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .doc(jsonMap); </span><br></pre></td></tr></table></figure><ol><li>XContentBuilder</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">XContentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> XContentFactory.jsonBuilder();</span><br><span class="line">builder.startObject();</span><br><span class="line">&#123;</span><br><span class="line">    builder.timeField(<span class="string">&quot;updated&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    builder.field(<span class="string">&quot;reason&quot;</span>, <span class="string">&quot;daily update&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">builder.endObject();</span><br><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .doc(builder);  </span><br></pre></td></tr></table></figure><ol><li>object 键值对</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateRequest</span> <span class="variable">updateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">        .doc(<span class="string">&quot;updated&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">             <span class="string">&quot;reason&quot;</span>, <span class="string">&quot;daily update&quot;</span>); </span><br></pre></td></tr></table></figure><p>可选参数：</p><ol><li>超时时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>)); </span><br><span class="line">updateRequest.timeout(<span class="string">&quot;1s&quot;</span>); </span><br></pre></td></tr></table></figure><ol><li>刷新策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); </span><br><span class="line">updateRequest.setRefreshPolicy(<span class="string">&quot;wait_for&quot;</span>);  </span><br></pre></td></tr></table></figure><ol><li>冲突后重试次数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.retryOnConflict(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ol><li>获取数据源，默认是开启的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.fetchSource(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><ol><li>包括特定字段</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] includes = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;updated&quot;</span>, <span class="string">&quot;r*&quot;</span>&#125;;</span><br><span class="line">String[] excludes = Strings.EMPTY_ARRAY;</span><br><span class="line">updateRequest.fetchSource(<span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">true</span>, includes, excludes)); </span><br></pre></td></tr></table></figure><ol><li>排除特定字段</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] includes = Strings.EMPTY_ARRAY;</span><br><span class="line">String[] excludes = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;updated&quot;</span>&#125;;</span><br><span class="line">updateRequest.fetchSource(<span class="keyword">new</span> <span class="title class_">FetchSourceContext</span>(<span class="literal">true</span>, includes, excludes)); </span><br></pre></td></tr></table></figure><ol><li>指定版本</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.version(<span class="number">2</span>); </span><br></pre></td></tr></table></figure><ol><li>禁用 noop detection</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.scriptedUpsert(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><ol><li>设置如果更新的文档不存在，就必须要创建一个</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateRequest.docAsUpsert(<span class="literal">true</span>); </span><br></pre></td></tr></table></figure><h4 id="执行-3"><a href="#执行-3" class="headerlink" title="执行"></a>执行</h4><p>同步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.update(updateRequest);</span><br></pre></td></tr></table></figure><p>异步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;UpdateResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;UpdateResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(UpdateResponse updateResponse)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> client.updateAsync(request, listener); </span><br></pre></td></tr></table></figure><h4 id="UpdateResponse"><a href="#UpdateResponse" class="headerlink" title="UpdateResponse"></a>UpdateResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> updateResponse.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> updateResponse.getType();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> updateResponse.getId();</span><br><span class="line"><span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> updateResponse.getVersion();</span><br><span class="line"><span class="keyword">if</span> (updateResponse.getResult() == DocWriteResponse.Result.CREATED) &#123;</span><br><span class="line">    <span class="comment">// 文档已创建</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) &#123;</span><br><span class="line">    <span class="comment">// 文档已更新</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResponse.getResult() == DocWriteResponse.Result.DELETED) &#123;</span><br><span class="line">    <span class="comment">// 文档已删除</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResponse.getResult() == DocWriteResponse.Result.NOOP) &#123;</span><br><span class="line">    <span class="comment">// 文档不受更新的影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 UpdateRequest 中设置了获取源数据，响应中则包含了更新后的源文档信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GetResult</span> <span class="variable">result</span> <span class="operator">=</span> updateResponse.getGetResult(); </span><br><span class="line"><span class="keyword">if</span> (result.isExists()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> result.sourceAsString();  <span class="comment">// 将获取的文档以 string 格式输出</span></span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = result.sourceAsMap(); <span class="comment">// 以 Map 格式输出</span></span><br><span class="line">    <span class="type">byte</span>[] sourceAsBytes = result.source();  <span class="comment">// 字节形式</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下，不会返回文档源数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测是否分片失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReplicationResponse.<span class="type">ShardInfo</span> <span class="variable">shardInfo</span> <span class="operator">=</span> updateResponse.getShardInfo();</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getTotal() != shardInfo.getSuccessful()) &#123;</span><br><span class="line">    <span class="comment">// 成功的分片数量小于总分片数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (shardInfo.getFailed() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ReplicationResponse.ShardInfo.Failure failure : shardInfo.getFailures()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">reason</span> <span class="operator">=</span> failure.reason(); <span class="comment">// 得到分片失败的原因</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bulk-API-批量处理"><a href="#Bulk-API-批量处理" class="headerlink" title="Bulk API 批量处理"></a>Bulk API 批量处理</h3><h4 id="BulkRequest-批量请求"><a href="#BulkRequest-批量请求" class="headerlink" title="BulkRequest 批量请求"></a>BulkRequest 批量请求</h4><p>使用 BulkRequest 可以在一次请求中执行多个索引，更新和删除的操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();  </span><br><span class="line">request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>)  </span><br><span class="line">        .source(XContentType.JSON,<span class="string">&quot;field&quot;</span>, <span class="string">&quot;foo&quot;</span>)); <span class="comment">// 将第一个 IndexRequest 添加到批量请求中</span></span><br><span class="line">request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;2&quot;</span>)  </span><br><span class="line">        .source(XContentType.JSON,<span class="string">&quot;field&quot;</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// 第二个</span></span><br><span class="line">request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;3&quot;</span>)  </span><br><span class="line">        .source(XContentType.JSON,<span class="string">&quot;field&quot;</span>, <span class="string">&quot;baz&quot;</span>)); <span class="comment">// 第三个</span></span><br></pre></td></tr></table></figure><p>在同一个 BulkRequest 也可以添加不同的操作类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">bulkRequest.add(<span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;3&quot;</span>)); </span><br><span class="line">bulkRequest.add(<span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;2&quot;</span>) </span><br><span class="line">        .doc(XContentType.JSON,<span class="string">&quot;other&quot;</span>, <span class="string">&quot;test&quot;</span>));j</span><br><span class="line">bulkRequest.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;4&quot;</span>)  </span><br><span class="line">        .source(XContentType.JSON,<span class="string">&quot;field&quot;</span>, <span class="string">&quot;baz&quot;</span>));</span><br></pre></td></tr></table></figure><p>可选参数：</p><ol><li>超时时间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bulkRequest.timeout(TimeValue.timeValueMinutes(<span class="number">2</span>)); </span><br><span class="line">bulkRequest.timeout(<span class="string">&quot;2m&quot;</span>); </span><br></pre></td></tr></table></figure><ol><li>刷新策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bulkRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); </span><br><span class="line">bulkRequest.setRefreshPolicy(<span class="string">&quot;wait_for&quot;</span>); </span><br></pre></td></tr></table></figure><ol><li>设置在批量操作前必须有几个分片处于激活状态</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bulkRequest.waitForActiveShards(<span class="number">2</span>); </span><br><span class="line">bulkRequest.waitForActiveShards(ActiveShardCount.ALL);  <span class="comment">// 全部分片都处于激活状态</span></span><br><span class="line">bulkRequest.waitForActiveShards(ActiveShardCount.DEFAULT);  <span class="comment">// 默认</span></span><br><span class="line">bulkRequest.waitForActiveShards(ActiveShardCount.ONE);  <span class="comment">// 一个</span></span><br></pre></td></tr></table></figure><h4 id="执行-4"><a href="#执行-4" class="headerlink" title="执行"></a>执行</h4><p>同步请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> client.bulk(request);</span><br></pre></td></tr></table></figure><p>异步请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;BulkResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;BulkResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(BulkResponse bulkResponse)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> client.bulkAsync(request, listener); </span><br></pre></td></tr></table></figure><h4 id="BulkResponse"><a href="#BulkResponse" class="headerlink" title="BulkResponse"></a>BulkResponse</h4><p>BulkResponse 中包含执行操作后的信息，并允许对每个操作结果迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (BulkItemResponse bulkItemResponse : bulkResponse) &#123; <span class="comment">// 遍历所有的操作结果</span></span><br><span class="line">    <span class="type">DocWriteResponse</span> <span class="variable">itemResponse</span> <span class="operator">=</span> bulkItemResponse.getResponse(); <span class="comment">// 获取操作结果的响应，可以是  IndexResponse, UpdateResponse or DeleteResponse, 它们都可以惭怍是 DocWriteResponse 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bulkItemResponse.getOpType() == DocWriteRequest.OpType.INDEX</span><br><span class="line">            || bulkItemResponse.getOpType() == DocWriteRequest.OpType.CREATE) &#123; </span><br><span class="line">        <span class="type">IndexResponse</span> <span class="variable">indexResponse</span> <span class="operator">=</span> (IndexResponse) itemResponse; <span class="comment">// index 操作后的响应结果</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bulkItemResponse.getOpType() == DocWriteRequest.OpType.UPDATE) &#123; </span><br><span class="line">        <span class="type">UpdateResponse</span> <span class="variable">updateResponse</span> <span class="operator">=</span> (UpdateResponse) itemResponse; <span class="comment">// update 操作后的响应结果</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bulkItemResponse.getOpType() == DocWriteRequest.OpType.DELETE) &#123; </span><br><span class="line">        <span class="type">DeleteResponse</span> <span class="variable">deleteResponse</span> <span class="operator">=</span> (DeleteResponse) itemResponse; <span class="comment">// delete 操作后的响应结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，批量响应还有一个非常便捷的方法来检测是否有一个或多个操作失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bulkResponse.hasFailures()) &#123; <span class="comment">// 表示至少有一个操作失败</span></span><br><span class="line">    <span class="comment">// 遍历所有的操作结果，检查是否是失败的操作，并获取对应的失败信息</span></span><br><span class="line"><span class="keyword">for</span> (BulkItemResponse bulkItemResponse : bulkResponse) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bulkItemResponse.isFailed()) &#123; <span class="comment">// 检测给定的操作是否失败</span></span><br><span class="line">            BulkItemResponse.<span class="type">Failure</span> <span class="variable">failure</span> <span class="operator">=</span> bulkItemResponse.getFailure(); <span class="comment">// 获取失败信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BulkProcessor"><a href="#BulkProcessor" class="headerlink" title="BulkProcessor"></a>BulkProcessor</h4><p>BulkProcessor 是为了简化 Bulk API 的操作提供的一个工具类，要执行操作，就需要下面组件:</p><ul><li>RestHighLevelClient 用来执行 BulkRequest 并获取 BulkResponse</li><li>BulkProcessor.Listener 对 BulkRequest 执行前后以及失败时监听</li></ul><p>BulkProcessor.builder 方法用来构建一个新的 BulkProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ulkProcessor.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkProcessor</span>.Listener() &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 在每个 BulkRequest 执行前调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request,</span></span><br><span class="line"><span class="params">            BulkResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 在每个 BulkRequest 执行后调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request, Throwable failure)</span> &#123;</span><br><span class="line">        <span class="comment">// 失败时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">BulkProcessor</span> <span class="variable">bulkProcessor</span> <span class="operator">=</span></span><br><span class="line">        BulkProcessor.builder(client::bulkAsync, listener).build(); <span class="comment">// 构建 BulkProcessor, RestHighLevelClient.bulkAsync()  用来执行 BulkRequest </span></span><br></pre></td></tr></table></figure><p>BulkProcessor.Builder 提供了多个方法来配置 BulkProcessor 如何来处理请求的执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BulkProcessor.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> BulkProcessor.builder(client::bulkAsync, listener);</span><br><span class="line">builder.setBulkActions(<span class="number">500</span>); <span class="comment">// 指定多少操作时，就会刷新一次</span></span><br><span class="line">builder.setBulkSize(<span class="keyword">new</span> <span class="title class_">ByteSizeValue</span>(<span class="number">1L</span>, ByteSizeUnit.MB)); </span><br><span class="line">builder.setConcurrentRequests(<span class="number">0</span>);  <span class="comment">// 指定多大容量，就会刷新一次</span></span><br><span class="line">builder.setFlushInterval(TimeValue.timeValueSeconds(<span class="number">10L</span>)); <span class="comment">// 允许并发执行的数量 </span></span><br><span class="line">builder.setBackoffPolicy(BackoffPolicy</span><br><span class="line">        .constantBackoff(TimeValue.timeValueSeconds(<span class="number">1L</span>), <span class="number">3</span>)); </span><br></pre></td></tr></table></figure><p>BulkProcessor 创建后，各种请求就可以添加进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IndexRequest</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;1&quot;</span>).</span><br><span class="line">        source(XContentType.JSON, <span class="string">&quot;title&quot;</span>,</span><br><span class="line">                <span class="string">&quot;In which order are my Elasticsearch queries executed?&quot;</span>);</span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">        .source(XContentType.JSON, <span class="string">&quot;title&quot;</span>,</span><br><span class="line">                <span class="string">&quot;Current status and upcoming changes in Elasticsearch&quot;</span>);</span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">three</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;posts&quot;</span>, <span class="string">&quot;doc&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">        .source(XContentType.JSON, <span class="string">&quot;title&quot;</span>,</span><br><span class="line">                <span class="string">&quot;The Future of Federated Search in Elasticsearch&quot;</span>);</span><br><span class="line"></span><br><span class="line">bulkProcessor.add(one);</span><br><span class="line">bulkProcessor.add(two);</span><br><span class="line">bulkProcessor.add(three);</span><br></pre></td></tr></table></figure><p>BulkProcessor 执行时，会对每个 bulk request调用 BulkProcessor.Listener ， listener 提供了下面方法来访问 BulkRequest 和 BulkResponse:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BulkProcessor.<span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkProcessor</span>.Listener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberOfActions</span> <span class="operator">=</span> request.numberOfActions(); <span class="comment">// 在执行前获取操作的数量</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Executing bulk [&#123;&#125;] with &#123;&#125; requests&quot;</span>,</span><br><span class="line">                executionId, numberOfActions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request,</span></span><br><span class="line"><span class="params">            BulkResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.hasFailures()) &#123; <span class="comment">// 执行后查看响应中是否包含失败的操作</span></span><br><span class="line">            logger.warn(<span class="string">&quot;Bulk [&#123;&#125;] executed with failures&quot;</span>, executionId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Bulk [&#123;&#125;] completed in &#123;&#125; milliseconds&quot;</span>,</span><br><span class="line">                    executionId, response.getTook().getMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterBulk</span><span class="params">(<span class="type">long</span> executionId, BulkRequest request, Throwable failure)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to execute bulk&quot;</span>, failure); <span class="comment">// 请求失败时打印信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请求添加到 BulkProcessor ， 它的实例可以使用下面两种方法关闭请求：</p><ol><li>awaitClose() 在请求返回后或等待一定时间关闭</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">terminated</span> <span class="operator">=</span> bulkProcessor.awaitClose(<span class="number">30L</span>, TimeUnit.SECONDS); </span><br></pre></td></tr></table></figure><ol><li>close() 立刻关闭</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bulkProcessor.close();</span><br></pre></td></tr></table></figure><p>两个方法都会在关闭前对处理器中的请求进行刷新，并避免新的请求添加进去。</p><h3 id="Multi-Get-API"><a href="#Multi-Get-API" class="headerlink" title="Multi-Get API"></a>Multi-Get API</h3><p>multiGet API 可以在单个 http 交互中并行的执行多个 get 请求。</p><h4 id="MultiGetRequest"><a href="#MultiGetRequest" class="headerlink" title="MultiGetRequest"></a>MultiGetRequest</h4><p>MultiGetRequest 实例化时参数为空，实例化后可以通过添加 MultiGetRequest.Item 来配置获取的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MultiGetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiGetRequest</span>();</span><br><span class="line">request.add(<span class="keyword">new</span> <span class="title class_">MultiGetRequest</span>.Item(</span><br><span class="line">    <span class="string">&quot;index&quot;</span>,     <span class="comment">// 索引  </span></span><br><span class="line">    <span class="string">&quot;type&quot;</span>,      <span class="comment">// 类型</span></span><br><span class="line">    <span class="string">&quot;example_id&quot;</span>));  <span class="comment">// 文档 idj</span></span><br><span class="line">request.add(<span class="keyword">new</span> <span class="title class_">MultiGetRequest</span>.Item(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;another_id&quot;</span>));  <span class="comment">// 添加另外一个条目</span></span><br></pre></td></tr></table></figure><p>可选参数：</p><p>与前面 Get API 可选参数相同</p><h4 id="执行-5"><a href="#执行-5" class="headerlink" title="执行"></a>执行</h4><p>同步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MultiGetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.multiGet(request);</span><br></pre></td></tr></table></figure><p>异步执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;MultiGetResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;MultiGetResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(MultiGetResponse response)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">client.multiGetAsync(request, listener); </span><br></pre></td></tr></table></figure><h4 id="MultiGetResponse"><a href="#MultiGetResponse" class="headerlink" title="MultiGetResponse"></a>MultiGetResponse</h4><p>MultiGetResponse 中getResponse 方法包含的 MultiGetItemResponse 顺序与请求时的相 MultiGetItemResponse ，如果执行成功，就会返回 GetResponse 对象，失败则返回 MultiGetResponse.Failure</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MultiGetItemResponse</span> <span class="variable">firstItem</span> <span class="operator">=</span> response.getResponses()[<span class="number">0</span>];</span><br><span class="line">assertNull(firstItem.getFailure());     <span class="comment">// 执行成功，则返回 null         </span></span><br><span class="line"><span class="type">GetResponse</span> <span class="variable">firstGet</span> <span class="operator">=</span> firstItem.getResponse();  <span class="comment">// 返回 GetResponse 对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> firstItem.getIndex();</span><br><span class="line"><span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> firstItem.getType();</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> firstItem.getId();</span><br><span class="line"><span class="keyword">if</span> (firstGet.isExists()) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">version</span> <span class="operator">=</span> firstGet.getVersion();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> firstGet.getSourceAsString();  <span class="comment">// string 格式      </span></span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = firstGet.getSourceAsMap(); <span class="comment">// Map </span></span><br><span class="line">    <span class="type">byte</span>[] sourceAsBytes = firstGet.getSourceAsBytes();       <span class="comment">// bytes   </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有发现文档</span></span><br><span class="line">    <span class="comment">// 尽管响应中会返回 404 状态码，也会返回一个有效的 GetResponse</span></span><br><span class="line">    <span class="comment">// 这是可以使用 isExists 方法来判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子请求中对应的 index 不存在，返回的响应中的getFailure 方法中会包含 exception:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assertNull(missingIndexItem.getResponse());    <span class="comment">// 获取的响应为空            </span></span><br><span class="line"><span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> missingIndexItem.getFailure().getFailure();  <span class="comment">// 获取 exception</span></span><br><span class="line"><span class="type">ElasticsearchException</span> <span class="variable">ee</span> <span class="operator">=</span> (ElasticsearchException) e;    </span><br><span class="line"><span class="comment">// TODO status is broken! fix in a followup</span></span><br><span class="line"><span class="comment">// assertEquals(RestStatus.NOT_FOUND, ee.status());        </span></span><br><span class="line">assertThat(e.getMessage(),</span><br><span class="line">    containsString(<span class="string">&quot;reason=no such index&quot;</span>));    </span><br></pre></td></tr></table></figure><h2 id="查询（Search）API"><a href="#查询（Search）API" class="headerlink" title="查询（Search）API"></a>查询（Search）API</h2><p>Java High Level REST Client 支持下面的 Search API：</p><ul><li>Search API</li><li>Search Scroll API</li><li>Clear Scroll API</li><li>Multi-Search API</li><li>Ranking Evaluation API</li></ul><h3 id="Search-API"><a href="#Search-API" class="headerlink" title="Search API"></a>Search API</h3><h4 id="SearchRequest"><a href="#SearchRequest" class="headerlink" title="SearchRequest"></a>SearchRequest</h4><p>searchRequest 用来完成和搜索文档，聚等相关的操作同时也提供了各种方式来完成对查询结果的高亮操作。</p><p>最基本的查询操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(); </span><br><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>(); </span><br><span class="line">searchSourceBuilder.query(QueryBuilders.matchAllQuery()); <span class="comment">// 添加 match_all 查询</span></span><br><span class="line">searchRequest.source(searchSourceBuilder); <span class="comment">// 将 SearchSourceBuilder  添加到 SeachRequest 中</span></span><br></pre></td></tr></table></figure><p>可选参数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;posts&quot;</span>);  <span class="comment">// 设置搜索的 index</span></span><br><span class="line">searchRequest.types(<span class="string">&quot;doc&quot;</span>);  <span class="comment">// 设置搜索的 type</span></span><br><span class="line">searchRequest.routing(<span class="string">&quot;routing&quot;</span>); <span class="comment">// 设置 routing 参数</span></span><br><span class="line">searchRequest.preference(<span class="string">&quot;_local&quot;</span>);  <span class="comment">// 配置搜索时偏爱使用本地分片，默认是使用随机分片</span></span><br></pre></td></tr></table></figure><h5 id="SearchSourceBuilder"><a href="#SearchSourceBuilder" class="headerlink" title="SearchSourceBuilder"></a>SearchSourceBuilder</h5><p>对搜索行为的配置可以使用 SearchSourceBuilder 来完成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();  <span class="comment">// 默认配置</span></span><br><span class="line">sourceBuilder.query(QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>)); <span class="comment">// 设置搜索，可以是任何类型的 QueryBuilder</span></span><br><span class="line">sourceBuilder.from(<span class="number">0</span>); <span class="comment">// 起始 index</span></span><br><span class="line">sourceBuilder.size(<span class="number">5</span>); <span class="comment">// 大小 size</span></span><br><span class="line">sourceBuilder.timeout(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60</span>, TimeUnit.SECONDS)); <span class="comment">// 设置搜索的超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>();</span><br><span class="line">searchRequest.source(sourceBuilder);</span><br></pre></td></tr></table></figure><p><strong>SearchSourceBuilder 可选配置有：</strong></p><h5 id="1-构建查询条件"><a href="#1-构建查询条件" class="headerlink" title="1. 构建查询条件"></a>1. 构建查询条件</h5><p>查询请求是通过使用 QueryBuilder 对象来完成的，并且支持 Query DSL（领域特定语言，是指专注于某个应用程序领域的计算机语言）。</p><p>使用构造函数来创建 QueryBuilder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MatchQueryBuilder</span>(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置查询选项</span></span><br><span class="line">matchQueryBuilder.fuzziness(Fuzziness.AUTO);  <span class="comment">// 模糊查询</span></span><br><span class="line">matchQueryBuilder.prefixLength(<span class="number">3</span>); <span class="comment">// 前缀查询的长度</span></span><br><span class="line">matchQueryBuilder.maxExpansions(<span class="number">10</span>); <span class="comment">// max expansion 选项，用来控制模糊查询</span></span><br></pre></td></tr></table></figure><p>也可以使用QueryBuilders 工具类来创建 QueryBuilder 对象。这个类提供了函数式编程风格的各种方法用来快速创建 QueryBuilder 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">QueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>)</span><br><span class="line">                                        .fuzziness(Fuzziness.AUTO)</span><br><span class="line">                                                .prefixLength(<span class="number">3</span>)</span><br><span class="line">                                                .maxExpansions(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>最后要添加到 <code>SearchSourceBuilder</code> 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchSourceBuilder.query(matchQueryBuilder);</span><br></pre></td></tr></table></figure><h5 id="2-指定排序"><a href="#2-指定排序" class="headerlink" title="2. 指定排序"></a>2. 指定排序</h5><p>SearchSourceBuilder 允许添加一个或多个SortBuilder 实例。这里包含 4 种特殊的实现, (Field-, Score-, GeoDistance- 和 ScriptSortBuilder)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceBuilder.sort(<span class="keyword">new</span> <span class="title class_">ScoreSortBuilder</span>().order(SortOrder.DESC)); <span class="comment">// 根据分数 _score 降序排列 (默认行为)</span></span><br><span class="line">sourceBuilder.sort(<span class="keyword">new</span> <span class="title class_">FieldSortBuilder</span>(<span class="string">&quot;_uid&quot;</span>).order(SortOrder.ASC));  <span class="comment">// 根据 id 降序排列</span></span><br></pre></td></tr></table></figure><h5 id="3-过滤数据源"><a href="#3-过滤数据源" class="headerlink" title="3. 过滤数据源"></a>3. 过滤数据源</h5><p>默认情况下，查询请求会返回文档的内容 _source ,当然我们也可以配置它。例如，禁止对 _source 的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceBuilder.fetchSource(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>也可以使用通配符模式以更细的粒度包含或排除特定的字段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] includeFields = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;title&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;innerObject.*&quot;</span>&#125;;</span><br><span class="line">String[] excludeFields = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;_type&quot;</span>&#125;;</span><br><span class="line">sourceBuilder.fetchSource(includeFields, excludeFields);</span><br></pre></td></tr></table></figure><h5 id="4-高亮请求"><a href="#4-高亮请求" class="headerlink" title="4. 高亮请求"></a>4. 高亮请求</h5><p>可以通过在 SearchSourceBuilder 上设置 HighlightBuilder 完成对结果的高亮，而且可以配置不同的字段具有不同的高亮行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"><span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>(); </span><br><span class="line">HighlightBuilder.<span class="type">Field</span> <span class="variable">highlightTitle</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;title&quot;</span>); <span class="comment">// title 字段高亮</span></span><br><span class="line">highlightTitle.highlighterType(<span class="string">&quot;unified&quot;</span>);  <span class="comment">// 配置高亮类型</span></span><br><span class="line">highlightBuilder.field(highlightTitle);  <span class="comment">// 添加到 builder</span></span><br><span class="line">HighlightBuilder.<span class="type">Field</span> <span class="variable">highlightUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>.Field(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">highlightBuilder.field(highlightUser);</span><br><span class="line">searchSourceBuilder.highlighter(highlightBuilder);</span><br></pre></td></tr></table></figure><h5 id="5-聚合请求"><a href="#5-聚合请求" class="headerlink" title="5. 聚合请求"></a>5. 聚合请求</h5><p>要实现聚合请求分两步</p><ol><li>创建合适的 <code>AggregationBuilder</code></li><li>作为参数配置在 <code>SearchSourceBuilder</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"><span class="type">TermsAggregationBuilder</span> <span class="variable">aggregation</span> <span class="operator">=</span> AggregationBuilders.terms(<span class="string">&quot;by_company&quot;</span>)</span><br><span class="line">        .field(<span class="string">&quot;company.keyword&quot;</span>);</span><br><span class="line">aggregation.subAggregation(AggregationBuilders.avg(<span class="string">&quot;average_age&quot;</span>)</span><br><span class="line">        .field(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">searchSourceBuilder.aggregation(aggregation);</span><br></pre></td></tr></table></figure><h5 id="6-建议请求-Requesting-Suggestions"><a href="#6-建议请求-Requesting-Suggestions" class="headerlink" title="6. 建议请求 Requesting Suggestions"></a>6. 建议请求 Requesting Suggestions</h5><p>SuggestionBuilder 实现类是由 SuggestBuilders 工厂类来创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line"><span class="type">SuggestionBuilder</span> <span class="variable">termSuggestionBuilder</span> <span class="operator">=</span></span><br><span class="line">    SuggestBuilders.termSuggestion(<span class="string">&quot;user&quot;</span>).text(<span class="string">&quot;kmichy&quot;</span>); </span><br><span class="line"><span class="type">SuggestBuilder</span> <span class="variable">suggestBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>();</span><br><span class="line">suggestBuilder.addSuggestion(<span class="string">&quot;suggest_user&quot;</span>, termSuggestionBuilder); </span><br><span class="line">searchSourceBuilder.suggest(suggestBuilder);</span><br></pre></td></tr></table></figure><h5 id="7-对请求和聚合分析"><a href="#7-对请求和聚合分析" class="headerlink" title="7. 对请求和聚合分析"></a>7. 对请求和聚合分析</h5><p>分析 API 可用来对一个特定的查询操作中的请求和聚合进行分析，此时要将SearchSourceBuilder 的 profile标志位设置为 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">searchSourceBuilder.profile(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="执行-6"><a href="#执行-6" class="headerlink" title="执行"></a>执行</h4><p>同步执行</p><p>同步执行是阻塞式的，只有结果返回后才能继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest);</span><br></pre></td></tr></table></figure><p>异步执行</p><p>异步执行使用的是 listener 对结果进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ActionListener&lt;SearchResponse&gt; listener = <span class="keyword">new</span> <span class="title class_">ActionListener</span>&lt;SearchResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(SearchResponse searchResponse)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest);</span><br></pre></td></tr></table></figure><h4 id="SearchResponse"><a href="#SearchResponse" class="headerlink" title="SearchResponse"></a>SearchResponse</h4><p>查询执行完成后，会返回 SearchResponse 对象，并在对象中包含查询执行的细节和符合条件的文档集合。</p><p>SerchResponse 包含的信息如下：</p><ul><li>请求本身的信息，如 HTTP 状态码，执行时间，或者请求是否超时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestStatus</span> <span class="variable">status</span> <span class="operator">=</span> searchResponse.status(); <span class="comment">// HTTP 状态码</span></span><br><span class="line"><span class="type">TimeValue</span> <span class="variable">took</span> <span class="operator">=</span> searchResponse.getTook(); <span class="comment">// 查询占用的时间</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">terminatedEarly</span> <span class="operator">=</span> searchResponse.isTerminatedEarly(); <span class="comment">// 是否由于 SearchSourceBuilder 中设置 terminateAfter 而过早终止</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> searchResponse.isTimedOut(); <span class="comment">// 是否超时</span></span><br></pre></td></tr></table></figure><ul><li>查询影响的分片数量的统计信息，成功和失败的分片</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalShards</span> <span class="operator">=</span> searchResponse.getTotalShards();</span><br><span class="line"><span class="type">int</span> <span class="variable">successfulShards</span> <span class="operator">=</span> searchResponse.getSuccessfulShards();</span><br><span class="line"><span class="type">int</span> <span class="variable">failedShards</span> <span class="operator">=</span> searchResponse.getFailedShards();</span><br><span class="line"><span class="keyword">for</span> (ShardSearchFailure failure : searchResponse.getShardFailures()) &#123;</span><br><span class="line">    <span class="comment">// failures should be handled here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SearchHits</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">totalHits</span> <span class="operator">=</span> hits.getTotalHits();</span><br><span class="line"><span class="type">float</span> <span class="variable">maxScore</span> <span class="operator">=</span> hits.getMaxScore();</span><br><span class="line">SearchHit[] searchHits = hits.getHits();</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">    <span class="comment">// do something with the SearchHit</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">index</span> <span class="operator">=</span> hit.getIndex();</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> hit.getType();</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> hit.getId();</span><br><span class="line">    <span class="type">float</span> <span class="variable">score</span> <span class="operator">=</span> hit.getScore();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取文档源数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sourceAsString</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">    <span class="type">String</span> <span class="variable">documentTitle</span> <span class="operator">=</span> (String) sourceAsMap.get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; users = (List&lt;Object&gt;) sourceAsMap.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; innerObject =</span><br><span class="line">            (Map&lt;String, Object&gt;) sourceAsMap.get(<span class="string">&quot;innerObject&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于 Elasticsearch 6.x&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Rest client 分成两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java Low L</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/GraphQL%20%E5%85%A5%E9%97%A8/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/GraphQL%20%E5%85%A5%E9%97%A8/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphQL-入门"><a href="#GraphQL-入门" class="headerlink" title="GraphQL 入门"></a>GraphQL 入门</h2><p>GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。</p><p>一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是 me，这个用户的名称可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  me: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一并的还有每个类型上字段的解析函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Query_me(request) &#123;</span><br><span class="line">  return request.auth.user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User_name(user) &#123;</span><br><span class="line">  return user.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  me &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;me&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GraphQL-的查询和变更"><a href="#GraphQL-的查询和变更" class="headerlink" title="GraphQL 的查询和变更"></a>GraphQL 的查询和变更</h2><h4 id="字段（Fields）"><a href="#字段（Fields）" class="headerlink" title="字段（Fields）"></a>字段（Fields）</h4><p>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询和其结果拥有几乎一样的结构。这是 GraphQL 最重要的特性，因为这样一来，你就总是能得到你想要的数据，而服务器也准确地知道客户端请求的字段。</p><p><code>name</code> 字段返回 <code>String</code> 类型，在这个示例中是《星球大战》主角的名字是：<code>&quot;R2-D2&quot;</code>。</p><p>前一例子中，我们请求了我们主角的名字，返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    # 查询可以有备注！</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，friends 返回了一个数组的项目，GraphQL 查询会同等看待单个项目或者一个列表的项目，然而我们可以通过 schema 所指示的内容来预测将会得到哪一种。</p><h4 id="参数（Arguments）"><a href="#参数（Arguments）" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h4><p>即使我们能做的仅仅是遍历对象及其字段，GraphQL 就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: &quot;1000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 1.72</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数可以是多种不同的类型。上面例子中，我们使用了一个枚举类型，其代表了一个有限选项集合（本例中为长度单位，即是 METER 或者 FOOT）。GraphQL 自带一套默认类型，但是 GraphQL 服务器可以声明一套自己的定制类型，只要能序列化成你的传输格式即可。</p><p><a href="https://graphql.cn/learn/schema">更多的 GraphQL 类型系统请点击这里</a></p><h4 id="别名（Aliases）"><a href="#别名（Aliases）" class="headerlink" title="别名（Aliases）"></a>别名（Aliases）</h4><p>如果你眼睛够锐利，你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 —— 这可以让你重命名结果中的字段为任意你想到的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  empireHero: hero(episode: EMPIRE) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  jediHero: hero(episode: JEDI) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;empireHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;jediHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，两个 hero 字段将会存在冲突，但是因为我们可以将其另取一个别名，我们也就可以在一次请求中得到两个结果。</p><h4 id="片段（Fragments）"><a href="#片段（Fragments）" class="headerlink" title="片段（Fragments）"></a>片段（Fragments）</h4><p>假设我们的 app 有比较复杂的页面，将正反派主角及其友军分为两拨。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次 —— 两方各一次以作比较。</p><p>这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">  friends &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到上面的查询如何漂亮地重复了字段。片段的概念经常用于将复杂的应用数据需求分割成小块，特别是你要将大量不同片段的 UI 组件组合成一个初始数据获取的时候。</p><p>在片段内使用变量 </p><p>片段可以访问查询或变更中声明的变量。详见 <a href="https://graphql.cn/learn/queries/#variables">变量</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query HeroComparison($first: Int = 3) &#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  friendsConnection(first: $first) &#123;</span><br><span class="line">    totalCount</span><br><span class="line">    edges &#123;</span><br><span class="line">      node &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 4,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 3,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h4><p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的：例如，可能是一个”下拉菜单”让你选择感兴趣的《星球大战》续集，或者是一个搜索区，或者是一组过滤器。</p><p>将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL 拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。</p><p>使用变量之前，我们得做三件事：</p><ol><li>使用 <code>$variableName</code> 替代查询中的静态值。</li><li>声明 <code>$variableName</code> 为查询接受的变量之一。</li><li>将 <code>variableName: value</code> 通过传输专用（通常是 JSON）的分离的变量字典中。</li></ol><p>全部做完之后就像这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;episode&quot;: JEDI &#125; &#125;</span><br><span class="line">query HeroNameAndFriends($episode: Episode) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们的客户端代码就只需要传入不同的变量，而不用构建一个全新的查询了。这事实上也是一个良好实践，意味着查询的参数将是动态的 —— 我们决不能使用用户提供的值来字符串插值以构建查询。</p><h4 id="变量定义（Variable-definitions）"><a href="#变量定义（Variable-definitions）" class="headerlink" title="变量定义（Variable definitions）"></a>变量定义（Variable definitions）</h4><p>变量定义看上去像是上述查询中的 ($episode: Episode)。其工作方式跟类型语言中函数的参数定义一样。它以列出所有变量，变量前缀必须为 $，后跟其类型，本例中为 Episode。</p><p>所有声明的变量都必须是标量、枚举型或者输入对象类型。所以如果想要传递一个复杂对象到一个字段上，你必须知道服务器上其匹配的类型。可以从Schema页面了解更多关于输入对象类型的信息。</p><p>变量定义可以是可选的或者必要的。上例中，Episode 后并没有 !，因此其是可选的。但是如果你传递变量的字段要求非空参数，那变量一定是必要的。</p><p>如果想要进一步了解变量定义的句法，可以学习 GraphQL 的 schema 语言。schema 语言在 Schema 中有细述。</p><h4 id="默认变量（Default-variables）"><a href="#默认变量（Default-variables）" class="headerlink" title="默认变量（Default variables）"></a>默认变量（Default variables）</h4><p>可以通过在查询中的类型定义后面附带默认值的方式，将默认值赋给变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有变量都有默认值的时候，你可以不传变量直接调用查询。如果任何变量作为变量字典的部分传递了，它将覆盖其默认值。</p><h4 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（Directives）</h4><p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。</p><p>我们来构建一个这种组件的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query Hero($episode: Episode, $withFriends: Boolean!) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends @include(if: $withFriends) &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;episode&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;withFriends&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试修改上面的变量，传递 true 给 withFriends，看看结果的变化。</p><p>我们用了 GraphQL 中一种称作指令的新特性。一个指令可以附着在字段或者片段包含的字段上，然后以任何服务端期待的方式来改变查询的执行。GraphQL 的核心规范包含两个指令，其必须被任何规范兼容的 GraphQL 服务器实现所支持：</p><ul><li>@include(if: Boolean) 仅在参数为 true 时，包含此字段。</li><li>@skip(if: Boolean) 如果参数为 true，跳过此字段。</li></ul><p>指令在你不得不通过字符串操作来增减查询的字段时解救你。服务端实现也可以定义新的指令来添加新的特性。</p><h4 id="变更（Mutations）"><a href="#变更（Mutations）" class="headerlink" title="变更（Mutations）"></a>变更（Mutations）</h4><p>GraphQL 的大部分讨论集中在数据获取，但是任何完整的数据平台也都需要一个改变服务端数据的方法。</p><p>REST 中，任何请求都可能最后导致一些服务端副作用，但是约定上建议不要使用 GET 请求来修改数据。GraphQL 也是类似 —— 技术上而言，任何查询都可以被实现为导致数据写入。然而，建一个约定来规范任何导致写入的操作都应该显式通过变更（mutation）来发送。</p><p>就如同查询一样，如果任何变更字段返回一个对象类型，你也能请求其嵌套字段。获取一个对象变更后的新状态也是十分有用的。我们来看看一个变更例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>createReview</code> 字段如何返回了新建的 <code>review</code> 的 <code>stars</code> 和 <code>commentary</code> 字段。这在变更已有数据时特别有用，例如，当一个字段自增的时候，我们可以在一个请求中变更并查询这个字段的新值。</p><p>你也可能注意到，这个例子中，我们传递的 review 变量并非标量。它是一个输入对象类型，一种特殊的对象类型，可以作为参数传递。你可以在 Schema 页面上了解到更多关于输入类型的信息。</p><h5 id="变更中的多个字段（Multiple-fields-in-mutations）"><a href="#变更中的多个字段（Multiple-fields-in-mutations）" class="headerlink" title="变更中的多个字段（Multiple fields in mutations）"></a>变更中的多个字段（Multiple fields in mutations）</h5><p>一个变更也能包含多个字段，一如查询。查询和变更之间名称之外的一个重要区别是：</p><p>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</p><p>这意味着如果我们一个请求中发送了两个 incrementCredits 变更，第一个保证在第二个之前执行，以确保我们不会出现竞态。</p><h4 id="内联片段（Inline-Fragments）"><a href="#内联片段（Inline-Fragments）" class="headerlink" title="内联片段（Inline Fragments）"></a>内联片段（Inline Fragments）</h4><p>跟许多类型系统一样，GraphQL schema 也具备定义接口和联合类型的能力。在 <a href="https://graphql.cn/learn/schema/#interfaces">schema 指南中可了解更多</a>。</p><p>如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用内联片段来取出下层具体类型的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询中，<code>hero</code> 字段返回 <code>Character</code> 类型，取决于 <code>episode</code> 参数，其可能是 <code>Human</code> 或者 <code>Droid</code> 类型。在直接选择的情况下，你只能请求 <code>Character</code> 上存在的字段，譬如 <code>name</code>。</p><p>如果要请求具体类型上的字段，你需要使用一个类型条件内联片段。因为第一个片段标注为 <code>... on Droid</code>，<code>primaryFunction</code> 仅在 <code>hero</code> 返回的 <code>Character</code> 为 <code>Droid</code> 类型时才会执行。同理适用于 <code>Human</code> 类型的 <code>height</code> 字段。</p><p>具名片段也可以用于同样的情况，因为具名片段总是附带了一个类型。</p><h4 id="元字段（Meta-fields）"><a href="#元字段（Meta-fields）" class="headerlink" title="元字段（Meta fields）"></a>元字段（Meta fields）</h4><p>某些情况下，你并不知道你将从 GraphQL 服务获得什么类型，这时候你就需要一些方法在客户端来决定如何处理这些数据。GraphQL 允许你在查询的任何位置请求 __typename，一个元字段，以获得那个位置的对象类型名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的查询中，search 返回了一个联合类型，其可能是三种选项之一。没有 __typename 字段的情况下，几乎不可能在客户端分辨开这三个不同的类型。</p><p>GraphQL 服务提供了不少元字段，剩下的部分用于描述 内省 系统。</p><h2 id="Schema-和类型"><a href="#Schema-和类型" class="headerlink" title="Schema 和类型"></a>Schema 和类型</h2><p>在本节中，，你将学到关于 GraphQL 类型系统中所有你需要了解的知识，以及类型系统如何描述可以查询的数据。因为 GraphQL 可以运行在任何后端框架或者编程语言之上，我们将摒除实现上的细节而仅仅专注于其概念。</p><h4 id="类型系统（Type-System）"><a href="#类型系统（Type-System）" class="headerlink" title="类型系统（Type System）"></a>类型系统（Type System）</h4><p>如果你之前见到过 GraphQL 查询，你就知道 GraphQL 查询语言基本上就是关于选择对象上的字段。因此，例如在下列查询中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们以一个特殊的对象 “root” 开始</li><li>选择其上的 hero 字段</li><li>对于 hero 返回的对象，我们选择 name 和 appearsIn 字段</li></ol><p>因为一个 GraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果。但是一个关于我们所需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？这便是引入 schema 的原因。</p><p>每一个 GraphQL 服务都会定义一套类型，用以描述你可能从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询。</p><h4 id="类型语言（Type-Language）"><a href="#类型语言（Type-Language）" class="headerlink" title="类型语言（Type Language）"></a>类型语言（Type Language）</h4><p>GraphQL 服务可以用任何语言编写，因为我们并不依赖于任何特定语言的句法句式（譬如 JavaScript）来与 GraphQL schema 沟通，我们定义了自己的简单语言，称之为 “GraphQL schema language” —— 它和 GraphQL 的查询语言很相似，让我们能够和 GraphQL schema 之间可以无语言差异地沟通。</p><h4 id="对象类型和字段（Object-Types-and-Fields）"><a href="#对象类型和字段（Object-Types-and-Fields）" class="headerlink" title="对象类型和字段（Object Types and Fields）"></a>对象类型和字段（Object Types and Fields）</h4><p>一个 GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段。使用 GraphQL schema language，我们可以这样表示它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这语言可读性相当好，但我们还是一起看看其用语，以便我们可以有些共通的词汇：</p><ul><li>Character 是一个 GraphQL 对象类型，表示其是一个拥有一些字段的类型。你的 schema 中的大多数类型都会是对象类型。</li><li>name 和 appearsIn 是 Character 类型上的字段。这意味着在一个操作 Character 类型的 GraphQL 查询中的任何部分，都只能出现 name 和 appearsIn 字段。</li><li>String 是内置的标量类型之一 —— 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择。后面我们将细述标量类型。</li><li>String! 表示这个字段是非空的，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</li><li>[Episode!]! 表示一个 Episode 数组。因为它也是非空的，所以当你查询 appearsIn 字段的时候，你也总能得到一个数组（零个或者多个元素）。且由于 Episode! 也是非空的，你总是可以预期到数组中的每个项目都是一个 Episode 对象。</li></ul><p>现在你知道一个 GraphQL 对象类型看上去是怎样，也知道如何阅读基础的 GraphQL 类型语言了。</p><h4 id="参数（Arguments）-1"><a href="#参数（Arguments）-1" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h4><p>GraphQL 对象类型上的每一个字段都可能有零个或者多个参数，例如下面的 length 字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有参数都是具名的，不像 JavaScript 或者 Python 之类的语言，函数接受一个有序参数列表，而在 GraphQL 中，所有参数必须具名传递。本例中，length 字段定义了一个参数，unit。</p><p>参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个默认值 —— 如果 unit 参数没有传递，那么它将会被默认设置为 METER。</p><h4 id="查询和变更类型（The-Query-and-Mutation-Types）"><a href="#查询和变更类型（The-Query-and-Mutation-Types）" class="headerlink" title="查询和变更类型（The Query and Mutation Types）"></a>查询和变更类型（The Query and Mutation Types）</h4><p>你的 schema 中大部分的类型都是普通对象类型，但是一个 schema 内有两个特殊类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 GraphQL 服务都有一个 query 类型，可能有一个 mutation 类型。这两个类型和常规对象类型无差，但是它们之所以特殊，是因为它们定义了每一个 GraphQL 查询的入口。因此如果你看到一个像这样的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  droid(id: &quot;2000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;droid&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那表示这个 GraphQL 服务需要一个 Query 类型，且其上有 hero 和 droid 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  hero(episode: Episode): Character</span><br><span class="line">  droid(id: ID!): Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变更也是类似的工作方式 —— 你在 Mutation 类型上定义一些字段，然后这些字段将作为 mutation 根字段使用，接着你就能在你的查询中调用。</p><p>有必要记住的是，除了作为 schema 的入口，Query 和 Mutation 类型与其它 GraphQL 对象类型别无二致，它们的字段也是一样的工作方式。</p><h4 id="标量类型（Scalar-Types）"><a href="#标量类型（Scalar-Types）" class="headerlink" title="标量类型（Scalar Types）"></a>标量类型（Scalar Types）</h4><p>一个对象类型有自己的名字和字段，而某些时候，这些字段必然会解析到具体数据。这就是标量类型的来源：它们表示对应 GraphQL 查询的叶子节点。</p><p>下列查询中，name 和 appearsIn 字段将解析到标量类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道这些字段没有任何次级字段 —— 因为让它们是查询的叶子节点。</p><p>GraphQL 自带一组默认标量类型：</p><ul><li>Int：有符号 32 位整数。</li><li>Float：有符号双精度浮点值。</li><li>String：UTF‐8 字符序列。</li><li>Boolean：true 或者 false。</li><li>ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li></ul><p>大部分的 GraphQL 服务实现中，都有自定义标量类型的方式。例如，我们可以定义一个 Date 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure><p>然后就取决于我们的实现中如何定义将其序列化、反序列化和验证。例如，你可以指定 Date 类型应该总是被序列化成整型时间戳，而客户端应该知道去要求任何 date 字段都是这个格式。</p><h4 id="枚举类型（Enumeration-Types）"><a href="#枚举类型（Enumeration-Types）" class="headerlink" title="枚举类型（Enumeration Types）"></a>枚举类型（Enumeration Types）</h4><p>也称作枚举（enum），枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内。这让你能够：</p><ol><li>验证这个类型的任何参数是可选值的的某一个</li><li>与类型系统沟通，一个字段总是一个有限值集合的其中一个值。</li></ol><p>下面是一个用 GraphQL schema 语言表示的 enum 定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示无论我们在 schema 的哪处使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一。</p><p>注意，各种语言实现的 GraphQL 服务会有其独特的枚举处理方式。对于将枚举作为一等公民的语言，它的实现就可以利用这个特性；而对于像 JavaScript 这样没有枚举支持的语言，这些枚举值可能就被内部映射成整数值。当然，这些细节都不会泄漏到客户端，客户端会根据字符串名称来操作枚举值。</p><h4 id="列表和非空（Lists-and-Non-Null）"><a href="#列表和非空（Lists-and-Non-Null）" class="headerlink" title="列表和非空（Lists and Non-Null）"></a>列表和非空（Lists and Non-Null）</h4><p>对象类型、标量以及枚举是 GraphQL 中你唯一可以定义的类型种类。但是当你在 schema 的其他部分使用这些类型时，或者在你的查询变量声明处使用时，你可以给它们应用额外的类型修饰符来影响这些值的验证。我们先来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们使用了一个 String 类型，并通过在类型名后面添加一个感叹号!将其标注为非空。这表示我们的服务器对于这个字段，总是会返回一个非空值，如果它结果得到了一个空值，那么事实上将会触发一个 GraphQL 执行错误，以让客户端知道发生了错误。</p><p>非空类型修饰符也可以用于定义字段上的参数，如果这个参数上传递了一个空值（不管通过 GraphQL 字符串还是变量），那么会导致服务器返回一个验证错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query DroidById($id: ID!) &#123;</span><br><span class="line">  droid(id: $id) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Variable \&quot;$id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 1,</span><br><span class="line">          &quot;column&quot;: 17</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的运作方式也类似：我们也可以使用一个类型修饰符来标记一个类型为 List，表示这个字段会返回这个类型的数组。在 GraphQL schema 语言中，我们通过将类型包在方括号（[ 和 ]）中的方式来标记列表。列表对于参数也是一样的运作方式，验证的步骤会要求对应值为数组。</p><p>非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String!]</span><br></pre></td></tr></table></figure><p>这表示数组本身可以为空，但是其不能有任何空值成员。用 JSON 举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: null // 有效</span><br><span class="line">myField: [] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, &#x27;b&#x27;] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, null, &#x27;b&#x27;] // 错误</span><br></pre></td></tr></table></figure><p>然后，我们来定义一个不可为空的字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String]!</span><br></pre></td></tr></table></figure><p>这表示数组本身不能为空，但是其可以包含空值成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: null // 错误</span><br><span class="line">myField: [] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, &#x27;b&#x27;] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, null, &#x27;b&#x27;] // 有效</span><br></pre></td></tr></table></figure><p>你可以根据需求嵌套任意层非空和列表修饰符。</p><h4 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h4><p>跟许多类型系统一样，GraphQL 支持接口。一个接口是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口。</p><p>例如，你可以用一个 Character 接口用以表示《星球大战》三部曲中的任何角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着任何实现 Character 的类型都要具有这些字段，并有对应参数和返回类型。</p><p>例如，这里有一些可能实现了 Character 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  starships: [Starship]</span><br><span class="line">  totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这两个类型都具备 Character 接口的所有字段，但也引入了其他的字段 totalCredits、starships 和 primaryFunction，这都属于特定的类型的角色。</p><p>当你要返回一个对象或者一组对象，特别是一组不同的类型时，接口就显得特别有用。</p><p>注意下面例子的查询会产生错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 4,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hero 字段返回 Character 类型，取决于 episode 参数，它可能是 Human 或者 Droid 类型。上面的查询中，你只能查询 Character 接口中存在的字段，而其中并不包含 primaryFunction。</p><p>如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在查询指南的 <a href="https://graphql.cn/learn/queries/#inline-fragments">内联片段</a> 章节了解更多相关信息。</p><h4 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h4><p>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResult = Human | Droid | Starship</span><br></pre></td></tr></table></figure><p>在我们的schema中，任何返回一个 SearchResult 类型的地方，都可能得到一个 Human、Droid 或者 Starship。注意，联合类型的成员需要是具体对象类型；你不能使用接口或者其他联合类型来创造一个联合类型。</p><p>这时候，如果你需要查询一个返回 SearchResult 联合类型的字段，那么你得使用条件片段才能查询任意字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">        &quot;height&quot;: 1.8</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;,</span><br><span class="line">        &quot;height&quot;: 1.5</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;,</span><br><span class="line">        &quot;length&quot;: 9.2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_typename 字段解析为 String，它允许你在客户端区分不同的数据类型。</p><p>此外，在这种情况下，由于 Human 和 Droid 共享一个公共接口（Character），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Character &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 name 仍然需要指定在 Starship 上，否则它不会出现在结果中，因为 Starship 并不是一个 Character！</p><h4 id="输入类型（Input-Types）"><a href="#输入类型（Input-Types）" class="headerlink" title="输入类型（Input Types）"></a>输入类型（Input Types）</h4><p>目前为止，我们只讨论过将例如枚举和字符串等标量值作为参数传递给字段，但是你也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。在 GraphQL schema language 中，输入对象看上去和常规对象一模一样，除了关键字是 input 而不是 type：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input ReviewInput &#123;</span><br><span class="line">  stars: Int!</span><br><span class="line">  commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样在变更（mutation）中使用输入对象类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入对象类型上的字段本身也可以指代输入对象类型，但是你不能在你的 schema 混淆输入和输出类型。输入对象类型的字段当然也不能拥有参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphQL-入门&quot;&gt;&lt;a href=&quot;#GraphQL-入门&quot; class=&quot;headerlink&quot; title=&quot;GraphQL 入门&quot;&gt;&lt;/a&gt;GraphQL 入门&lt;/h2&gt;&lt;p&gt;GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/REST%E9%A3%8E%E6%A0%BC%E7%90%86%E8%A7%A3/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/REST%E9%A3%8E%E6%A0%BC%E7%90%86%E8%A7%A3/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.jianshu.com/p/6e8381c9b01d">https://www.jianshu.com/p/6e8381c9b01d</a></p><h4 id="一、什么是REST"><a href="#一、什么是REST" class="headerlink" title="一、什么是REST"></a>一、什么是REST</h4><p>一句话来概括RESTful API(具有REST风格的API): 用URL定位资源，用HTTP动词（GET,HEAD,POST,PUT,PATCH,DELETE）描述操作，用响应状态码表示操作结果。</p><p>REST是一种软件架构风格，或者说是一种规范，其强调HTTP应当以资源为中心，并且规范了URI的风格；规范了HTTP请求动作（GET&#x2F;PUT&#x2F;POST&#x2F;DELETE&#x2F;HEAD&#x2F;OPTIONS）的使用，具有对应的语义。 核心概念包括：</p><h4 id="资源（Resource）："><a href="#资源（Resource）：" class="headerlink" title="资源（Resource）："></a>资源（Resource）：</h4><p>在REST中，资源可以简单的理解为URI，表示一个网络实体。比如，&#x2F;users&#x2F;1&#x2F;name，对应id&#x3D;1的用户的属性name。既然资源是URI，就会具有以下特征：名词，代表一个资源；它对应唯一的一个资源，是资源的地址。</p><h4 id="表现（Representation）："><a href="#表现（Representation）：" class="headerlink" title="表现（Representation）："></a>表现（Representation）：</h4><p>资源呈现出来的形式，比如上述URI返回的HTML或JSON，包括HTTP Header等；  REST是一个无状态的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布REST服务，客户端通过URL来定位这些资源并通过HTTP协议来访问它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p/6e8381c9b01d&quot;&gt;https://www.jianshu.com/p/6e8381c9b01d&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、什么是REST&quot;&gt;&lt;a href=&quot;#一、什么是RES</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/git%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/git%20%E7%AC%94%E8%AE%B0/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="删除本地文件后从远程仓库获取问题"><a href="#删除本地文件后从远程仓库获取问题" class="headerlink" title="删除本地文件后从远程仓库获取问题"></a>删除本地文件后从远程仓库获取问题</h3><p>在本地删除文件后，<code>git pull</code>从远程仓库获取，但是一直提示 <code>up-to-date</code>，无法获取被删除的文件。</p><p>原因：当前本地库处于另一个分支中，需将本分支发Head重置至master。</p><p>将本分支发Head重置至master:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master </span><br><span class="line">$ git reset --hard</span><br></pre></td></tr></table></figure><p>强行pull并覆盖本地文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --all  </span><br><span class="line">$ git reset --hard origin/master </span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;删除本地文件后从远程仓库获取问题&quot;&gt;&lt;a href=&quot;#删除本地文件后从远程仓库获取问题&quot; class=&quot;headerlink&quot; title=&quot;删除本地文件后从远程仓库获取问题&quot;&gt;&lt;/a&gt;删除本地文件后从远程仓库获取问题&lt;/h3&gt;&lt;p&gt;在本地删除文件后，&lt;code</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/dalin%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/dalin%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云上重新买了台穷鬼t5，菜是菜了点，但是该折腾还是要折腾的。。。</p><h2 id="设置虚拟内存"><a href="#设置虚拟内存" class="headerlink" title="设置虚拟内存"></a>设置虚拟内存</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>free -m</code> 查看内存状态, <code>Swap</code> 的值都是0，说明还没有安装虚拟内存</p><p>在 &#x2F;opt 下创建虚拟内存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/opt/swap bs=2048 count=2048000</span><br></pre></td></tr></table></figure><p>将swap文件设置为swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /opt/swap    //注意更改swap文件的权限</span><br><span class="line">mkswap /opt/swap</span><br></pre></td></tr></table></figure><p>激活swap,启用分区交换文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /opt/swap</span><br></pre></td></tr></table></figure><p>查看结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 opt]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1829        1329         169           0         330         357</span><br><span class="line">Swap:          3999         429        3570</span><br></pre></td></tr></table></figure><p>重启自动启用设置，否则机器重启后分区就失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure><p>底部添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /home/swap</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>停止swap分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /opt/swap</span><br></pre></td></tr></table></figure><p>删除掉swap文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /opt/swap</span><br></pre></td></tr></table></figure><p>查看磁盘情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 opt]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        900M     0  900M   0% /dev</span><br><span class="line">tmpfs           915M     0  915M   0% /dev/shm</span><br><span class="line">tmpfs           915M  612K  915M   1% /run</span><br><span class="line">tmpfs           915M     0  915M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        40G  9.5G   31G  24% /</span><br><span class="line">tmpfs           183M     0  183M   0% /run/user/1000</span><br><span class="line">overlay          40G  9.5G   31G  24% /var/lib/docker/overlay2/cb6202d7408b52de4ca486b57263e33e6dbb34d3adf35e86bfdffe62b9d33339/merged</span><br><span class="line">overlay          40G  9.5G   31G  24% /var/lib/docker/overlay2/25f9d8b78fa8906f7b379efce90fdd90f8e5771399f537988cf15ca450641596/merged</span><br></pre></td></tr></table></figure><h2 id="mysql-安装"><a href="#mysql-安装" class="headerlink" title="mysql 安装"></a>mysql 安装</h2><p>上一次鄙人的mysql开启了远程访问，并且没有注意安全防范，被比特币勒索了。。。但是使用远程msql服务的需求还是需要的，毕竟真的是方便，这次注意一下安全方面的配置，应该不至于再没了吧。。。</p><h4 id="1-centos8-安装mysql8"><a href="#1-centos8-安装mysql8" class="headerlink" title="1. centos8 安装mysql8"></a>1. centos8 安装mysql8</h4><p>使用最新的包管理器安装MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install @mysql</span><br></pre></td></tr></table></figure><p>设置开机自启并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable --now mysqld</span><br></pre></td></tr></table></figure><p>运行mysql_secure_installation脚本，该脚本执行一些与安全性相关的操作并设置MySQL根密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>按提示往下走即可，注意在 <code>Disallow root login remotely?</code>选项中选择 <code>n</code></p><h4 id="2-更换-mysql-默认端口"><a href="#2-更换-mysql-默认端口" class="headerlink" title="2. 更换 mysql 默认端口"></a>2. 更换 mysql 默认端口</h4><p><code>vim /etc/my.cnf</code>，添加字段 <code>port=6612</code></p><p><code>systemctl restart mysqld</code> 重启 mysql</p><p>防火墙添加6612端口白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=6612/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>centos默认使用的是firewall作为防火墙，一些常用命令：</p><ol><li>firewall-cmd –list-ports       ##查看已开放的端口</li><li>firewall-cmd –add-port&#x3D;6612&#x2F;tcp –permanent ##永久开放6612端口</li><li>firewall-cmd –remove-port&#x3D;6612&#x2F;tcp –permanent ##永久关闭6612端口</li><li>firewall-cmd –reload ##刷新</li></ol><p>阿里云控制台安全组开放 6612 端口</p><h4 id="3-mysql-允许远程主机访问"><a href="#3-mysql-允许远程主机访问" class="headerlink" title="3. mysql 允许远程主机访问"></a>3. mysql 允许远程主机访问</h4><p>登录mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p&lt;密码&gt;</span><br></pre></td></tr></table></figure><p>将 <code>mysql.user</code> 中的 <code>root</code> 的 <code>host</code> 字段设为<code>&#39;%&#39;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h4 id="4-使用脚本自动备份数据"><a href="#4-使用脚本自动备份数据" class="headerlink" title="4. 使用脚本自动备份数据"></a>4. 使用脚本自动备份数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#数据库服务器</span><br><span class="line">dbserver=&#x27;localhost&#x27;</span><br><span class="line">#数据库用户名</span><br><span class="line">dbuser=&#x27;root&#x27;</span><br><span class="line">#数据库用密码</span><br><span class="line">dbpasswd=&#x27;********&#x27;</span><br><span class="line">#需要备份的数据库，多个数据库用空格分开</span><br><span class="line">dbname=&#x27;backdata01 backdata02&#x27;</span><br><span class="line">#备份时间</span><br><span class="line">backtime=`date +%Y%m%d`</span><br><span class="line">#日志备份路径</span><br><span class="line">logpath=&#x27;/opt/data/mysqlbak/&#x27;</span><br><span class="line">#数据备份路径</span><br><span class="line">datapath=&#x27;/opt/data/mysqlbak/&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">echo &#x27;##################$backtime##########################&#x27;</span><br><span class="line"> </span><br><span class="line">#日志记录头部</span><br><span class="line">echo ‘&quot;备份时间为$&#123;backtime&#125;,备份数据库表 $&#123;dbname&#125; 开始&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">#正式备份数据库</span><br><span class="line">for table in $dbname; do</span><br><span class="line">source=`mysqldump -h $&#123;dbserver&#125; -u $&#123;dbuser&#125; -p$&#123;dbpasswd&#125; $&#123;table&#125; &gt; $&#123;logpath&#125;/$&#123;backtime&#125;.sql` 2&gt;&gt; $&#123;logpath&#125;/mysqlback.log;</span><br><span class="line">#备份成功以下操作</span><br><span class="line">if [ &quot;$?&quot; == 0 ];then</span><br><span class="line">cd $datapath</span><br><span class="line">#为节约硬盘空间，将数据库压缩</span><br><span class="line">tar zcf $&#123;table&#125;$&#123;backtime&#125;.tar.gz $&#123;backtime&#125;.sql &gt; /dev/null</span><br><span class="line">#删除原始文件，只留压缩后文件</span><br><span class="line">rm -f $&#123;datapath&#125;/$&#123;backtime&#125;.sql</span><br><span class="line">#删除七天前备份，也就是只保存7天内的备份</span><br><span class="line">find $datapath -name &quot;*.tar.gz&quot; -type f -mtime +7 -exec rm -rf &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">echo &quot;数据库表 $&#123;dbname&#125; 备份成功!!&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">else</span><br><span class="line">#备份失败则进行以下操作</span><br><span class="line">echo &quot;数据库表 $&#123;dbname&#125; 备份失败!!&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">echo &#x27;##################完成############################&#x27;</span><br></pre></td></tr></table></figure><p>创建定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">59 23 * * * ./opt/mysqldata/mysqlbak.sh  ## 每天23:59执行命令</span><br></pre></td></tr></table></figure><h2 id="redis-安装"><a href="#redis-安装" class="headerlink" title="redis 安装"></a>redis 安装</h2><h4 id="5-安装redis并且设置远程访问和密码配置"><a href="#5-安装redis并且设置远程访问和密码配置" class="headerlink" title="5. 安装redis并且设置远程访问和密码配置"></a>5. 安装redis并且设置远程访问和密码配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum -y install redis</span><br><span class="line">[root@dalin1 ~]# systemctl enable --now redis</span><br></pre></td></tr></table></figure><p>修改redis端口、设置密码、允许远程访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# vim /etc/redis.conf</span><br></pre></td></tr></table></figure><p>修改 <code>port 6369</code></p><p>注释掉 <code>bind 127.0.0.1</code>，以便让外网访问</p><p>去掉 <code>#requirepass foobared</code> 注释，foobared改为自己的密码</p><p>防火墙添加6369端口白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=6369/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>阿里云控制台安全组开放 6369 端口</p><h4 id="6-创建普通用户，以后尽量使用普通用户操作"><a href="#6-创建普通用户，以后尽量使用普通用户操作" class="headerlink" title="6. 创建普通用户，以后尽量使用普通用户操作"></a>6. 创建普通用户，以后尽量使用普通用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# adduser dalin  #创建普通用户 dalin</span><br><span class="line">[root@dalin1 ~]# passwd dalin   #修改密码</span><br><span class="line">[root@dalin1 ~]# su dalin   #切换用户</span><br></pre></td></tr></table></figure><p>普通用户只在 <code>/home/&lt;username&gt;</code> 目录下有完整权限</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>docker这么方便的东西怎么能不用呢，但是因为服务器实在太菜了，可能会卡顿，而且要时刻注意内存使用情况</p><h4 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br></pre></td></tr></table></figure><h4 id="2-设置Docker源"><a href="#2-设置Docker源" class="headerlink" title="2. 设置Docker源"></a>2. 设置Docker源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="3-安装Docker-CE"><a href="#3-安装Docker-CE" class="headerlink" title="3. 安装Docker CE"></a>3. 安装Docker CE</h4><h5 id="3-1-docker安装版本查看"><a href="#3-1-docker安装版本查看" class="headerlink" title="3.1 docker安装版本查看"></a>3.1 docker安装版本查看</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h4 id="3-2-安装docker"><a href="#3-2-安装docker" class="headerlink" title="3.2 安装docker"></a>3.2 安装docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install docker-ce-18.09.6 docker-ce-cli-18.09.6 containerd.io</span><br></pre></td></tr></table></figure><p>指定安装的docker版本为18.09.6，由于该版本目前为最新版，故可以直接安装，不用指定版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h4 id="4-启动Docker并设置开机自启"><a href="#4-启动Docker并设置开机自启" class="headerlink" title="4. 启动Docker并设置开机自启"></a>4. 启动Docker并设置开机自启</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# systemctl enable --now docker</span><br></pre></td></tr></table></figure><h4 id="5-镜像加速"><a href="#5-镜像加速" class="headerlink" title="5. 镜像加速"></a>5. 镜像加速</h4><p>使用阿里云镜像加速地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# mkdir -p /etc/docker</span><br><span class="line">[root@dalin1 ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://khv87vsk.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="docker-下安装Elasticsearch和Kibana"><a href="#docker-下安装Elasticsearch和Kibana" class="headerlink" title="docker 下安装Elasticsearch和Kibana"></a>docker 下安装Elasticsearch和Kibana</h2><p>服务器太菜，基本跑不动</p><h3 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h3><p>下载镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker pull elasticsearch:7.2.0</span><br></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -d elasticsearch:7.2.0</span><br></pre></td></tr></table></figure><p>大概率启动失败，查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 temp]# docker logs elasticsearch</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: starting java failed with [1]</span><br><span class="line">output:</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># logs/hs_err_pid132.log</span><br><span class="line">error:</span><br><span class="line">OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error=&#x27;Not enough space&#x27; (errno=12)</span><br><span class="line">at org.elasticsearch.tools.launchers.JvmErgonomics.flagsFinal(JvmErgonomics.java:126)</span><br><span class="line">at org.elasticsearch.tools.launchers.JvmErgonomics.finalJvmOptions(JvmErgonomics.java:88)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>jvm内存不足。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1]# find / -name jvm.options</span><br><span class="line">/var/lib/docker/overlay2/aa7a9ac9f293452ddf8947e9fdf3af24d602566d54b6278284751239b43e37e5/diff/usr/share/elasticsearch/config/jvm.options</span><br><span class="line">[root@dalin1]# vim /var/lib/docker/overlay2/aa7a9ac9f293452ddf8947e9fdf3af24d602566d54b6278284751239b43e37e5/diff/usr/share/elasticsearch/config/jvm.options</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">## JVM configuration</span><br><span class="line"></span><br><span class="line">################################################################</span><br><span class="line">## IMPORTANT: JVM heap size</span><br><span class="line">################################################################</span><br><span class="line">##</span><br><span class="line">## You should always set the min and max JVM heap</span><br><span class="line">## size to the same value. For example, to set</span><br><span class="line">## the heap to 4 GB, set:</span><br><span class="line">##</span><br><span class="line">## -Xms4g</span><br><span class="line">## -Xmx4g</span><br><span class="line">##</span><br><span class="line">## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</span><br><span class="line">## for more information</span><br><span class="line">##</span><br><span class="line">################################################################</span><br><span class="line"></span><br><span class="line"># Xms represents the initial size of total heap space</span><br><span class="line"># Xmx represents the maximum size of total heap space</span><br><span class="line"></span><br><span class="line">-Xms1g      #服务器实在太菜了，我改成256m</span><br><span class="line">-Xmx1g      #服务器实在太菜了，我改成256m</span><br><span class="line"></span><br><span class="line">################################################################</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker start elasticsearch</span><br></pre></td></tr></table></figure><p>检测是否启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# curl http://localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;c19d1882a695&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;-zKpqN7TQMqmPULGgdMz3w&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.2.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;508c38a&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-06-20T15:54:18.811730Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.0.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决跨域访问问题</p><p>进入容器，修改elasticsearch.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker exec -it elasticsearch /bin/bash</span><br><span class="line">vim /usr/share/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p>在elasticsearch.yml的文件末尾加上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">`exit` 退出容器后 `docker restart elasticsearch` 重启容器</span><br><span class="line"></span><br><span class="line">#### kibana安装</span><br><span class="line">下载镜像</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker pull kibana:7.2.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker run –name kibana –link&#x3D;elasticsearch:es -e ELASTICSEARCH_URL&#x3D;<a href="http://172.17.0.2:9200/">http://172.17.0.2:9200</a>  -p 5601:5601 -d kibana:7.7.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用--link连接到elasticsearch容器，并添加环境变量，指定安装es的容器地址</span><br><span class="line"></span><br><span class="line">当然也可以进入容器内部修改配置文件来设置es访问地址</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker exec -it kibana &#x2F;bin&#x2F;bash<br>vi config&#x2F;kibana.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kibana默认是优先使用环境变量的地址，然后才是配置文件kibana.yml</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">如何查询容器地址？</span><br></pre></td></tr></table></figure><h1 id="获取到容器的元数据信息"><a href="#获取到容器的元数据信息" class="headerlink" title="获取到容器的元数据信息"></a>获取到容器的元数据信息</h1><p>[root@dalin1 ~]# docker inspect [id&#x2F;name]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后，配置安全组和防火墙，开放9200、5601端口</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# firewall-cmd –add-port&#x3D;5601&#x2F;tcp –permanent<br>[root@dalin1 ~]# firewall-cmd –add-port&#x3D;9200&#x2F;tcp –permanent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这就结束了吗？是的，网上几乎所有的关于docker下安装kibana教程都是到了这一步就说完事收工、开始体验。。。但是！！！我遇到的情况是访问 `http//:ip:5601`，只会给我冰冷的大字：</span><br></pre></td></tr></table></figure><p>Kibana server is not ready yet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker logs kibana`打印日志，报错：</span><br></pre></td></tr></table></figure><p>{“type”:”log”,”@timestamp”:”2020-06-04T08:25:57Z”,”tags”:[“warning”,”elasticsearch”,”admin”],”pid”:6,”message”:”Unable to revive connection: <a href="http://172.17.0.2:9200/%22%7D">http://172.17.0.2:9200/&quot;}</a><br>{“type”:”log”,”@timestamp”:”2020-06-04T08:25:57Z”,”tags”:[“warning”,”elasticsearch”,”admin”],”pid”:6,”message”:”No living connections”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip地址是没问题的，es服务也确实起了，为什么呢？？这个问题花了我大半天的时间，找遍了网上的教程都没有相关的介绍，官网上关于docker安装kibana的教程更是少。 </span><br><span class="line"></span><br><span class="line">进入kibana容器中</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker exec -it kibana &#x2F;bin&#x2F;bash<br>bash-4.2$ ping 172.17.0.2    #没有问题，能ping通<br>bash-4.2$ curl <a href="http://120.79.43.44:9200/">http://120.79.43.44:9200</a><br>curl: (7) Failed connect to 120.79.43.44:9200; No route to host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题就出在这里！应该是防火墙的原因导致容器之间无法进行通信</span><br><span class="line"></span><br><span class="line">解决方法，依次执行以下命令</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# nmcli connection modify docker0 connection.zone trusted</p><p>[root@dalin1 ~]# systemctl stop NetworkManager.service</p><p>[root@dalin1 ~]# firewall-cmd –permanent –zone&#x3D;trusted –change-interface&#x3D;docker0</p><p>[root@dalin1 ~]# systemctl start NetworkManager.service</p><p>[root@dalin1 ~]# nmcli connection modify docker0 connection.zone trusted</p><p>[root@dalin1 ~]# systemctl restart docker.service</p><p>&#96;&#96;&#96;<br>把 <code>docker0</code> 加入防火墙白名单</p><p>重新启动容器，访问地址 <a href="http://ip:5601/">http://ip:5601</a> ，总算没有了 <code>Kibana server is not ready yet</code>,显示正在加载的图像，稍作等候即可，部署完成！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;阿里云上重新买了台穷鬼t5，菜是菜了点，但是该折腾还是要折腾的。。。&lt;/p&gt;
&lt;h2 id=&quot;设置虚拟内存&quot;&gt;&lt;a href=&quot;#设置虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;设置虚拟内存&quot;&gt;&lt;/a&gt;设置虚拟内存&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/github%E6%B7%BB%E5%8A%A0ssh%E6%96%B9%E6%B3%95/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/github%E6%B7%BB%E5%8A%A0ssh%E6%96%B9%E6%B3%95/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="生成一个新的SSH-key"><a href="#生成一个新的SSH-key" class="headerlink" title="生成一个新的SSH key"></a>生成一个新的SSH key</h3><pre><code>打开 git bash输入 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 输入一个文件名，默认是id_rsa，该步骤可直接选择默认即可。（多用户的可能要设置另一个名字，以防止冲突）输入密码，同上可以选择默认即可。</code></pre><h3 id="将新生成的SSH-key添加到github"><a href="#将新生成的SSH-key添加到github" class="headerlink" title="将新生成的SSH key添加到github"></a>将新生成的SSH key添加到github</h3><pre><code>复制key到粘贴板github设置中添加ssh key</code></pre><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p><code>ssh-keygen -t rsa -C &quot;11706@sangfor.com&quot;</code> 根据提示完成下一步</p><h3 id="添加-SSH-key到-ssh-agent"><a href="#添加-SSH-key到-ssh-agent" class="headerlink" title="添加 SSH key到 ssh-agent"></a>添加 SSH key到 ssh-agent</h3><p><code>eval $(ssh-agent -s)</code> 确保ssh-agent工作</p><p><code>ssh-add ~/.ssh/id_rsa</code> 将 ssh 私钥添加到 ssh 代理中</p><h3 id="将新生成的SSH-key添加到github-1"><a href="#将新生成的SSH-key添加到github-1" class="headerlink" title="将新生成的SSH key添加到github"></a>将新生成的SSH key添加到github</h3><p>复制key到粘贴板</p><p>github设置中添加ssh key</p><h3 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h3><p><code>ssh -T git@github.com</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p>如果某天突然报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 20.205.243.166 port 22</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>可以尝试重新运行一次 <code>ssh -T git@github.com</code> 命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows&quot;&gt;&lt;a href=&quot;#Windows&quot; class=&quot;headerlink&quot; title=&quot;Windows&quot;&gt;&lt;/a&gt;Windows&lt;/h2&gt;&lt;h3 id=&quot;生成一个新的SSH-key&quot;&gt;&lt;a href=&quot;#生成一个新的SSH-key&quot; class</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<p>k8s用的是 github.com&#x2F;gosexy&#x2F;gettext&#x2F;go-xgettext 翻译库</p><p>项目中提供shell脚本，通过翻译库自带的 go-xgettext 工具进行词条扫描，生成template.po文件</p><p>不支持增量扫描</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;k8s用的是 github.com&amp;#x2F;gosexy&amp;#x2F;gettext&amp;#x2F;go-xgettext 翻译库&lt;/p&gt;
&lt;p&gt;项目中提供shell脚本，通过翻译库自带的 go-xgettext 工具进行词条扫描，生成template.po文件&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-12-15T16:14:36.451Z</published>
    <updated>2022-12-15T16:14:36.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s-yaml文件"><a href="#k8s-yaml文件" class="headerlink" title="k8s yaml文件"></a>k8s yaml文件</h2><h3 id="yaml基础"><a href="#yaml基础" class="headerlink" title="yaml基础"></a>yaml基础</h3><p>YAML是专门用来写配置文件的语言，非常简洁和强大，使用比json更方便。它实质上是一种通用的数据串行化格式。</p><p>YAML语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大小写敏感</span><br><span class="line">使用缩进表示层级关系</span><br><span class="line">缩进时不允许使用Tal键，只允许使用空格</span><br><span class="line">缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class="line">”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略　</span><br></pre></td></tr></table></figure><p>在Kubernetes中，只需要知道两种结构类型即可：Lists和Maps</p><p>YAML Maps：</p><p>Map顾名思义指的是字典，即一个Key:Value 的键值对信息。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">　　注：---为可选的分隔符 ，当需要在一个文件中定义多个结构的时候需要使用。上述内容表示有两个键apiVersion和kind，分别对应的值为v1和Pod。</span><br></pre></td></tr></table></figure><p>Maps的value既能够对应字符串也能够对应一个Maps。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br></pre></td></tr></table></figure><p>List即列表，说白了就是数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args</span><br><span class="line"> -beijing</span><br><span class="line"> -shanghai</span><br><span class="line"> -shenzhen</span><br><span class="line"> -guangzhou</span><br></pre></td></tr></table></figure><p>当然Lists的子项也可以是Maps，Maps的子项也可以是List，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: front-end</span><br><span class="line">      image: nginx</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">    - name: flaskapp-demo</span><br><span class="line">      image: jcdemo/flaskapp</span><br><span class="line">      ports: 8080</span><br></pre></td></tr></table></figure><h3 id="k8s-yaml"><a href="#k8s-yaml" class="headerlink" title="k8s yaml"></a>k8s yaml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1             #指定api版本，此值必须在kubectl apiversion中  </span><br><span class="line">kind: Pod                  #指定创建资源的角色/类型  </span><br><span class="line">metadata:                  #资源的元数据/属性  </span><br><span class="line">  name: web04-pod          #资源的名字，在同一个namespace中必须唯一  </span><br><span class="line">  labels:                  #设定资源的标签，详情请见http://blog.csdn.net/liyingke112/article/details/77482384</span><br><span class="line">    k8s-app: apache  </span><br><span class="line">    version: v1  </span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;  </span><br><span class="line">  annotations:             #自定义注解列表  </span><br><span class="line">    - name: String         #自定义注解名字  </span><br><span class="line">spec:#specification of the resource content 指定该资源的内容  </span><br><span class="line">  restartPolicy: Always    #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器  </span><br><span class="line">  nodeSelector:            #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1  </span><br><span class="line">    zone: node1  </span><br><span class="line">  containers:  </span><br><span class="line">  - name: web04-pod        #容器的名字  </span><br><span class="line">    image: web:apache      #容器使用的镜像地址  </span><br><span class="line">    imagePullPolicy: Never #三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略，</span><br><span class="line">                           # Always，每次都检查</span><br><span class="line">                           # Never，每次都不检查（不管本地是否有）</span><br><span class="line">                           # IfNotPresent，如果本地有就不检查，如果没有就拉取</span><br><span class="line">    command: [&#x27;sh&#x27;]        #启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT  </span><br><span class="line">    args: [&quot;$(str)&quot;]       #启动容器的命令参数，对应Dockerfile中CMD参数  </span><br><span class="line">    env:                   #指定容器中的环境变量  </span><br><span class="line">    - name: str            #变量的名字  </span><br><span class="line">      value: &quot;/etc/run.sh&quot; #变量的值  </span><br><span class="line">    resources:             #资源管理，请求请见http://blog.csdn.net/liyingke112/article/details/77452630</span><br><span class="line">      requests:            #容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行  </span><br><span class="line">        cpu: 0.1           #CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m）</span><br><span class="line">        memory: 32Mi       #内存使用量  </span><br><span class="line">      limits:              #资源限制  </span><br><span class="line">        cpu: 0.5  </span><br><span class="line">        memory: 32Mi  </span><br><span class="line">    ports:  </span><br><span class="line">    - containerPort: 80    #容器开放对外的端口</span><br><span class="line">      name: httpd          #名称</span><br><span class="line">      protocol: TCP  </span><br><span class="line">    livenessProbe:         #pod内容器健康检查的设置，详情请见http://blog.csdn.net/liyingke112/article/details/77531584</span><br><span class="line">      httpGet:             #通过httpget检查健康，返回200-399之间，则认为容器正常  </span><br><span class="line">        path: /            #URI地址  </span><br><span class="line">        port: 80  </span><br><span class="line">        #host: 127.0.0.1   #主机地址  </span><br><span class="line">        scheme: HTTP  </span><br><span class="line">      initialDelaySeconds: 180 #表明第一次检测在容器启动后多长时间后开始  </span><br><span class="line">      timeoutSeconds: 5    #检测的超时时间  </span><br><span class="line">      periodSeconds: 15    #检查间隔时间  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常  </span><br><span class="line">      #  command:  </span><br><span class="line">      #    - cat  </span><br><span class="line">      #    - /tmp/health  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #tcpSocket: //通过tcpSocket检查健康   </span><br><span class="line">      #  port: number   </span><br><span class="line">    lifecycle:             #生命周期管理  </span><br><span class="line">      postStart:           #容器运行之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command:  </span><br><span class="line">            - &#x27;sh&#x27;  </span><br><span class="line">            - &#x27;yum upgrade -y&#x27;  </span><br><span class="line">      preStop:             #容器关闭之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command: [&#x27;service httpd stop&#x27;]  </span><br><span class="line">    volumeMounts:          #详情请见http://blog.csdn.net/liyingke112/article/details/76577520</span><br><span class="line">    - name: volume         #挂载设备的名字，与volumes[*].name 需要对应    </span><br><span class="line">      mountPath: /data     #挂载到容器的某个路径下  </span><br><span class="line">      readOnly: True  </span><br><span class="line">  volumes:                 #定义一组挂载设备  </span><br><span class="line">  - name: volume           #定义一个挂载设备的名字  </span><br><span class="line">    #meptyDir: &#123;&#125;  </span><br><span class="line">    hostPath:  </span><br><span class="line">      path: /opt           #挂载设备类型为hostPath，路径为宿主机下的/opt,这里设备类型支持很多种  </span><br></pre></td></tr></table></figure><h3 id="k8s-使用过程笔记"><a href="#k8s-使用过程笔记" class="headerlink" title="k8s 使用过程笔记"></a>k8s 使用过程笔记</h3><h5 id="如何进入kubernetes的一个pod"><a href="#如何进入kubernetes的一个pod" class="headerlink" title="如何进入kubernetes的一个pod"></a>如何进入kubernetes的一个pod</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类似于docker</span><br><span class="line">进入docker容器 ：</span><br><span class="line">docker exec -ti  &lt;your-container-name&gt;   /bin/sh</span><br><span class="line"></span><br><span class="line">进入pod：</span><br><span class="line">kubectl exec -ti &lt;your-pod-name&gt;  -n &lt;your-namespace&gt;  -- /bin/sh</span><br></pre></td></tr></table></figure><h5 id="关于k8s使用镜像创建pod的坑"><a href="#关于k8s使用镜像创建pod的坑" class="headerlink" title="关于k8s使用镜像创建pod的坑"></a>关于k8s使用镜像创建pod的坑</h5><p>k8s默认从远程仓库中获取镜像，可以使用镜像获取策略从本地获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">   - name: test</span><br><span class="line">     image: nginx:1.7.9     #必须带上tag</span><br><span class="line">     imagePullPolicy: Never</span><br></pre></td></tr></table></figure><p>Always 总是拉取镜像</p><p>IfNotPresent 本地有则使用本地镜像,不拉取</p><p>Never 只使用本地镜像，从不拉取，即使本地没有</p><p>如果省略imagePullPolicy 镜像tag为 :latest 策略为always ，否则 策略为 IfNotPresent</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;k8s-yaml文件&quot;&gt;&lt;a href=&quot;#k8s-yaml文件&quot; class=&quot;headerlink&quot; title=&quot;k8s yaml文件&quot;&gt;&lt;/a&gt;k8s yaml文件&lt;/h2&gt;&lt;h3 id=&quot;yaml基础&quot;&gt;&lt;a href=&quot;#yaml基础&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
</feed>

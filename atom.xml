<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dalin blog</title>
  
  
  <link href="https://tianxiafeiyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://tianxiafeiyu.github.io/"/>
  <updated>2023-02-14T02:55:29.017Z</updated>
  <id>https://tianxiafeiyu.github.io/</id>
  
  <author>
    <name>Dalin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的新冠经历</title>
    <link href="https://tianxiafeiyu.github.io/2023/02/14/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/%E6%88%91%E7%9A%84%E6%96%B0%E5%86%A0%E7%BB%8F%E5%8E%86/"/>
    <id>https://tianxiafeiyu.github.io/2023/02/14/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/%E6%88%91%E7%9A%84%E6%96%B0%E5%86%A0%E7%BB%8F%E5%8E%86/</id>
    <published>2023-02-14T02:55:29.017Z</published>
    <updated>2023-02-14T02:55:29.017Z</updated>
    
    <content type="html"><![CDATA[<p>从彻底放开两周以后，身边的同事陆陆续续都有了症状，工位上的人一个个消失。。。</p><p>12.21 日，早上起来我便感觉有一点点不舒服，头有点晕，嗓子也有点不舒服，不过症状很小，我还安慰是自己吓自己，再加上认为新冠也就那样，所以不是很在意。<br>这一天正常上班，一整天下来，确实有点无力的感觉，喉咙的异物感越来越重，我便知道这次是真的来了。这天晚上很难入睡，翻来覆去睡不着。</p><p>22号早上醒来，我便感觉头昏脑胀，喉咙已经哑了，我赶紧跟领导请了假，拿出温度计量体温，不到37度，还没有开始烧。不过我整个人已经像火炉一样了，冒着热气。这一天整个人是无精打采的，<br>很明显的感冒症状，但是有感觉哪里不同。</p><p>23号开始高烧了，一度烧到39度多，一整夜没睡，躺床上仿佛过了一个世纪，但是一看表，才凌晨两点钟，夜还长着，一夜无眠。临近早上，才昏昏沉沉睡过去，醒来时已经快11点了。<br>这期间身体发烧，但是身体又发冷，又热又冷，冰火两重天。喉咙倒是没有进一步恶化，不是熟悉的扁桃体炎。</p><p>周末这两天，我几乎都是躺在床上，发烧还没退，身体冻得直哆嗦。不过，烧页渐渐的退了下来，趋于平缓，我开始洗热水澡。</p><p>26号周一，烧退的差不多了，开始远程上班，但是整个人都没有精神，工作不下去。</p><p>27号依然如此，咳嗽还一直再，有浓痰，身体完全虚了，多运动几下就喘得不行，也许是我呆久了吧。</p><p>今天28号，已经过去一周了，现在烧已经完全退了下来，我倒是不再担心复烧了，只是还是很没有精神，感觉哪里出了问题。</p><p>这个新冠没有想的那么简单，确实有一定的严重性，不同于普通的感冒发烧。很难想象，之前刚爆发时，是怎么过来的。虽然我全程没有吃药，全靠身体免疫力撑了过来，但是感觉已经元气大伤，不知道要过好久才能恢复呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从彻底放开两周以后，身边的同事陆陆续续都有了症状，工位上的人一个个消失。。。&lt;/p&gt;
&lt;p&gt;12.21 日，早上起来我便感觉有一点点不舒服，头有点晕，嗓子也有点不舒服，不过症状很小，我还安慰是自己吓自己，再加上认为新冠也就那样，所以不是很在意。&lt;br&gt;这一天正常上班，一整天</summary>
      
    
    
    
    <category term="生活点滴" scheme="https://tianxiafeiyu.github.io/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>cpu加压脚本</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/30/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/30/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/</id>
    <published>2022-12-30T23:10:53.000Z</published>
    <updated>2022-12-30T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      this scripts <span class="keyword">for</span> cpu usage testing</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      eg.  cpu_test.sh start  50 <span class="comment">#start testing use 50% cpu</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      eg.  cpu_test.sh stop  <span class="comment">#stop testing</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################################################</span></span></span><br><span class="line">op=$1</span><br><span class="line">num=$2</span><br><span class="line"></span><br><span class="line">mkcsp()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        touch ./killcpu.c</span><br><span class="line">        echo &#x27;int main()&#123;while(1);return 0;&#125;&#x27; &gt; killcpu.c</span><br><span class="line">        gcc -o out killcpu.c</span><br><span class="line">        chmod +x ./out</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">cpu_num=$(cat /proc/cpuinfo | grep &quot;physical id&quot; | wc -l)</span><br><span class="line"></span><br><span class="line">for i in `seq 1 $(expr $num \* $cpu_num / 100)`</span><br><span class="line">        do</span><br><span class="line">            ./out &amp;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">for i in $( ps -ef | grep &#x27;./out&#x27;| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">        do</span><br><span class="line">                kill -9 $i</span><br><span class="line">        done</span><br><span class="line">rm -rf killcpu.c out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">if [ $op == &quot;start&quot; ]</span><br><span class="line">then</span><br><span class="line">        mkcsp</span><br><span class="line">fi</span><br><span class="line">        $op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="cpu加压脚本" scheme="https://tianxiafeiyu.github.io/tags/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Chrome年度热门扩展程序</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Chrome%E5%B9%B4%E5%BA%A6%E7%83%AD%E9%97%A8%20%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Chrome%E5%B9%B4%E5%BA%A6%E7%83%AD%E9%97%A8%20%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-12-16T15:18:00.000Z</published>
    <updated>2023-02-14T02:55:29.009Z</updated>
    
    <content type="html"><![CDATA[<p>Google 官方统计的年度榜单，多看涨姿势~~</p><p>2022：<a href="https://www.oschina.net/news/221758/chrome-extension-favorite-2022">https://www.oschina.net/news/221758/chrome-extension-favorite-2022</a></p><p>2021：<a href="https://www.oschina.net/news/172732/chrome-extension-favorite-2021">https://www.oschina.net/news/172732/chrome-extension-favorite-2021</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Google 官方统计的年度榜单，多看涨姿势~~&lt;/p&gt;
&lt;p&gt;2022：&lt;a href=&quot;https://www.oschina.net/news/221758/chrome-extension-favorite-2022&quot;&gt;https://www.oschina.net</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title>Prometheus监控kubernetes方案及实现</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-16T00:43:25.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promtheus监控kubernetes"><a href="#promtheus监控kubernetes" class="headerlink" title="promtheus监控kubernetes"></a>promtheus监控kubernetes</h1><h2 id="Kubernetes监控策略"><a href="#Kubernetes监控策略" class="headerlink" title="Kubernetes监控策略"></a>Kubernetes监控策略</h2><p>Kubernetes作为开源的容器编排工具，为用户提供了一个可以统一调度，统一管理的云操作系统。其解决如用户应用程序如何运行的问题。而一旦在生产环境中大量基于Kubernetes部署和管理应用程序后，作为系统管理员，还需要充分了解应用程序以及Kubernetes集群服务运行质量如何，通过对应用以及集群运行状态数据的收集和分析，持续优化和改进，从而提供一个安全可靠的生产运行环境。这一小节中我们将讨论当使用Kubernetes时的监控策略该如何设计。  </p><p>从物理结构上讲Kubernetes主要用于整合和管理底层的基础设施资源，对外提供应用容器的自动化部署和管理能力，这些基础设施可能是物理机、虚拟机、云主机等等。因此，基础资源的使用直接影响当前集群的容量和应用的状态。在这部分，我们需要关注集群中各个节点的主机负载，CPU使用率、内存使用率、存储空间以及网络吞吐等监控指标。  </p><p>从自身架构上讲，kube-apiserver是Kubernetes提供所有服务的入口，无论是外部的客户端还是集群内部的组件都直接与kube-apiserver进行通讯。因此，kube-apiserver的并发和吞吐量直接决定了集群性能的好坏。其次，对于外部用户而言，Kubernetes是否能够快速的完成pod的调度以及启动，是影响其使用体验的关键因素。而这个过程主要由kube-scheduler负责完成调度工作，而kubelet完成pod的创建和启动工作。因此在Kubernetes集群本身我们需要评价其自身的服务质量，主要关注在Kubernetes的API响应时间，以及Pod的启动时间等指标上。  </p><p>Kubernetes的最终目标还是需要为业务服务，因此我们还需要能够监控应用容器的资源使用情况。对于内置了对Prometheus支持的应用程序，也要支持从这些应用程序中采集内部的监控指标。最后，结合黑盒监控模式，对集群中部署的服务进行探测，从而当应用发生故障后，能够快速处理和恢复。  </p><p>在Kubernetes集群上也需要监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，这样可以反映出使用这些资源部署的应用状态。但通过查看api-server或者cAdvisor的指标，并没有具体的各种资源对象的状态指标，对于Prometheus来说，当然需要引入新的exporter来暴露这些指标，Kubernetes提供了名为kube-state-metrics的项目（项目地址：<a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a> ）。</p><p>综上所述，我们需要综合使用白盒监控和黑盒监控模式，建立从基础设施，Kubernetes核心组件，应用容器等全面的监控体系。  </p><p>在白盒监控层面我们需要关注：</p><ul><li>基础设施层（Node）：为整个集群和应用提供运行时资源，需要通过各节点的kubelet获取节点的基本状态，同时通过在节点上部署Node Exporter获取节点的资源使用情况；</li><li>容器基础设施（Container）：为应用提供运行时环境，Kubelet内置了对cAdvisor的支持，用户可以直接通过Kubelet组件获取给节点上容器相关监控指标；</li><li>用户应用（Pod）：Pod中会包含一组容器，它们一起工作，并且对外提供一个（或者一组）功能。如果用户部署的应用程序内置了对Prometheus的支持，那么我们还应该采集这些Pod暴露的监控指标；</li><li>Kubernetes组件：获取并监控Kubernetes核心组件的运行状态，确保平台自身的稳定运行。  </li><li>Kubernetes资源对象：监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，反映出使用这些资源部署的应用状态</li></ul><p>而在黑盒监控层面，则主要需要关注以下：</p><ul><li>内部服务负载均衡（Service）：在集群内，通过Service在集群暴露应用功能，集群内应用和应用之间访问时提供内部的负载均衡。通过Balckbox Exporter探测Service的可用性，确保当Service不可用时能够快速得到告警通知；</li><li>外部访问入口（Ingress）：通过Ingress提供集群外的访问入口，从而可以使外部客户端能够访问到部署在Kubernetes集群内的服务。因此也需要通过Blackbox Exporter对Ingress的可用性进行探测，确保外部用户能够正常访问集群内的功能；</li></ul><p>下表中，梳理了监控Kubernetes集群监控的各个维度以及策略：</p><table><thead><tr><th>目标</th><th>描述</th><th>服务发现方式</th><th>监控方法</th><th>数据源</th><th>集群外监控</th></tr></thead><tbody><tr><td>api-server</td><td>获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标</td><td>endpoints</td><td>白盒监控</td><td>api server</td><td>✓</td></tr><tr><td>kube-schedule</td><td>kube-schedule的metrics接口 （Scheduler服务端口默认为10251）</td><td>-</td><td>白盒监控</td><td>kube-schedule</td><td>✓</td></tr><tr><td>control-manager</td><td>control-manager的metrics接口（ControllerManager服务端口默认为10252）</td><td>-</td><td>白盒监控</td><td>control-manager</td><td>✓</td></tr><tr><td>kubelet</td><td>从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标</td><td>node</td><td>白盒监控</td><td>kubelet</td><td>✓</td></tr><tr><td>kube-proxy</td><td>kube-proxy的metrics接口（ControllerManager服务端口默认为10252）</td><td>-</td><td>白盒监控</td><td>kube-proxy</td><td>✓</td></tr><tr><td>kube-dns</td><td>从集群各节点获取kube-dns的基本运行状态的监控指标</td><td>-</td><td>白盒监控</td><td>kube-dns</td><td>✓</td></tr><tr><td>cAdvisor</td><td>从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标</td><td>node</td><td>白盒监控</td><td>kubelet</td><td>✓</td></tr><tr><td>node</td><td>从部署到各个节点的Node Exporter中采集主机资源相关的运行资源</td><td>node</td><td>白盒监控</td><td>node exporter</td><td>✓</td></tr><tr><td>pod</td><td>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标</td><td>pod</td><td>白盒监控</td><td>custom pod</td><td>✓</td></tr><tr><td>资源对象</td><td>监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，反映出使用这些资源部署的应用状态</td><td>endpoints</td><td>白盒监控</td><td>kube-state-metrics</td><td>✓</td></tr><tr><td>service</td><td>获取集群中Service的访问地址，并通过Blackbox  Exporter获取网络探测指标</td><td>service</td><td>黑盒监控</td><td>blackbox exporter</td><td>✓</td></tr><tr><td>ingress</td><td>获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标</td><td>ingress</td><td>黑盒监控</td><td>blackbox exporter</td><td>✓</td></tr></tbody></table><h2 id="kubernetes监控实现"><a href="#kubernetes监控实现" class="headerlink" title="kubernetes监控实现"></a>kubernetes监控实现</h2><p>使用prometheus监控kubernetes，基本上有两个场景： </p><ul><li>prometheus部署在k8s集群内部；</li><li>prometheus部署在k8s集群外部。</li></ul><p>两种场景大同小异，原理上都是基于kubernetes服务发现，promtheus自身已经实现了基于kubernetes的服务发现。但目前prometheus部署在k8s集群外部对于service和ingress的监控暂无合适方案</p><h3 id="prometheus部署在k8s集群外部监控实现"><a href="#prometheus部署在k8s集群外部监控实现" class="headerlink" title="prometheus部署在k8s集群外部监控实现"></a>prometheus部署在k8s集群外部监控实现</h3><h4 id="Kubernetes访问授权"><a href="#Kubernetes访问授权" class="headerlink" title="Kubernetes访问授权"></a>Kubernetes访问授权</h4><p>为了能够让Prometheus能够访问收到认证保护的Kubernetes API，我们首先需要做的是，对Prometheus进行访问授权。在Kubernetes中主要使用基于角色的访问控制模型(Role-Based Access Control)，用于管理Kubernetes下资源访问权限。首先我们需要在Kubernetes下定义角色（ClusterRole），并且为该角色赋予响应的访问权限。同时创建Prometheus所使用的账号（ServiceAccount），最后则是将该账号与角色进行绑定（ClusterRoleBinding）。这些所有的操作在Kubernetes同样被视为是一系列的资源，可以通过YAML文件进行描述并创建，这里创建prometheus-rbac-setup.yml文件，并写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - services</span><br><span class="line">  - services/proxy</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  - pods/proxy</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br></pre></td></tr></table></figure><p>通过kubectl命令创建RBAC对应的各个资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f prometheus-rbac-setup.yml</span><br><span class="line">clusterrole &quot;prometheus&quot; created</span><br><span class="line">serviceaccount &quot;prometheus&quot; created</span><br><span class="line">clusterrolebinding &quot;prometheus&quot; created</span><br></pre></td></tr></table></figure><p>外部的prometheus需要获取Bearer Token来访问kubernetes api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ SECRET=$(kubectl get serviceaccount prometheus -ojsonpath=&#x27;&#123;.secrets[0].name&#125;&#x27;)</span><br><span class="line">$ kubectl get secret $&#123;SECRET&#125; -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 -d &gt; /tmp/prometheus-sa-token</span><br></pre></td></tr></table></figure><h4 id="从kube-apiserver获取集群运行监控指标"><a href="#从kube-apiserver获取集群运行监控指标" class="headerlink" title="从kube-apiserver获取集群运行监控指标"></a>从kube-apiserver获取集群运行监控指标</h4><p>kube-apiserver扮演了整个Kubernetes集群管理的入口的角色，负责对外暴露Kubernetes API。kube-apiserver组件一般是独立部署在集群外的，为了能够让部署在集群内的应用（kubernetes插件或者用户应用）能够与kube-apiserver交互，Kubernetes会默认在命名空间下创建一个名为kubernetes的服务，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc kubernetes -o wide</span><br><span class="line">NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE       SELECTOR</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          166d      &lt;none&gt;</span><br></pre></td></tr></table></figure><p>而该kubernetes服务代理的后端实际地址通过endpoints进行维护，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get endpoints kubernetes</span><br><span class="line">NAME         ENDPOINTS        AGE</span><br><span class="line">kubernetes   192.168.1.4:6443   166d</span><br></pre></td></tr></table></figure><p>通过这种方式集群内的应用或者系统主机就可以通过集群内部的DNS域名kubernetes.default.svc访问到部署外部的kube-apiserver实例。 </p><p>因此，如果我们想要监控kube-apiserver相关的指标，只需要通过endpoints资源找到kubernetes对应的所有后端地址即可。  </p><p>如下所示，创建监控任务kubernetes-apiservers，这里指定了服务发现模式为endpoints。Promtheus会查找当前集群中所有的endpoints配置，并通过relabel进行判断是否为apiserver对应的访问地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-apiservers&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: default;kubernetes;https</span><br></pre></td></tr></table></figure><p>在relabel_configs配置中用于判断当前endpoints是否为kube-apiserver对用的地址。重新加载配置文件，重建Promthues实例，得到以下结果。</p><h4 id="监控kube-schedule、kube-control-manager、kube-proxy"><a href="#监控kube-schedule、kube-control-manager、kube-proxy" class="headerlink" title="监控kube-schedule、kube-control-manager、kube-proxy"></a>监控kube-schedule、kube-control-manager、kube-proxy</h4><p>在prometheus里手动添加kubernetes-schedule、kubernetes-control-manager组件的连接配置，非证书连接！以下组件的配置，还不需要使用证书连接，直接ip+port就可以，默认路径就是&#x2F;metrics<br>确保以下四个组件的metrcis数据可以通过下面方式正常获取。  </p><p>schedule的metrics接口 （Scheduler服务端口默认为10251）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-schedule&#x27;          #任务名</span><br><span class="line">  scrape_interval: 5s                   #本任务的抓取间隔，覆盖全局配置</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10251&#x27;]</span><br></pre></td></tr></table></figure><p>control-manager的metrics接口（ControllerManager服务端口默认为10252）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-control-manager&#x27;</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10252&#x27;]</span><br></pre></td></tr></table></figure><p>kube-proxy的metrics接口(kube-proxy服务端口默认为10249）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-proxy&#x27;</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10249&#x27;, &#x27;192.168.1.5：10249&#x27;, &#x27;192.168.1.6:10249&#x27; ]</span><br></pre></td></tr></table></figure><p>当然，还可用服务发现的方式监控，具体如下：<br>创建service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-scheduler-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-scheduler</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    component: kube-scheduler</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10251</span><br><span class="line">    targetPort: 10251</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-controller-manager-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-controller-manager</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    component: kube-controller-manager</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10252</span><br><span class="line">    targetPort: 10252</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-proxy-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-proxy</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kube-proxy</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10249</span><br><span class="line">    targetPort: 10249</span><br><span class="line">    nodePort: 30025</span><br><span class="line">    protocol: TCP</span><br></pre></td></tr></table></figure><p>创建监控任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kube-scheduler-prometheus-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-scheduler-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line">- job_name: &#x27;kube-controller-manager-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-controller-manager-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line">- job_name: &#x27;kube-proxy-prometheus-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-proxy-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从Kubelet获取节点运行状态"><a href="#从Kubelet获取节点运行状态" class="headerlink" title="从Kubelet获取节点运行状态"></a>从Kubelet获取节点运行状态</h4><p>Kubelet组件运行在Kubernetes集群的各个节点中，其负责维护和管理节点上Pod的运行状态。kubelet组件的正常运行直接关系到该节点是否能够正常的被Kubernetes集群正常使用。</p><p>基于Node模式，Prometheus会自动发现Kubernetes中所有Node节点的信息并作为监控的目标Target。 而这些Target的访问地址实际上就是Kubelet的访问地址，并且Kubelet实际上直接内置了对Promtheus的支持。</p><p>实际探索过程中，直接从kuberlet获取数据有报错。这里采用第二种方式：不直接通过kubelet的metrics服务采集监控数据，而通过Kubernetes的api-server提供的代理API访问各个节点中kubelet的metrics服务，如下所示：</p><p>修改prometheus.yml配置文件，并添加以下采集任务配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">    regex: (.+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics</span><br></pre></td></tr></table></figure><p>通过relabeling，将从Kubernetes获取到的默认地址__address__替换为192.168.1.4:6443。同时将__metrics_path__替换为api-server的代理地址&#x2F;api&#x2F;v1&#x2F;nodes&#x2F;${1}&#x2F;proxy&#x2F;metrics。</p><h4 id="监控kube-dns"><a href="#监控kube-dns" class="headerlink" title="监控kube-dns"></a>监控kube-dns</h4><p>kube-dns会在9153端口暴露采集指标，通过服务发现可以实现对kube-dns的监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kube-dns-discovery&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_endpoint_port_name]</span><br><span class="line">    separator: ;</span><br><span class="line">    regex: metrics</span><br><span class="line">    replacement: $1</span><br><span class="line">    action: keep</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/$&#123;2&#125;:$&#123;3&#125;/proxy/metrics</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: kube-system;kube-dns</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br></pre></td></tr></table></figure><h4 id="从cadvisor获取容器的监控数据"><a href="#从cadvisor获取容器的监控数据" class="headerlink" title="从cadvisor获取容器的监控数据"></a>从cadvisor获取容器的监控数据</h4><p>cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。Kubernetes内置对cAdvisor支持。外部的Prometheus可以通过Api Server的代理访问到cAdvisor：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">    regex: (.+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_node_label_(.+)</span><br></pre></td></tr></table></figure><h4 id="使用NodeExporter监控集群资源使用情况"><a href="#使用NodeExporter监控集群资源使用情况" class="headerlink" title="使用NodeExporter监控集群资源使用情况"></a>使用NodeExporter监控集群资源使用情况</h4><p>为了能够采集集群中各个节点的资源使用情况，我们需要在各节点中部署一个Node Exporter实例。在本章的“部署Prometheus”小节，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。而与Prometheus的部署不同的是，对于Node Exporter而言每个节点只需要运行一个唯一的实例，此时，就需要使用Kubernetes的另外一种控制器Daemonset。顾名思义，Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。</p><p>创建node-exporter-daemonset.yml文件，并写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">        prometheus.io/port: &#x27;9100&#x27;</span><br><span class="line">        prometheus.io/path: &#x27;metrics&#x27;</span><br><span class="line">      labels:</span><br><span class="line">        app: node-exporter</span><br><span class="line">      name: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-role.kubernetes.io/master&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - image: prom/node-exporter</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: node-exporter</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">          hostPort: 9100</span><br><span class="line">          name: scrape</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      hostPID: true</span><br></pre></td></tr></table></figure><p>由于Node Exporter需要能够访问宿主机，因此这里指定了hostNetwork和hostPID，让Pod实例能够以主机网络以及系统进程的形式运行。同时YAML文件中也创建了NodeExporter相应的Service。这样通过Service就可以访问到对应的NodeExporter实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f node-exporter-daemonset.yml</span><br><span class="line">service &quot;node-exporter&quot; created</span><br><span class="line">daemonset &quot;node-exporter&quot; created</span><br></pre></td></tr></table></figure><p>目前为止，通过Daemonset的形式将Node Exporter部署到了集群中的各个节点中。接下来，我们只需要通过Prometheus的pod服务发现模式，找到当前集群中部署的Node Exporter实例即可。 需要注意的是，由于Kubernetes中并非所有的Pod都提供了对Prometheus的支持，有些可能只是一些简单的用户应用，为了区分哪些Pod实例是可以供Prometheus进行采集的，这里我们为Node Exporter添加了注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/scrape: &#x27;true&#x27;</span><br></pre></td></tr></table></figure><p>由于Kubernetes中Pod可能会包含多个容器，还需要用户通过注解指定用户提供监控指标的采集端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/port: &#x27;9100&#x27;</span><br></pre></td></tr></table></figure><p>而有些情况下，Pod中的容器可能并没有使用默认的&#x2F;metrics作为监控采集路径，因此还需要支持用户指定采集路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/path: &#x27;metrics&#x27;</span><br></pre></td></tr></table></figure><p>为Prometheus创建监控采集任务kubernetes-nodes，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">   kubernetes_sd_configs:</span><br><span class="line">   - role: pod</span><br><span class="line">     api_server: https://192.168.1.4:6443</span><br><span class="line">     bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">     tls_config:</span><br><span class="line">       insecure_skip_verify: true</span><br><span class="line">   relabel_configs:</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">     action: keep</span><br><span class="line">     regex: true</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: __metrics_path__</span><br><span class="line">     regex: (.+)</span><br><span class="line">   - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">     action: replace</span><br><span class="line">     regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">     replacement: $1:$2</span><br><span class="line">     target_label: __address__</span><br><span class="line">   - action: labelmap</span><br><span class="line">     regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">   - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: kubernetes_namespace</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: kubernetes_pod_name</span><br><span class="line">   - source_labels:  [&quot;__mkubernetes_pod_node_name&quot;]</span><br><span class="line">     target_label: &quot;node_name&quot;</span><br></pre></td></tr></table></figure><h4 id="使用kube-state-metrics监控资源对象"><a href="#使用kube-state-metrics监控资源对象" class="headerlink" title="使用kube-state-metrics监控资源对象"></a>使用kube-state-metrics监控资源对象</h4><p>通过kube-state-metrics可以获取以下指标</p><ul><li>CronJob Metrics</li><li>DaemonSet Metrics</li><li>Deployment Metrics</li><li>Job Metrics</li><li>LimitRange Metrics</li><li>Node Metrics</li><li>PersistentVolume Metrics</li><li>PersistentVolumeClaim Metrics</li><li>Pod Metrics</li><li>ReplicaSet Metrics</li><li>ReplicationController Metrics</li><li>ResourceQuota Metrics</li><li>Service Metrics</li><li>StatefulSet Metrics</li><li>Namespace Metrics</li><li>Horizontal Pod Autoscaler Metrics</li><li>Endpoint Metrics</li></ul><h5 id="Kubernetes版本支持"><a href="#Kubernetes版本支持" class="headerlink" title="Kubernetes版本支持"></a>Kubernetes版本支持</h5><p>kube-state-metrics用于client-go与Kubernetes集群通信。支持的Kubernetes集群版本由决定client-go。可以在此处找到client-go和Kubernetes集群的兼容性矩阵 。</p><table><thead><tr><th>kube-state-metrics</th><th><strong>Kubernetes 1.12</strong></th><th><strong>Kubernetes 1.13</strong></th><th><strong>Kubernetes 1.14</strong></th><th><strong>Kubernetes 1.15</strong></th><th><strong>Kubernetes 1.16</strong></th><th><strong>Kubernetes 1.17</strong></th></tr></thead><tbody><tr><td><strong>v1.5.0</strong></td><td>✓</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.6.0</strong></td><td>✓</td><td>✓</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.7.2</strong></td><td>✓</td><td>✓</td><td>✓</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.8.0</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>-</td><td>-</td></tr><tr><td><strong>v1.9.4</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>-</td></tr><tr><td><strong>master</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr></tbody></table><h5 id="部署kube-state-metrics"><a href="#部署kube-state-metrics" class="headerlink" title="部署kube-state-metrics"></a>部署kube-state-metrics</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - configmaps</span><br><span class="line">  - secrets</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - pods</span><br><span class="line">  - pods/proxy</span><br><span class="line">  - services/proxy</span><br><span class="line">  - services</span><br><span class="line">  - resourcequotas</span><br><span class="line">  - replicationcontrollers</span><br><span class="line">  - limitranges</span><br><span class="line">  - persistentvolumeclaims</span><br><span class="line">  - persistentvolumes</span><br><span class="line">  - namespaces</span><br><span class="line">  - endpoints</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">  - get</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - daemonsets</span><br><span class="line">  - deployments</span><br><span class="line">  - replicasets</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - apps</span><br><span class="line">  resources:</span><br><span class="line">  - statefulsets</span><br><span class="line">  - daemonsets</span><br><span class="line">  - deployments</span><br><span class="line">  - replicasets</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - batch</span><br><span class="line">  resources:</span><br><span class="line">  - cronjobs</span><br><span class="line">  - jobs</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - autoscaling</span><br><span class="line">  resources:</span><br><span class="line">  - horizontalpodautoscalers</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - authentication.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - tokenreviews</span><br><span class="line">  verbs:</span><br><span class="line">  - create</span><br><span class="line">- apiGroups:</span><br><span class="line">  - authorization.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - subjectaccessreviews</span><br><span class="line">  verbs:</span><br><span class="line">  - create</span><br><span class="line">- apiGroups:</span><br><span class="line">  - policy</span><br><span class="line">  resources:</span><br><span class="line">  - poddisruptionbudgets</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - certificates.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - certificatesigningrequests</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - storage.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - storageclasses</span><br><span class="line">  - volumeattachments</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - admissionregistration.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - mutatingwebhookconfigurations</span><br><span class="line">  - validatingwebhookconfigurations</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - networking.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - networkpolicies</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">        app.kubernetes.io/version: v1.9.4</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: quay.io/coreos/kube-state-metrics:v1.9.4</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthz</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        name: kube-state-metrics</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">          name: http-metrics</span><br><span class="line">        - containerPort: 8081</span><br><span class="line">          name: telemetry</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8081</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">      nodeSelector:</span><br><span class="line">        kubernetes.io/os: linux</span><br><span class="line">      serviceAccountName: kube-state-metrics</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: http-metrics</span><br><span class="line">  - name: telemetry</span><br><span class="line">    port: 8081</span><br><span class="line">    targetPort: telemetry</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="prometheus创建kube-state-netrics监控任务"><a href="#prometheus创建kube-state-netrics监控任务" class="headerlink" title="prometheus创建kube-state-netrics监控任务"></a>prometheus创建kube-state-netrics监控任务</h5><p>通过kubernetes服务发现，监控kube-state-metrics</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kube-state-metrics&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [ __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: kube-state-metrics;http-metrics</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/http:$&#123;2&#125;:$&#123;3&#125;/proxy/metrics</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h4 id="内置对prometheus支持的应用监控"><a href="#内置对prometheus支持的应用监控" class="headerlink" title="内置对prometheus支持的应用监控"></a>内置对prometheus支持的应用监控</h4><p>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标。在这需要对应用添加以annotations：</p><ul><li>prometheus.io&#x2F;scrape: ‘true’</li><li>prometheus.io&#x2F;port: ‘your_port’</li><li>prometheus.io&#x2F;path: ‘your_metrics_path’</li></ul><p>通过这些标签可以筛选掉无用的应用。</p><p>添加promtheus任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kube-service&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number, __meta_kubernetes_service_annotation_prometheus_io_path]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/http:$&#123;2&#125;:$&#123;3&#125;/proxy/$&#123;4&#125;</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h4 id="对Ingress和Service进行网络探测"><a href="#对Ingress和Service进行网络探测" class="headerlink" title="对Ingress和Service进行网络探测"></a>对Ingress和Service进行网络探测</h4><p>为了能够对Ingress和Service进行探测，我们需要在集群部署Blackbox Exporter实例。 如下所示，创建blackbox-exporter.yaml用于描述部署相关的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  name: blackbox-exporter</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: blackbox</span><br><span class="line">    port: 9115</span><br><span class="line">    protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  name: blackbox-exporter</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: blackbox-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: blackbox-exporter</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: prom/blackbox-exporter</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: blackbox-exporter</span><br></pre></td></tr></table></figure><p>为了能够让Prometheus能够自动的对Service进行探测，我们需要通过服务发现自动找到所有的Service信息。 如下所示，在Prometheus的配置文件中添加名为kubernetes-services的监控采集任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-services&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  params:</span><br><span class="line">    module: [http_2xx]</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: service</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    target_label: __param_target</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - target_label: __metrics_path__</span><br><span class="line">    replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br><span class="line">  - source_labels: [__param_target]</span><br><span class="line">    target_label: instance</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><p>在该任务配置中，通过指定kubernetes_sd_config的role为service指定服务发现模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubernetes_sd_configs:</span><br><span class="line">    - role: service</span><br><span class="line">      api_server: https://192.168.1.4:6443</span><br><span class="line">      tls_config:</span><br><span class="line">        insecure_skip_verify: true</span><br><span class="line">      bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br></pre></td></tr></table></figure><p>为了区分集群中需要进行探测的Service实例，我们通过标签‘prometheus.io&#x2F;probe: true’进行判断，从而过滤出需要探测的所有Service实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">  action: keep</span><br><span class="line">  regex: true</span><br></pre></td></tr></table></figure><p>为了能够在外部访问k8s集群内部的blackbox，这里使用的Kubernetes proxy api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- target_label: __address__</span><br><span class="line">  replacement: 192.168.1.4:6443</span><br><span class="line">- target_label: __metrics_path__</span><br><span class="line">  replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br></pre></td></tr></table></figure><p>对于Ingress而言，也是一个相对类似的过程，这里给出对Ingress探测的Promthues任务配置作为参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-ingresses&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  params:</span><br><span class="line">    module: [http_2xx]</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: ingress</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]</span><br><span class="line">    regex: (.+);(.+);(.+)</span><br><span class="line">    replacement: $&#123;1&#125;://$&#123;2&#125;$&#123;3&#125;</span><br><span class="line">    target_label: __param_target</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - target_label: __metrics_path__</span><br><span class="line">    replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br><span class="line">  - source_labels: [__param_target]</span><br><span class="line">    target_label: instance</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_ingress_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_name]</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h3 id="prometheus部署在k8s集群内部监控实现"><a href="#prometheus部署在k8s集群内部监控实现" class="headerlink" title="prometheus部署在k8s集群内部监控实现"></a>prometheus部署在k8s集群内部监控实现</h3><p>prometheus部署在k8s集群内部监控k8s和部署在外部监控的原理是一样的，唯一的区别：</p><ul><li>集群内部，可以通过集群的DNS访问监控对象，不需要通过api server代理。</li><li>服务发现时，不需要制定api server 的地址。</li></ul><p>具体过程如下：</p><p>1.授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - pods</span><br><span class="line">  - proxy</span><br><span class="line">  - pods/proxy</span><br><span class="line">  - services</span><br><span class="line">  - services/proxy</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br></pre></td></tr></table></figure><p>2.将prometheus的配置放在configmap中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  prometheus.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      scrape_interval:     15s </span><br><span class="line">      evaluation_interval: 15s</span><br><span class="line">    scrape_configs:</span><br><span class="line">    - job_name: &#x27;kubernetes-apiservers&#x27;</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: default;kubernetes;https</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">    - job_name: &#x27;kube-scheduler&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-scheduler-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kube-controller-manager&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-controller-manager-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: node</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        regex: (.+)</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        target_label: &quot;kubernetes_node_name&quot;</span><br><span class="line">    - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: node</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        regex: (.+)</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">    - job_name: &#x27;kube-proxy&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-proxy-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kube-dns-discovery&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: kube-system;kube-dns</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__meta_kubernetes_endpoint_port_name]</span><br><span class="line">        separator: ;</span><br><span class="line">        regex: metrics</span><br><span class="line">        replacement: $1</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: instance</span><br><span class="line">    - job_name: &#x27;kube-state-metrics&#x27;        </span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">        regex: kube-state-metrics;http-metrics</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __scheme__</span><br><span class="line">        regex: (https?)</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        regex: (.+)</span><br><span class="line">      - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __address__</span><br><span class="line">        regex: (.+)(?::\d+);(\d+)</span><br><span class="line">        replacement: $1:$2</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_name        </span><br><span class="line">    - job_name: &#x27;kubernetes-pods&#x27;</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: pod</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        regex: (.+)</span><br><span class="line">      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">        action: replace</span><br><span class="line">        regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">        replacement: $1:$2</span><br><span class="line">        target_label: __address__</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_pod_name   </span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_node_name]</span><br><span class="line">        target_label: kubernetes_node_name   </span><br><span class="line">    - job_name: &#x27;kubernetes-services&#x27;</span><br><span class="line">      metrics_path: /probe</span><br><span class="line">      params:</span><br><span class="line">        module: [http_2xx]</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: service</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: blackbox-exporter.default.svc.cluster.local:9115</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">        target_label: kubernetes_name</span><br><span class="line">    - job_name: &#x27;kubernetes-ingresses&#x27;</span><br><span class="line">      metrics_path: /probe</span><br><span class="line">      params:</span><br><span class="line">        module: [http_2xx]</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: ingress</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]</span><br><span class="line">        regex: (.+);(.+);(.+)</span><br><span class="line">        replacement: $&#123;1&#125;://$&#123;2&#125;$&#123;3&#125;</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: blackbox-exporter.default.svc.cluster.local:9115</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_ingress_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_name]</span><br><span class="line">        target_label: kubernetes_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-config</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.创建prometheus service和deployment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus</span><br><span class="line">  name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: prometheus</span><br><span class="line">      serviceAccount: prometheus</span><br><span class="line">      containers:</span><br><span class="line">      - name: prometheus</span><br><span class="line">        image: prom/prometheus:v2.2.1</span><br><span class="line">        command:</span><br><span class="line">        - &quot;/bin/prometheus&quot;</span><br><span class="line">        args:</span><br><span class="line">        - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">        - &quot;--web.enable-lifecycle&quot;</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          protocol: TCP</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;/etc/prometheus&quot;</span><br><span class="line">          name: prometheus-config</span><br><span class="line">      volumes:</span><br><span class="line">      - name: prometheus-config</span><br><span class="line">        configMap:</span><br><span class="line">          name: prometheus-config</span><br><span class="line">        </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: &quot;Service&quot;</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: prometheus</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 9090</span><br><span class="line">    targetPort: 9090</span><br><span class="line">    nodePort: 30090</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus</span><br><span class="line">  type: NodePort</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里创建的prometheus service是NodePort类型，可以直接通过ip:30090访问prometheus。</p><h2 id="kubernetes监控方案"><a href="#kubernetes监控方案" class="headerlink" title="kubernetes监控方案"></a>kubernetes监控方案</h2><p>上面讲述了如何在集群外部和集群内部监控k8s 。对于单集群来说，这两种方案已经能够满足我们的需求。那对于多集群监控呢。下面列出两种方案：</p><table><thead><tr><th>方案</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>采用外部部署prometheus的方式，写多套配置</td><td>无需对k8s造成额外的资源占用</td><td>增加了api server的负载</td></tr><tr><td>利用联邦集群，每个k8s中部署一个prometheus，由外部prometheus汇总</td><td>api server负载小</td><td>对k8s造成额外的资源占用</td></tr></tbody></table><p>两种方案各有各自的优缺点，在部署实施过程中，可根据需求选择对应方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;promtheus监控kubernetes&quot;&gt;&lt;a href=&quot;#promtheus监控kubernetes&quot; class=&quot;headerlink&quot; title=&quot;promtheus监控kubernetes&quot;&gt;&lt;/a&gt;promtheus监控kubernetes&lt;/</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="Prometheus监控kubernetes方案及实现" scheme="https://tianxiafeiyu.github.io/tags/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E5%AD%A6%E4%B9%A0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-16T00:43:25.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做skywalking相关的项目，skywalking使用了Elasticsearch对数据指标进行存取，要理解skywalking的工程项目，就需要对 Elasticsearch 有一定的了解。</p><p>转载自 <a href="https://www.jianshu.com/p/d48c32423789">https://www.jianshu.com/p/d48c32423789</a></p><h2 id="什么是-Elasticsearch"><a href="#什么是-Elasticsearch" class="headerlink" title="什么是 Elasticsearch"></a>什么是 Elasticsearch</h2><p><a href="https://www.elastic.co/cn/elasticsearch">https://www.elastic.co/cn/elasticsearch</a></p><p>Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><p>Elasticsearch用 Java 编写，内部采用 Lucene 做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene 做了一层封装，它提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。</p><p>Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确地形容：</p><ul><li>一个分布式的实时文档存储系统，每个字段可以被索引与搜索；</li><li>一个分布式实时分析搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><p>现在，Elasticsearch已成为全文搜索领域的主流软件之一。维基百科、卫报、Stack Overflow、GitHub等都纷纷采用它来做搜索。</p><h2 id="Elasticsearch-一些概念"><a href="#Elasticsearch-一些概念" class="headerlink" title="Elasticsearch 一些概念"></a>Elasticsearch 一些概念</h2><p>【Cluster】</p><p>集群,一个ES集群由一个或多个节点(Node)组成,每个集群都有一个cluster name作为标识</p><p>【node】</p><p>节点,一个ES实例就是一个node,一个机器可以有多个实例,所以并不能说一台机器就是一个node，大多数情况下每个node运行在一个独立的环境或者虚拟机上。</p><p>【index】<br>索引，即文档的集合</p><p>【shard】</p><ol><li>分片,ES是分布式搜索引擎,每个索引有一个或多个分片,索引的数据被分配到各个分片上，相当于一桶水分N个杯子装。</li><li>分片有助于横向扩展，N个分片会尽可能平均地分配在不同的节点上。（2个节点，4个分片，则每个节点会分到2个分片。后面增加2个节点后，ES会自动感知进行分配，每个节点一个分片）</li><li>分片是独立的。</li><li>每个分片都是一个Lucene Index，所以一个分片只能存放Integer.MAX_VALUE-128&#x3D;2,147,483,519个docs。</li><li>分片中有 主分片（primary shard）和备份分片（replica shard），主分片和备份分片不会出现在同一个节点上（防止单点故障），默认情况下一个索引会创建5个分片及它们的备份（5primary 5replica&#x3D;10个分片）。如果只有一个节点，备份分片将会无法分配（unassigned）,此时集群状态为Yellow。</li><li>对于一个索引，除非重建索引，否则不能调整分片数目（主分片数目, number_of_shards）,但是可以随时调整备份分片数目（number_of_replicas）</li></ol><p>【ES集群状态】</p><ul><li>Green：所有主分片和备份分片都准备就绪（分配成功）。</li><li>Yellow：所有主分片准备就绪，存在至少一个备份分片没有准备就绪。</li><li>Red：存在至少一个主分片没有准备就绪，此时查询可能会出现数据丢失。</li></ul><p>【replica作用】</p><ul><li>容灾：primary分片丢失,replica分片就会被顶上去成为新的主分片,同时根据这个新的主分片创建新的replica，集群数据安然无恙。</li><li>提高查询性能：主分片和备份分片的数据是相同的，所有对于查询请求既可以查主分片也可以查备份分片，在合适的范围内多个replica性能会更优。</li></ul><h3 id="1-文档"><a href="#1-文档" class="headerlink" title="1. 文档"></a>1. 文档</h3><h4 id="1-1-什么是文档？"><a href="#1-1-什么是文档？" class="headerlink" title="1.1 什么是文档？"></a>1.1 什么是文档？</h4><p>对象 or 文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:         &quot;John Smith&quot;,</span><br><span class="line">    &quot;age&quot;:          42,</span><br><span class="line">    &quot;confirmed&quot;:    true,</span><br><span class="line">    &quot;join_date&quot;:    &quot;2014-06-01&quot;,</span><br><span class="line">    &quot;home&quot;: &#123;</span><br><span class="line">        &quot;lat&quot;:      51.5,</span><br><span class="line">        &quot;lon&quot;:      0.1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;accounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;facebook&quot;,</span><br><span class="line">            &quot;id&quot;:   &quot;johnsmith&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;twitter&quot;,</span><br><span class="line">            &quot;id&quot;:   &quot;johnsmith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们使用的术语 <code>对象</code> 和 <code>文档</code> 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，<code>文档</code> 有着特定的含义。它是指最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p><h4 id="1-2-文档元数据"><a href="#1-2-文档元数据" class="headerlink" title="1.2 文档元数据"></a>1.2 文档元数据</h4><p>一个文档不仅仅包含它的数据 ，也包含 元数据 —— 有关 文档的信息。<br>三个必须的元数据元素如下：</p><ul><li><p>_index<br> 文档在哪存放<br>我们可以简单理解为一个文档存储在一个索引内，索引和文档是一对多的关系。  </p><blockquote><p> 实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。 然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 索引 内。 Elasticsearch 会处理所有的细节。</p></blockquote></li><li><p>_type<br> 文档表示的对象类别<br><code>types</code> （类型）允许在索引中对数据进行逻辑分区。不同 <code>types</code> 的文档可能有不同的字段，但最好能够非常相似。一个  <code>_type</code> 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为256个字符。</p></li><li><p>_id<br>文档唯一标识<br>它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。<br>创建一个新的文档时，可以指定 <code>_id</code> ，也可以让 Elasticsearch 自动生成。</p></li></ul><p>当然，还有很多其他的元数据</p><h3 id="2-分布式文档存储"><a href="#2-分布式文档存储" class="headerlink" title="2. 分布式文档存储"></a>2. 分布式文档存储</h3><h4 id="2-1-文档的存放位置"><a href="#2-1-文档的存放位置" class="headerlink" title="2.1 文档的存放位置"></a>2.1 文档的存放位置</h4><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？</p><p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure><p><code>routing </code> : 可变值，默认是文档的 _id ，也可以设置成一个自定义的值</p><p><code>number_of_primary_shards </code> : 主分片的数量</p><p><code>shard</code> : 文档所在分片的位置，取值范围 [0, number_of_primary_shards-1]</p><p>这也解释了为什么创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p><blockquote><p>你可能觉得由于 Elasticsearch 主分片数量是固定的会使索引难以进行扩容。实际上当你需要时有很多技巧可以轻松实现扩容。</p></blockquote><p><strong>所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中</strong>。</p><h4 id="2-2-主分片和副本分片如何交互"><a href="#2-2-主分片和副本分片如何交互" class="headerlink" title="2.2 主分片和副本分片如何交互"></a>2.2 主分片和副本分片如何交互</h4><h5 id="2-2-1-分片分布规则"><a href="#2-2-1-分片分布规则" class="headerlink" title="2.2.1 分片分布规则"></a>2.2.1 分片分布规则</h5><p>假设有一个集群由三个节点组成。 它包含一个叫 blogs 的索引，有两个主分片，每个主分片有两个副本分片，相同分片的副本不会放在同一节点。类似如下图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/410BA879B6594958B1AAC8F3DF0DD8F7?method=getImage&version=8841&cstk=XTuNqpzO" alt="集群"></p><p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。负责转发的节点称为 ***协调节点(coordinating node)***。</p><h5 id="2-2-2-索引、新建和删除"><a href="#2-2-2-索引、新建和删除" class="headerlink" title="2.2.2 索引、新建和删除"></a>2.2.2 索引、新建和删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 索引文档- 存储和使文档可被搜索 (也可以作为更新功能)</span><br><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;value&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 例如</span><br><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;:  &quot;Just trying this out...&quot;,</span><br><span class="line">  &quot;date&quot;:  &quot;2014/01/01&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 新建新文档（与索引的区分就是确保生成新的文档，而不是覆盖）</span><br><span class="line">POST /website/blog/  # es自动生成_id，保证唯一</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PUT /website/blog/123/_create   # 指定 _id 为 123，若是已存在_id，则创建失败并且返回409</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"># 删除文档</span><br><span class="line">DELETE /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>注意：在 Elasticsearch 中文档是 不可改变 的，不能修改它们。如果想要更新现有的文档，需要 重建索引 或者进行替换</strong></em></p><p>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/6A476F43F8264DDBB17485EF3150A97B?method=getImage&version=7159&cstk=kixc2ey7" alt="新建、索引和删除单个文档"></p><p>以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：</p><ol><li>客户端向 <code>Node 1</code> 发送新建、索引或者删除请求。</li><li>节点使用文档的 <code>_id</code> 确定文档属于分片 0 。请求会被转发到 <code>Node 3</code>，因为分片 0 的主分片目前被分配在 <code>Node 3</code> 上。</li><li><code>Node 3</code> 在主分片上面执行请求。如果成功了，它将请求并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 的副本分片上。一旦所有的副本分片都报告成功, <code>Node 3</code> 将向协调节点报告成功，协调节点向客户端报告成功。</li></ol><p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。</p><h5 id="2-2-3-单文档查询"><a href="#2-2-3-单文档查询" class="headerlink" title="2.2.3 单文档查询"></a>2.2.3 单文档查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br><span class="line">#pretty 参数，将会调用 Elasticsearch 的 pretty-print 功能，该功能将会格式化数据，提高可读性。</span><br><span class="line"></span><br><span class="line"># 获取文档部分内容</span><br><span class="line">GET /website/blog/123?_source=title,text</span><br><span class="line"></span><br><span class="line"># 只想得到 _source 字段，不需要任何元数据</span><br><span class="line">GET /website/blog/123?_source</span><br></pre></td></tr></table></figure><p>响应体包括常见元数据元素，再加上  <code>_source</code> 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; :   &quot;website&quot;,</span><br><span class="line">  &quot;_type&quot; :    &quot;blog&quot;,</span><br><span class="line">  &quot;_id&quot; :      &quot;123&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; :    true,</span><br><span class="line">  &quot;_source&quot; :  &#123;</span><br><span class="line">      &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">      &quot;text&quot;:  &quot;Just trying this out...&quot;,</span><br><span class="line">      &quot;date&quot;:  &quot;2014/01/01&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get 获取文档，可以从主分片或者从其它任意副本分片检索文档 ，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/A249BA20D8BC434FB1329C7EE93D2093?method=getImage&version=8204&cstk=XTuNqpzO" alt="获取文档"></p><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p><ol><li><p>客户端向 <code>Node 1</code> 发送获取请求。</p></li><li><p>节点使用文档的 <code>_id</code> 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 <code>Node 2</code> 。</p></li><li><p><code>Node 2</code> 将文档返回给 <code>Node 1</code> ，然后将文档返回给客户端。</p></li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p><p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h5 id="2-2-4-局部更新文档"><a href="#2-2-4-局部更新文档" class="headerlink" title="2.2.4 局部更新文档"></a>2.2.4 局部更新文档</h5><p>update 请求最简单的一种形式是接收文档的一部分作为 doc 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 tags 和 views 到我们的博客文章，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   &quot;doc&quot; : &#123;</span><br><span class="line">      &quot;tags&quot; : [ &quot;testing&quot; ],</span><br><span class="line">      &quot;views&quot;: 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求成功，我们看到类似于 index 请求的响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;_index&quot; :   &quot;website&quot;,</span><br><span class="line">   &quot;_id&quot; :      &quot;1&quot;,</span><br><span class="line">   &quot;_type&quot; :    &quot;blog&quot;,</span><br><span class="line">   &quot;_version&quot; : 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检索文档显示了更新后的 _source 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;_index&quot;:    &quot;website&quot;,</span><br><span class="line">   &quot;_type&quot;:     &quot;blog&quot;,</span><br><span class="line">   &quot;_id&quot;:       &quot;1&quot;,</span><br><span class="line">   &quot;_version&quot;:  3,</span><br><span class="line">   &quot;found&quot;:     true,</span><br><span class="line">   &quot;_source&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:  &quot;My first blog entry&quot;,</span><br><span class="line">      &quot;text&quot;:   &quot;Starting to get the hang of this...&quot;,</span><br><span class="line">      &quot;tags&quot;: [ &quot;testing&quot; ],    #新添加</span><br><span class="line">      &quot;views&quot;:  0   #新添加</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部更新文档，<code>update</code> API 结合了先前说明的读取和写入模式：</p><p><img src="https://note.youdao.com/yws/api/personal/file/E5B6A405579E4720854EAFF23B14CC0A?method=getImage&version=7157&cstk=kixc2ey7" alt="局部更新文档"></p><p>以下是部分更新一个文档的步骤：</p><ol><li>客户端向 <code>Node 1</code> 发送更新请求。</li><li>它将请求转发到主分片所在的 <code>Node 3</code> 。</li><li>Node 3 从主分片检索文档，修改 <code>_source</code> 字段中的 <code>JSON</code> ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 <code>retry_on_conflict</code> 次后放弃。</li><li>如果 <code>Node 3</code> 成功地更新文档，它将新版本的文档并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， <code>Node 3</code> 向协调节点也返回成功，协调节点向客户端返回成功。</li></ol><p><code>update</code> API 还接受在 新建、索引和删除文档 章节中介绍的 <code>routing</code> 、 <code>replication</code> 、 <code>consistency</code> 和 <code>timeout</code> 参数。</p><blockquote><p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p></blockquote><h5 id="2-2-5-多文档操作"><a href="#2-2-5-多文档操作" class="headerlink" title="2.2.5 多文档操作"></a>2.2.5 多文档操作</h5><p>将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 <code>multi-get</code> 或者 <code>mget</code> API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p><p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个元素包含需要检索文档的元数据， 包括 <code>_index</code> 、 <code>_type</code> 和  <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查询多个文档</span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;blog&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;pageviews&quot;,</span><br><span class="line">         &quot;_id&quot; :    1,</span><br><span class="line">         &quot;_source&quot;: &quot;views&quot; #指定查询字段</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123; &quot;_id&quot; : 2 &#125;,</span><br><span class="line">      &#123; &quot;_type&quot; : &quot;pageviews&quot;, &quot;_id&quot; :   1 &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;ids&quot; : [ &quot;2&quot;, &quot;1&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个文档的检索是异步执行的，相互之间不会有影响。</p><p><img src="https://note.youdao.com/yws/api/personal/file/8D769E5874344107A60A740E11852523?method=getImage&version=7154&cstk=kixc2ey7" alt="获取多文档"></p><p>以下是使用单个 <code>mget</code> 请求取回多个文档所需的步骤顺序：</p><ol><li>客户端向 <code>Node 1</code> 发送 <code>mget</code> 请求。</li><li><code>Node 1</code> 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， <code>Node 1</code> 构建响应并将其返回给客户端。</li></ol><p>可以对 docs 数组中每个文档设置 <code>routing</code> 参数。</p><h5 id="2-2-6-多文档创建、索引、删除和更新"><a href="#2-2-6-多文档创建、索引、删除和更新" class="headerlink" title="2.2.6 多文档创建、索引、删除和更新"></a>2.2.6 多文档创建、索引、删除和更新</h5><p><code>mget</code> 可以使我们一次取回多个文档同样的方式， <code>bulk</code> API 允许在单个步骤中进行多次 <code>create</code> 、 <code>index</code> 、 <code>update</code> 或 <code>delete</code> 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p><p>bulk 与其他的请求体格式稍有不同，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个完整的 bulk 请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125; </span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;:    &quot;My first blog post&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;:    &quot;My second blog post&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;title&quot; : &quot;My updated blog post&quot;&#125; &#125; </span><br></pre></td></tr></table></figure><p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 </p><p><code>mget</code> 和 <code>bulk</code> API 的模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。</p><p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p><p><code>bulk</code> API，允许在单个批量请求中执行多个创建、索引、删除和更新请求，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/019587FBADCB4224812553F474652AB1?method=getImage&version=7158&cstk=kixc2ey7" alt="使用 bulk 修改多个文档"></p><p>bulk API 按如下步骤顺序执行：</p><ol><li>客户端向 Node 1 发送 bulk 请求。</li><li>Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li><li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li></ol><p>bulk API 还可以在整个批量请求的最顶层使用 consistency 参数，以及在每个请求中的元数据中使用 routing 参数。</p><blockquote><p> “为什么 bulk API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 mget API？”</p></blockquote><p> 在批量请求中引用的每个文档可能属于不同的主分片， 每个文档可能被分配给集群中的任何节点。这意味着批量请求 bulk 中的每个 操作 都需要被转发到正确节点上的正确分片。</p><p> 如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：</p><ol><li>将 JSON 解析为数组（包括文档数据，可以非常大）</li><li>查看每个请求以确定应该去哪个分片</li><li>为每个分片创建一个请求数组</li><li>将这些数组序列化为内部传输格式</li><li>将请求发送到每个分片</li></ol><p>这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收。</p><p>相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。 它使用换行符字符来识别和解析小的  action&#x2F;metadata 行来决定哪个分片应该处理每个请求。</p><p>这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。</p><h2 id="Elasticsearch-搜索"><a href="#Elasticsearch-搜索" class="headerlink" title="Elasticsearch 搜索"></a>Elasticsearch 搜索</h2><p> Elasticsearch 真正强大之处在于可以从无规律的数据中找出有意义的信息——从“大数据”到“大信息”。</p><p> 搜索（search） 可以做到：</p><ul><li>在类似于 gender 或者 age 这样的字段上使用结构化查询，join_date 这样的字段上使用排序，就像SQL的结构化查询一样。</li><li>全文检索，找出所有匹配关键字的文档并按照_相关性（relevance）_ 排序后返回结果。</li><li>以上二者兼而有之。</li></ul><p>关键概念：</p><ul><li>映射（Mapping）<br>描述数据在每个字段内如何存储</li><li>分析（Analysis）<br>全文是如何处理使之可以被搜索的</li><li>领域特定查询语言（Query DSL）<br>Elasticsearch 中强大灵活的查询语言</li></ul><h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><p>搜索API的最基础的形式是没有指定任何查询的空搜索，它简单地返回集群中所有索引下的所有文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure><p>返回的结果（为了界面简洁编辑过的）类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;hits&quot; : &#123;</span><br><span class="line">      &quot;total&quot; :       14,   #匹配到的文档总数</span><br><span class="line">      &quot;hits&quot; : [    #hits 数组包含所查询结果的前十个文档。</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;_index&quot;:   &quot;us&quot;,</span><br><span class="line">          &quot;_type&quot;:    &quot;tweet&quot;,</span><br><span class="line">          &quot;_id&quot;:      &quot;7&quot;,</span><br><span class="line">          &quot;_score&quot;:   1,    #衡量了文档与查询的匹配程度,默认情况下，首先返回最相关的文档结果，即返回的文档是按照 _score 降序排列的，</span><br><span class="line">          &quot;_source&quot;: &#123;</span><br><span class="line">             &quot;date&quot;:    &quot;2014-09-17&quot;,</span><br><span class="line">             &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">             &quot;tweet&quot;:   &quot;The Query DSL is really powerful and flexible&quot;,</span><br><span class="line">             &quot;user_id&quot;: 2</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... 9 RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      &quot;max_score&quot; :   1   #查询所匹配文档的 _score 的最大值</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;took&quot; :           4,    #执行整个搜索请求耗费了多少毫秒</span><br><span class="line">   &quot;_shards&quot; : &#123;    #查询中参与分片的总数和查询情况</span><br><span class="line">      &quot;failed&quot; :      0,</span><br><span class="line">      &quot;successful&quot; :  10,</span><br><span class="line">      &quot;total&quot; :       10</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;timed_out&quot; :      false   #查询是否超时，默认情况下，搜索请求不会超时，可以自定义超时时间 GET /_search?timeout=10ms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多索引、多类型搜索"><a href="#多索引、多类型搜索" class="headerlink" title="多索引、多类型搜索"></a>多索引、多类型搜索</h3><p>在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索，如下所示：</p><ul><li>&#x2F;_search<br>在所有的索引中搜索所有的类型</li><li>&#x2F;gb&#x2F;_search<br>在 gb 索引中搜索所有的类型</li><li>&#x2F;gb,us&#x2F;_search<br>在 gb 和 us 索引中搜索所有的文档</li><li>&#x2F;g*,u*&#x2F;_search<br>在任何以 g 或者 u 开头的索引中搜索所有的类型</li><li>&#x2F;gb&#x2F;user&#x2F;_search<br>在 gb 索引中搜索 user 类型</li><li>&#x2F;gb,us&#x2F;user,tweet&#x2F;_search<br>在 gb 和 us 索引中搜索 user 和 tweet 类型</li><li>&#x2F;_all&#x2F;user,tweet&#x2F;_search<br>在所有的索引中搜索 user 和 tweet 类型</li></ul><p>当然，可以在url后面加上 <code>pretty</code> 提高返回结果的可阅读性，如 <code>/gb/_search?pretty</code></p><p>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的—只是会涉及到更多的分片。</p><p>tip：搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>默认情况下<code>hits</code> 数组中只有前 10 个文档（有10个或以上的话），要在搜索中显示其余的文档，需要使用分页功能。</p><p>和 SQL 使用 <code>LIMIT</code> 关键字返回单个 <code>page</code> 结果的方法相同，Elasticsearch 接受 <code>from</code> 和 <code>size</code> 参数：</p><ul><li>size<br>显示应该返回的结果数量，默认是 10</li><li>from<br>显示应该跳过的初始结果数量，默认是 0</li></ul><p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?size=5   #第1页</span><br><span class="line">GET /_search?size=5&amp;from=5    #第2页</span><br><span class="line">GET /_search?size=5&amp;from=10   #第3页</span><br></pre></td></tr></table></figure><h3 id="轻量搜索"><a href="#轻量搜索" class="headerlink" title="轻量搜索"></a>轻量搜索</h3><p>两种形式的搜索 API：</p><ol><li><p>“轻量的” 查询字符串 版本<br>使用 Get 请求，参数通过url传递</p></li><li><p>请求体 版本<br>使用 Post 请求，使用 JSON 格式和更丰富的查询表达式作为搜索语言</p></li></ol><p>现介绍轻量搜索</p><p>查询字符串搜索非常适用于通过命令行做即席查询（用户自定义查询条件）。例如，查询在 <code>tweet</code> 类型中 <code>tweet</code> 字段包含 <code>elasticsearch</code> 单词的所有文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure><p>查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档，实际的地址是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary   #在url编码中，%2B为“+”，%3A为“:”</span><br></pre></td></tr></table></figure><p>+ 前缀表示必须与查询条件匹配。类似地， - 前缀表示一定不与查询条件匹配。没有 + 或者 - 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p><h4 id="all-字段"><a href="#all-字段" class="headerlink" title="_all 字段"></a><code>_all</code> 字段</h4><p>查询字段值中存在mary的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=mary</span><br></pre></td></tr></table></figure><p>其实，当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 <code>_all</code> 字段进行索引。相当于增加了一个名叫 <code>_all</code> 的额外字段，所以如果不指定字段名，将会匹配 <code>_all</code>字段，也即匹配所有字段。</p><p>例如，当索引这个文档时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tweet&quot;:    &quot;However did I manage before Elasticsearch?&quot;,</span><br><span class="line">    &quot;date&quot;:     &quot;2014-09-14&quot;,</span><br><span class="line">    &quot;name&quot;:     &quot;Mary Jones&quot;,</span><br><span class="line">    &quot;user_id&quot;:  1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就好似增加了一个名叫 _all 的额外字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;_all&quot;: &quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;</span><br></pre></td></tr></table></figure><p>当然，也可以设置 <code>_all</code> 字段无效。</p><h4 id="更复杂一点的查询"><a href="#更复杂一点的查询" class="headerlink" title="更复杂一点的查询"></a>更复杂一点的查询</h4><p>下面的查询针对 <code>tweents</code> 类型，并使用以下的条件：</p><ul><li>name 字段中包含 mary 或者 john</li><li>date 值大于 2014-09-10</li><li>_all 字段包含 aggregations 或者 geo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># GET /_all/tweents/_search?q=+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</span><br><span class="line">GET /_all/tweents/_search?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</span><br></pre></td></tr></table></figure></li></ul><p>Get查询虽然比较简洁轻量，但是可读性很差，难以扩展，不好维护，主要是用于开发测试和简单的查询，生产环境中更多地使用功能全面的 request body 查询API</p><h2 id="分析和映射"><a href="#分析和映射" class="headerlink" title="分析和映射"></a>分析和映射</h2><h3 id="精确值和全文"><a href="#精确值和全文" class="headerlink" title="精确值和全文"></a>精确值和全文</h3><p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文</p><p>精确值如日期、数字等数据，字符串也可以作为精确值。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p><p>全文通常是指非结构化的数据，例如一个推文的内容或一封邮件的内容。</p><p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE name    = &quot;John Smith&quot;</span><br><span class="line">  AND user_id = 2</span><br><span class="line">  AND date    &gt; &quot;2014-09-15&quot;</span><br></pre></td></tr></table></figure><p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 意图 ：</p><ul><li>搜索 <code>UK</code> ，会返回包含 <code>United Kindom</code> 的文档。</li><li>搜索 <code>jump</code> ，会匹配 <code>jumped</code> ， <code>jumps</code> ， <code>jumping</code> ，甚至是 <code>leap</code> 。</li><li>搜索 <code>johnny walker</code> 会匹配 <code>Johnnie Walker</code> ， <code>johnnie depp</code> 应该匹配 <code>Johnny Depp</code> 。</li><li><code>fox news hunting</code> 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， <code>fox hunting news</code> 应该返回关于猎狐的故事。</li></ul><p>Elasticsearch 使用到排索引完成这类查询。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p><p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：</p><ol><li>The quick brown fox jumped over the lazy dog</li><li>Quick brown foxes leap over lazy dogs in summer</li></ol><p>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2  </span><br><span class="line">-------------------------  </span><br><span class="line">Quick   |       |  X </span><br><span class="line">The     |   X   |</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |</span><br><span class="line">dogs    |       |  X</span><br><span class="line">fox     |   X   |</span><br><span class="line">foxes   |       |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jumped  |   X   |</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">leap    |       |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TermTerm      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1     </span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1</span><br></pre></td></tr></table></figure><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p><p>但是，我们目前的倒排索引有一些问题：</p><ul><li>Quick 和 quick 以独立的词条出现，然而用户可能认为它们是相同的词。</li><li>fox 和 foxes 非常相似, 就像 dog 和 dogs ；他们有相同的词根。</li><li>jumped 和 leap, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</li></ul><p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p><p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p><ul><li>Quick 可以小写化为 quick 。</li><li>foxes 可以 词干提取 –变为词根的格式– 为 fox 。类似的， dogs 可以为提取为 dog 。</li><li>jumped 和 leap 是同义词，可以索引为相同的单词 jump 。</li></ul><p>现在索引看上去像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |  X</span><br><span class="line">fox     |   X   |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jump    |   X   |  X</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |  X</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |  X</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><p>这还远远不够。我们搜索 +Quick +fox 仍然 会失败，因为在我们的索引中，已经没有 Quick 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 +quick +fox ，这样两个文档都会匹配！</p><p>分词和标准化的过程称为 分析。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析是决定文档如何被搜索到的方式。</p><p>分析 包含下面的过程：</p><ul><li>首先，将一块文本分成适合于倒排索引的独立的 词条 ，</li><li>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall</li></ul><p>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：</p><ol><li>字符过滤器<br>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</li><li>分词器<br>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li><li>Token 过滤器<br>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</li></ol><p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p><h4 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h4><p>Elasticsearch 内置了常用的分析器。用下面字符串举例：</p><p><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p><p>使用不同的分析器将会得到不同的结果：</p><h5 id="1-标准分析器"><a href="#1-标准分析器" class="headerlink" title="1. 标准分析器"></a>1. 标准分析器</h5><p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set_trans, 5</span><br></pre></td></tr></table></figure><h5 id="2-简单分析器"><a href="#2-简单分析器" class="headerlink" title="2. 简单分析器"></a>2. 简单分析器</h5><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set, trans</span><br></pre></td></tr></table></figure><h5 id="3-空格分析器"><a href="#3-空格分析器" class="headerlink" title="3. 空格分析器"></a>3. 空格分析器</h5><p>空格分析器在空格的地方划分文本。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</span><br></pre></td></tr></table></figure><h5 id="4-语言分析器"><a href="#4-语言分析器" class="headerlink" title="4. 语言分析器"></a>4. 语言分析器</h5><p>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p><p>英语 分词器会产生下面的词条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># transparent、 calling 和 set_trans 已经变为词根格式。</span><br><span class="line">set, shape, semi, transpar, call, set_tran, 5</span><br></pre></td></tr></table></figure><h4 id="测试分析器"><a href="#测试分析器" class="headerlink" title="测试分析器"></a>测试分析器</h4><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 analyze API 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Text to analyze&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中每个元素代表一个单独的词条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;tokens&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;text&quot;,    #实际存储到索引中的词条</span><br><span class="line">         &quot;start_offset&quot;: 0,     #指明字符在原始字符串中的开始位置</span><br><span class="line">         &quot;end_offset&quot;:   4,     #指明字符在原始字符串中的结束位置</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     1      #指明词条在原始文本中出现的位置</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;to&quot;,</span><br><span class="line">         &quot;start_offset&quot;: 5,</span><br><span class="line">         &quot;end_offset&quot;:   7,</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;analyze&quot;,</span><br><span class="line">         &quot;start_offset&quot;: 8,</span><br><span class="line">         &quot;end_offset&quot;:   15,</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     3</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在在映射中指定分析器。</p><h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p>映射定义了文档结构，类似与关系数据库中的表结构概念。</p><p>在 Elasticsearch 中，索引中每个文档都有 <strong>类型</strong> 。每种类型都有它自己的 <strong>映射</strong>。映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p><p>注：“域”指的是数据类型、属性，比如时间域、数字域、字符串域</p><h4 id="核心简单域类型"><a href="#核心简单域类型" class="headerlink" title="核心简单域类型"></a>核心简单域类型</h4><p>Elasticsearch 支持如下简单域类型：</p><ul><li>字符串: string</li><li>整数 : byte, short, integer, long</li><li>浮点数: float, double</li><li>布尔型: boolean</li><li>日期: date</li></ul><p>索引（创建）一个包含新域的文档—之前未曾出现– Elasticsearch 会使用 动态映射 ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p><table><thead><tr><th>JSON type</th><th>域 type</th></tr></thead><tbody><tr><td>布尔型: true 或者 false</td><td>boolean</td></tr><tr><td>整数: 123</td><td>long</td></tr><tr><td>浮点数: 123.45</td><td>double</td></tr><tr><td>字符串，有效日期: 2014-09-15</td><td>date</td></tr><tr><td>字符串: foo bar</td><td>string</td></tr></tbody></table><blockquote><p>这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p></blockquote><h4 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h4><p>通过 <code>/_mapping</code> ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射。比如获取索引 <code>gb</code> 中类型 <code>tweet</code> 的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure><p>Elasticsearch 根据我们索引的文档，为域(称为 属性 )动态生成的映射:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;gb&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">         &quot;tweet&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;date&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">                  &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;name&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;tweet&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;user_id&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;long&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h4><p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p><ul><li>全文字符串域和精确值字符串域的区别</li><li>使用特定语言分析器</li><li>优化域以适应部分匹配</li><li>指定自定义数据格式</li><li>更多</li></ul><p>域最重要的属性是 <code>type</code> 。对于不是 <code>string</code> 的域，一般只需要设置 <code>type</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认， <code>string</code> 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p><p><code>string</code> 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>index 属性控制怎样索引字符串。它可以是下面三个值：<br>    1. analyzed<br>    首先分析字符串，然后索引它。换句话说，以全文索引这个域。<br>    2. not_analyzed<br>    索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。<br>    3. no<br>    不索引这个域。这个域不会被搜索到。</p><p><code>string</code> 域 <code>index</code> 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 <code>not_analyzed</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tag&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">        &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他简单类型（例如 long ， double ， date 等）也接受 <code>index</code> 参数，但有意义的值只有 <code>no</code> 和 <code>not_analyzed</code> ， 因为它们永远不会被分析，总是使用精确匹配。</p><h5 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h5><p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如 <code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>，当然也可以自定义分析器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tweet&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">        &quot;index&quot;:     &quot;analyzed&quot;,</span><br><span class="line">        &quot;analyzer&quot;:    &quot;english&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h4><p>首次创建一个索引的时候，可以指定类型的映射。也可以使用 <code>_mapping</code> 为新类型增加映射或者为已存在的类型更新映射。</p><p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。</p><p>创建一个新索引，指定 tweet 域使用 english 分析器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;tweet&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :    &quot;string&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;date&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;string&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user_id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;long&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新这个索引的类型的映射，<code>tweet</code> 映射增加一个新的名为 <code>tag</code> 的 <code>not_analyzed</code> 的文本域，使用 <code>_mapping</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot; : &#123;</span><br><span class="line">    &quot;tag&quot; : &#123;</span><br><span class="line">      &quot;type&quot; :    &quot;string&quot;,</span><br><span class="line">      &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能修改和删除映射已存在域，只能新增域。</p><h4 id="测试映射"><a href="#测试映射" class="headerlink" title="测试映射"></a>测试映射</h4><p>使用 analyze API 测试字符串域的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;name&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tag&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>name</code> 域产生两个词条 <code>black</code> 和 <code>cat</code>（分词） ， <code>tag</code> 域产生单独的词条 <code>Black-cats</code> （不分词）。换句话说，我们的映射正常工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做skywalking相关的项目，skywalking使用了Elasticsearch对数据指标进行存取，要理解skywalking的工程项目，就需要对 Elasticsearch 有一定的了解。&lt;/p&gt;
&lt;p&gt;转载自 &lt;a href=&quot;https://www.jia</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="database" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/"/>
    
    <category term="es" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/"/>
    
    
    <category term="Elasticsearch学习" scheme="https://tianxiafeiyu.github.io/tags/Elasticsearch%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>websocket学习</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/websocket%E5%AD%A6%E4%B9%A0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/websocket%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocke简述"><a href="#WebSocke简述" class="headerlink" title="WebSocke简述"></a>WebSocke简述</h2><p>随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。</p><p>　　我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和Comet技术。其实后者本质上也是一种轮询，只不过有所改进。</p><p>　　轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p><p>　　Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p><p>　　这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。</p><p>　　伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B&#x2F;S模式具备了C&#x2F;S模式的实时通信能力。WebSocket的工作流程是这 样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小 了很多　　</p><ul><li><p>WebSocke是 HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p></li><li><p>WebSocket协议是基于TCP的一种新的网络协议，是一个应用层协议，是TCP&#x2F;IP协议的子集。</p></li><li><p>它实现了浏览器与服务器全双工（full-duplex）通信，客户端和服务器都可以向对方主动发送和接收数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></li><li><p>在JS中创建WebSocket后，会有一个HTTP请求从浏览器发向服务器。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。由于WebScoket使用了自定义协议，所以URL与HTTP协议略有不同。未加密的连接为ws:&#x2F;&#x2F;，而不是http:&#x2F;&#x2F;。加密的连接为wss:&#x2F;&#x2F;，而不是https:&#x2F;&#x2F;，所以如果你的项目使用了网关，又想使用WebSocket，在网关转发这方面，就会遇到问题。</p></li></ul><h2 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h2><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。如 <code>ws:localhost:80\test</code></p><h2 id="gorilla-x2F-websocket-介绍"><a href="#gorilla-x2F-websocket-介绍" class="headerlink" title="gorilla&#x2F;websocket 介绍"></a>gorilla&#x2F;websocket 介绍</h2><p><a href="https://github.com/gorilla/websocket">https://github.com/gorilla/websocket</a></p><p>这是一个封装了go原生websocket的库。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>创建websocket连接地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(&quot;/ws&quot;, serveWs)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func serveWs(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">ws, err := upgrader.Upgrade(w, r, nil)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(&quot;upgrade:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer ws.Close()</span><br><span class="line">    //...</span><br><span class="line">    // 数据写入，发送消息</span><br><span class="line">    ws.WriteMessage(websocket.TextMessage, s.Bytes())</span><br><span class="line">    // 数据读取，接受消息</span><br><span class="line">    _, message, err := ws.ReadMessage()</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><ol><li>聊天室</li><li>c&#x2F;s 架构使用websocket通信</li><li>文件监听</li><li>远程命令</li></ol><h2 id="WebSocket网关"><a href="#WebSocket网关" class="headerlink" title="WebSocket网关"></a>WebSocket网关</h2><p>如果是全新的服务和架构，原生支持websocket固然值最好的</p><p>痛点：</p><ol><li>新服务需要考虑到ws部分的实现和支持；前后端对接增加工作</li><li>不能使用原先的框架快速开发</li><li>旧服务设计之初就不支持ws，服务多，需要重新对接，容易改动引发，改造耗时耗力</li></ol><p>如果存在这样一个服务：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WebSocke简述&quot;&gt;&lt;a href=&quot;#WebSocke简述&quot; class=&quot;headerlink&quot; title=&quot;WebSocke简述&quot;&gt;&lt;/a&gt;WebSocke简述&lt;/h2&gt;&lt;p&gt;随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="websocket学习" scheme="https://tianxiafeiyu.github.io/tags/websocket%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>交换机端口标识含义</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="交换机端口标识含义"><a href="#交换机端口标识含义" class="headerlink" title="交换机端口标识含义"></a>交换机端口标识含义</h4><ul><li>FastEthernet 百兆端口</li><li>GigabitEthernet 千兆端口</li><li>TenGigabitEthernet 万兆端口</li><li>vlan 逻辑端口，划分物理端口的逻辑分区</li><li>StackSub 堆叠端口，支持堆叠的交换机一般有专门的堆叠模块和端口<br>堆叠是指将一台以上的交换机组合起来共同工作，以便在有限的空间内提供尽可能多的端口。</li><li>Port-channel 加入port group 中的物理端口满足某种条件时进行端口汇聚，形成一个port channel。所以Port-channel是逻辑端口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;交换机端口标识含义&quot;&gt;&lt;a href=&quot;#交换机端口标识含义&quot; class=&quot;headerlink&quot; title=&quot;交换机端口标识含义&quot;&gt;&lt;/a&gt;交换机端口标识含义&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;FastEthernet 百兆端口&lt;/li&gt;
&lt;li&gt;GigabitEt</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="交换机端口标识含义" scheme="https://tianxiafeiyu.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>基于etcd实现的分布式锁</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>lock.sh<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @CreateTime:   2021-03-23 16:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Description:  分布式锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Note:         在axis中实现分布式锁时，由于Python的语言特性，导致性能特别差；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此这里直接基于etcd进行实现，对性能有大幅提升！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁名</span></span><br><span class="line"></span><br><span class="line">LOCK\_NAME=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话超时时间，即服务异常退出时锁的最长自动释放时间，单位/秒</span></span><br><span class="line"></span><br><span class="line">TTL=30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否本地锁，如果是本地锁，那么作用和flock类似，不会对集群的其他节点造成影响</span></span><br><span class="line"></span><br><span class="line">IS\_LOCAL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 待执行命令</span></span><br><span class="line"></span><br><span class="line">COMMAND=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接|获取锁|释放锁的超时时间，单位/秒</span></span><br><span class="line"></span><br><span class="line">TIMEOUT=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否输出调试信息</span></span><br><span class="line"></span><br><span class="line">DEBUG=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 用法说明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: dlock \[-n|--name] \[-t|--ttl] \[-w|--timeout] \[-l|--local] \[-d|--debug] \[-h|--help] \&lt;command&gt; \[command args]&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Options:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -n  --name        锁名，默认为被执行命令名&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -t  --ttl         会话超时时间，即服务异常退出时锁的最长自动释放时间，单位/秒&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -w  --timeout     连接超时时间，单位/秒&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -l  --local       本地锁，类似flock&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -d  --debug       输出调试信息&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -h  --help        输出帮助信息并退出&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 解析命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> parse\_cmdline\<span class="function"><span class="title">_args</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">local</span> parsed\_args</span><br><span class="line">parsed\_args=`$(getopt -a -n dlock -o n:t:w:ldh --long name:,ttl:,<span class="built_in">timeout</span>:,<span class="built_in">local</span>,debug,<span class="built_in">help</span> -- <span class="string">&quot;$`@&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> \[ \$? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">usage</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">&quot;<span class="variable">$parsed_args</span>&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">            -n | --name)    LOCK_NAME=<span class="string">&quot;<span class="variable">$2</span>&quot;</span>         ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -t | --ttl)     TTL=<span class="variable">$2</span>                 ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -w | --<span class="built_in">timeout</span>) TIMEOUT=<span class="variable">$2</span>             ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -l | --<span class="built_in">local</span>)   IS_LOCAL=<span class="literal">true</span>          ; <span class="built_in">shift</span>    ;;</span><br><span class="line">            -d | --debug)   DEBUG=<span class="literal">true</span>             ; <span class="built_in">shift</span>    ;;</span><br><span class="line">            -h | --<span class="built_in">help</span>)    usage ;;</span><br><span class="line">            --)             <span class="built_in">shift</span>; <span class="built_in">break</span> ;;</span><br><span class="line">            *)              usage ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剩余参数就当做被执行命令看待</span></span><br><span class="line">    COMMAND=<span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$COMMAND</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        usage</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 主函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">parse\_cmdline\_args <span class="string">&quot;\$@&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 未指定锁名的情况下，默认使用可执行文件作为锁名</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$LOCK_NAME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LOCK_NAME=$(<span class="built_in">echo</span> <span class="variable">$COMMAND</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为本地锁的情况下，使用主机名作为锁名前缀</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$IS_LOCAL</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> hostname</span><br><span class="line">        hostname=$(hostname)</span><br><span class="line">        LOCK_NAME=<span class="string">&quot;<span class="variable">$hostname</span>/<span class="variable">$LOCK_NAME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目前基于etcd来实现分布式锁</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$TIMEOUT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> ETCDCTL_CONNECTION_TIMEOUT=<span class="variable">$TIMEOUT</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 需要把etcdctl的第一行warning日志去掉或者过滤掉</span></span><br><span class="line">    /sf/bin/etcdctl lock --debug=<span class="variable">$DEBUG</span> --ttl=<span class="variable">$TTL</span> <span class="string">&quot;<span class="variable">$LOCK_NAME</span>&quot;</span> <span class="variable">$COMMAND</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main <span class="string">&quot;\$@&quot;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;lock.sh&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="基于etcd实现的分布式锁" scheme="https://tianxiafeiyu.github.io/tags/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法---常见算法减治、分治、递归、迭代、回溯、动态规划、贪心的基本思想</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/cqfdcw/article/details/100063987">https://blog.csdn.net/cqfdcw/article/details/100063987</a></p><h4 id="一、减而治之"><a href="#一、减而治之" class="headerlink" title="一、减而治之"></a>一、减而治之</h4><p>减而治之与分而治之都是递归中常用的算法策略。其中减而治之是将一个大规模的问题，将其划分为两个子问题，其一是平凡问题，另一个规模缩减。递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡问题。</p><p>应用举例1：求解数组元素的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>)?<span class="number">0</span>:sum(A,n-<span class="number">1</span>)+A[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：数组中元素倒置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为得到整个数组的倒置，可以先对换其首、末元素，然后递归地倒置除这两个元素以外的部分。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> lo, <span class="type">int</span> hi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &lt; hi) &#123;</span><br><span class="line">        swap(A[lo],A[hi]);</span><br><span class="line">        reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、分而治之"><a href="#二、分而治之" class="headerlink" title="二、分而治之"></a>二、分而治之</h4><p>可以将其划分为多个（通常情况下为两个）子问题，两个问题的规模大体相同。由子问题的解，通过递归得到原问题的解。</p><p>应用举例1：求解数组元素的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (low == high) ? A[low] : sum(A, low, (low + high) &gt;&gt; <span class="number">1</span>) + sum(A, ((low + high) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(vector&lt;T&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> mid, <span class="type">int</span> R)</span> &#123;  <span class="comment">//有序向量的逐层归并</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp;   <span class="comment">//临时变量用来存放本次合并后的数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">temp.push_back(arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的循环退出后，把剩余的元素依次填入到temp中，只有一个while会执行</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">temp.push_back(arr[p1++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">temp.push_back(arr[p2++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把最终的排序的结果复制给原数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">arr[L + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(vector&lt;T&gt; &amp;arr , <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123; <span class="comment">//无序向量的逐层分解</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;  <span class="comment">//只有一个元素的时候返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">mergeSort(arr, L, mid);  </span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、递归与迭代"><a href="#三、递归与迭代" class="headerlink" title="三、递归与迭代"></a>三、递归与迭代</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>重复调用函数自身实现循环，A函数调用A函数。简而言之，通过不断地深层调用函数，直到函数有返回才会逐层的返回，把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解(子问题须与原始问题为同样的事，且更为简单)；递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域。</p><p>应用举例1：二叉树的先序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sytem.out.println(node.val);</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：递归求阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用变量的原值推出新值称为迭代，或着说迭代是函数内某段代码实现循环，A函数调用B函数；每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。重复执行一系列运算步骤，从前面的量依次求出后面的量的过程。</p><p>应用举例1：迭代法求阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代   阶乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归与迭代比较"><a href="#递归与迭代比较" class="headerlink" title="递归与迭代比较"></a>递归与迭代比较</h4><p>递归满足条件后，逐层返回，每层都计算完后才返回结果；迭代满足条件后，通过计数器结束循环，直接返回计算结果。 递归与迭代相比较，递归的效率较低。</p><ul><li>| 定义 | 优点 | 缺点<br>—|— | —|—<br>递归 |重复调用函数自身实现循环|a.用有限的循环语句实现无限集合；b.代码易读；c.大问题转化成小问题，减少了代码量。|a.递归不断调用函数，浪费空间；b.容易造成堆栈溢出<br>迭代 |利用变量的原值推出新值；函数内某段代码实现循环。|a.效率高，运行时间只随循环的增加而增加；b.无额外开销。|a.代码难理解；b.代码不如递归代码简洁；c.编写复杂问题时，代码逻辑不易想出<br>关系|a.递归中一定有迭代，但是迭代中不一定有递归；大部分可以相互转换。b.相对来说，能用迭代不用递归（因为递归不断调用函数，浪费空间，容易造成堆栈溢出）||</li></ul><h4 id="四、回溯"><a href="#四、回溯" class="headerlink" title="四、回溯"></a>四、回溯</h4><p>又称为试探法，可以理解为尝试不同岔路口，遇到错误原路返回到岔路口走另外一条路，当解决问题的每一步都有多种选择时候，在某一步选择了其中一个选项时，则进入此选项，然后继续新的选择。若选择符合题目要求则此选择是正确的；若此选择不符合题目要求则此选择是不正确的，此时就需要(递归)返回上一步，重新进行选择。</p><p>回溯法说白了就是穷举法。回溯法一般用递归来解决。</p><p>回溯法通常要确定三个要素：</p><ol><li><p>选择<br> 对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列</p></li><li><p>条件<br> 对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。</p></li><li><p>结束<br> 当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。</p></li></ol><p>回溯法中，递归函数的设计需要遵循以下四个原则：</p><ol><li><p>必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。</p></li><li><p>可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。</p></li><li><p>最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。</p></li><li><p>要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。</p></li></ol><h4 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h4><h5 id="题目1：给出n对括号，打印出所有可能的括号排列序列。"><a href="#题目1：给出n对括号，打印出所有可能的括号排列序列。" class="headerlink" title="题目1：给出n对括号，打印出所有可能的括号排列序列。"></a>题目1：给出n对括号，打印出所有可能的括号排列序列。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackTracking</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> leftnum=n,rightnum=n;<span class="comment">//左括号和右括号都各有n个</span></span><br><span class="line">ArrayList&lt;String&gt; results=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//用于存放解空间</span></span><br><span class="line">parentheses(<span class="string">&quot;&quot;</span>, results, leftnum, rightnum);</span><br><span class="line"><span class="keyword">for</span>(String s:results)</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parentheses</span><span class="params">(String sublist, ArrayList&lt;String&gt; results, <span class="type">int</span> leftnum, <span class="type">int</span> rightnum)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(leftnum==<span class="number">0</span>&amp;&amp;rightnum==<span class="number">0</span>)<span class="comment">//结束</span></span><br><span class="line">results.add(sublist);</span><br><span class="line"><span class="keyword">if</span>(rightnum&gt;leftnum)<span class="comment">//选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间</span></span><br><span class="line">parentheses(sublist+<span class="string">&quot;)&quot;</span>, results, leftnum, rightnum-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(leftnum&gt;<span class="number">0</span>)</span><br><span class="line">parentheses(sublist+<span class="string">&quot;(&quot;</span>, results, leftnum-<span class="number">1</span>, rightnum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应回溯法三要素：</p><ol><li>选择。在这个例子中，解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号。</li><li>条件。在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于0才能放入左括号。这里if的顺序会影响输出的顺序，但是不影响最终解。</li><li>结束。这里的结束条件很显然就是，左右括号都放完了。</li></ol><p>对应回溯法递归函数参数设计：</p><ol><li>用了一个空字符串来作为临时变量存储不完整解。</li><li>用了一个ArrayList<String> results来存放符合要求的解。在后面可以看到，不一定要这样做，也可以直接打印结果。</li><li>把leftnum和rightnum传入给递归函数，这样可以用于判断结束条件。</li><li>这个例子不明显。但是事实上也符合这个条件。可以仔细观察代码，可以发现由于使用了两个if，所以当一次递归退出后，例如从第一个if退出，第二个递归直接递归的是leftnum-1和rightnum，这其实是已经恢复状态了（如果没有恢复状态，那就是leftnum, rightnum-1）。因此不需要人为让他恢复状态。但是恢复状态这点是很重要的，因为回溯法，顾名思义要回溯，不恢复状态，怎么回溯呢。</li></ol><h5 id="题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于-该目标的组合（数字不同组合顺序当做一个解）。"><a href="#题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于-该目标的组合（数字不同组合顺序当做一个解）。" class="headerlink" title="题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于 该目标的组合（数字不同组合顺序当做一个解）。"></a>题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于 该目标的组合（数字不同组合顺序当做一个解）。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackTracking</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> target=<span class="number">9</span>;</span><br><span class="line">find(num, target, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> target, String temp)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(issolution(temp,target))&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]!=-<span class="number">1</span>)&#123;<span class="comment">//如果取过这个数字了，就置为-1</span></span><br><span class="line"><span class="type">int</span> k=num[i];</span><br><span class="line">num[i]=-<span class="number">1</span>;</span><br><span class="line">find(num, target, temp+k);</span><br><span class="line">num[i]=k;   <span class="comment">//在递归后，必须把数组恢复。这也是参数的特征的第四点所说的内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">issolution</span><span class="params">(String temp, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"><span class="type">boolean</span> result=<span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.length();i++)&#123;</span><br><span class="line">count=count+Integer.valueOf(temp.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==target)</span><br><span class="line">result=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目3：给一个字符串-字符不重复，给出他的所有排列"><a href="#题目3：给一个字符串-字符不重复，给出他的所有排列" class="headerlink" title="题目3：给一个字符串,字符不重复，给出他的所有排列"></a>题目3：给一个字符串,字符不重复，给出他的所有排列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BackTracking &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">String s=&quot;abc&quot;;</span><br><span class="line">pailie(s,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void pailie(String s, String temp)&#123;//参数设计地尽量地简洁</span><br><span class="line">if(s.length()==0)&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">String news=s.substring(0, i)+s.substring(i+1,s.length());//去掉String中的某个字母</span><br><span class="line">pailie(news, temp+s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目4："><a href="#题目4：" class="headerlink" title="题目4："></a>题目4：</h5><h4 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h4><p>在对问题进行求解时，总是做出当前看来是最好的选择的一种方法，从而希望能够导致结果是最好或者最优的算法(可能是局部最优解也可能是全局最优解)。是动态规划的一种特例，能用贪心解决的问题，也可以用动态规划解决。</p><h4 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h4><p>动态规划的实质是分治思想和解决冗余，是一种将问题实例分解为更小的、相似的子问题，求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，避免计算重复的子问题，以解决最优化问题的算法策略。（可分为多个相关子问题，子问题的解被重复使用）。</p><p>[]: <a href="https://blog.csdn.net/cqfdcw/article/details/100063987">https://blog.csdn.net/cqfdcw/article/details/100063987</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net/cqfdcw/article/details/100063987&quot;&gt;https://blog.csdn.net/cqfdcw/article/details/100063987&lt;/a&gt;&lt;/p&gt;
&lt;h4 i</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="数据结构与算法---常见算法减治、分治、递归、迭代、回溯、动态规划、贪心的基本思想【转】" scheme="https://tianxiafeiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>火焰图怎么看</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “平顶”（plateaus），就表示该函数可能存在性能问题。</p><p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “平顶”（plateaus），就表示该函数可能存在性能问题。</p><p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。&lt;/p&gt;
&lt;p&gt;x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="火焰图怎么看" scheme="https://tianxiafeiyu.github.io/tags/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue-优先级队列</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、什么是优先级队列"><a href="#一、什么是优先级队列" class="headerlink" title="一、什么是优先级队列"></a>一、什么是优先级队列</h4><p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p><p>优先级队列底层的数据结构其实是一棵二叉堆</p><h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不用比较器，默认升序排列，每次出列都是队列中最大元素，相当于小顶堆</span></span><br><span class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 降序排列，每次出列都是队列中最小元素，相当于大顶堆</span></span><br><span class="line">        Queue&lt;Integer&gt; maxHeap1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        Queue&lt;Integer&gt; maxHeap2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            minHeap.add(num);   <span class="comment">// 添加元素</span></span><br><span class="line">            maxHeap1.add(num);</span><br><span class="line">            maxHeap2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> minHeap.peek(); <span class="comment">// 获得队首元素，不出列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> minHeap.poll(); <span class="comment">// 获得队首元素并出列，队列为空返回 null</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> minHeap.remove();  <span class="comment">// 获得队首元素并出列, 队列为空报错</span></span><br><span class="line"></span><br><span class="line">        System.out.println(a + <span class="string">&quot;,&quot;</span> + b + <span class="string">&quot;,&quot;</span> + c);  <span class="comment">// 1,1,3</span></span><br><span class="line">        System.out.println(maxHeap1.peek() + <span class="string">&quot;,&quot;</span> + maxHeap1.poll() + <span class="string">&quot;,&quot;</span> + maxHeap1.remove());  <span class="comment">// 9,9,7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、什么是优先级队列&quot;&gt;&lt;a href=&quot;#一、什么是优先级队列&quot; class=&quot;headerlink&quot; title=&quot;一、什么是优先级队列&quot;&gt;&lt;/a&gt;一、什么是优先级队列&lt;/h4&gt;&lt;p&gt;PriorityQueue类在Java1.5中引入。PriorityQueu</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="PriorityQueue-优先级队列" scheme="https://tianxiafeiyu.github.io/tags/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>实体类中用基本类型还是包装类</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中基本类型：</p><p>int、short、byte、long、float、double、char、boolean </p><p>对应的包装类：</p><p>Integer 、Long、Short、Byte、Character、Double、Float、Boolean</p><table><thead><tr><th>Java中基本类型</th><th>默认初始值</th><th>bit</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>8</td></tr><tr><td>short</td><td>0</td><td>16</td></tr><tr><td>int</td><td>0</td><td>32</td></tr><tr><td>long</td><td>0</td><td>64</td></tr><tr><td>float</td><td>0.0</td><td>32</td></tr><tr><td>double</td><td>0.0</td><td>64</td></tr><tr><td>char</td><td>‘ ‘</td><td>16</td></tr><tr><td>boolean</td><td>false</td><td>32</td></tr></tbody></table><table><thead><tr><th>对应的包装类</th><th>默认初始值</th><th>bit</th></tr></thead><tbody><tr><td>Byte</td><td>null</td><td></td></tr><tr><td>Short</td><td>null</td><td></td></tr><tr><td>Integer</td><td>null</td><td></td></tr><tr><td>Long</td><td>null</td><td></td></tr><tr><td>Float</td><td>null</td><td></td></tr><tr><td>Double</td><td>null</td><td></td></tr><tr><td>Character</td><td>null</td><td></td></tr><tr><td>Boolean</td><td>null</td><td></td></tr></tbody></table><h4 id="建模的时候用基本类型还是包装类型呢？"><a href="#建模的时候用基本类型还是包装类型呢？" class="headerlink" title="建模的时候用基本类型还是包装类型呢？"></a>建模的时候用基本类型还是包装类型呢？</h4><p>个人认为还是包装类的好，原因有下：</p><p>数据库null问题，表字段都<br>可能有null，包装类型默认值为null，基本类型不能为null</p><p>但是需要注意的是：Integer 的判断问题，需要使用 intValue 方法。 &#x3D;&#x3D; 判断可能会出现许多的问题。S</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java中基本类型：&lt;/p&gt;
&lt;p&gt;int、short、byte、long、float、double、char、boolean &lt;/p&gt;
&lt;p&gt;对应的包装类：&lt;/p&gt;
&lt;p&gt;Integer 、Long、Short、Byte、Character、Double、Float、Bo</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="实体类中用基本类型还是包装类" scheme="https://tianxiafeiyu.github.io/tags/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>混乱的Java版本命名</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.cnblogs.com/biggw/p/11776294.html">https://www.cnblogs.com/biggw/p/11776294.html</a></p><h2 id="JDK版本与发行时间"><a href="#JDK版本与发行时间" class="headerlink" title="JDK版本与发行时间"></a>JDK版本与发行时间</h2><table><thead><tr><th>版本</th><th>名称</th><th>发行日期</th></tr></thead><tbody><tr><td>JDK 1.0</td><td>Oak(橡树)</td><td>1996-01-23</td></tr><tr><td>JDK 1.1</td><td>none（无）</td><td>1997-02-19</td></tr><tr><td>JDK 1.1.4</td><td>Sparkler（宝石）</td><td>1997-09-12</td></tr><tr><td>JDK 1.1.5</td><td>Pumpkin（南瓜）</td><td>1997-12-13</td></tr><tr><td>JDK 1.1.6</td><td>Abigail（阿比盖尔–女子名）</td><td>1998-04-24</td></tr><tr><td>JDK 1.1.7</td><td>Brutus（布鲁图–古罗马政治家和将军）</td><td>1998-09-28</td></tr><tr><td>JDK 1.1.8</td><td>Chelsea（切尔西–城市名）</td><td>1999-04-08</td></tr><tr><td>J2SE 1.2</td><td>Playground（运动场）</td><td>1998-12-04</td></tr><tr><td>J2SE 1.2.1</td><td>none（无）</td><td>1999-03-30</td></tr><tr><td>J2SE 1.2.2</td><td>Cricket（蟋蟀）</td><td>1999-07-08</td></tr><tr><td>J2SE 1.3</td><td>Kestrel（美洲红隼）</td><td>2000-05-08</td></tr><tr><td>J2SE 1.3.1</td><td>Ladybird（瓢虫）</td><td>2001-05-17</td></tr><tr><td>J2SE 1.4.0</td><td>Merlin（灰背隼）</td><td>2002-02-13</td></tr><tr><td>J2SE 1.4.1</td><td>grasshopper（蚱蜢）</td><td>2002-09-16</td></tr><tr><td>J2SE 1.4.2</td><td>Mantis（螳螂）</td><td>2003-06-26</td></tr><tr><td>Java SE 5.0 (1.5.0)</td><td>Tiger（老虎）</td><td>2004-09-30</td></tr><tr><td>Java SE 6.0 (1.6.0)</td><td>Mustang（野马）</td><td>2006-04</td></tr><tr><td>Java SE 7.0 (1.7.0)</td><td>Dolphin（海豚）</td><td>2011-07-28</td></tr><tr><td>Java SE 8.0 (1.8.0)</td><td>Spider（蜘蛛）</td><td>2014-03-18</td></tr><tr><td>Java SE 9.0</td><td>none（无）</td><td>2017-09-21</td></tr><tr><td>Java SE 10.0</td><td>none（无）</td><td>2018-03-21</td></tr><tr><td>Java SE 11.0</td><td>none（无）</td><td>2018-09-25</td></tr></tbody></table><p>Java大体有3大类命名方式：JDK、J2SE、JAVA SE。</p><p>我们口中说的Java8、JDK8、JDK1.8都是一个东西，JDK(Java Development Kit)</p><h2 id="Java命名方式更改的事件原因"><a href="#Java命名方式更改的事件原因" class="headerlink" title="Java命名方式更改的事件原因"></a>Java命名方式更改的事件原因</h2><p>1998年12月8日，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。</p><p>2004年9月30日，J2SE1.5发布。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0）</p><p>2005年6月，Java SE 6正式发布。此时，Java的各种版本已经更名，已取消其中的数字2（如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://www.cnblogs.com/biggw/p/11776294.html&quot;&gt;https://www.cnblogs.com/biggw/p/11776294.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;JDK版本与发行时间&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="混乱的Java版本命名" scheme="https://tianxiafeiyu.github.io/tags/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>解读阿里巴巴 Java 代码规范</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/">https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2017 年阿里云栖大会，阿里发布了针对 Java 程序员的《阿里巴巴 Java 开发手册（终极版）》，这篇文档作为阿里数千位 Java 程序员的经验积累呈现给公众，并随之发布了适用于 Eclipse 和 Intellim 的代码检查插件。为了能够深入了解 Java 程序员编码规范，也为了深入理解为什么阿里这样规定，是否规定有误，本文以阿里发布的这篇文档作为分析起源，扩大范围至业界其他公司的规范，例如谷歌、FaceBook、微软、百度、华为，并搜索网络上技术大牛发表的技术文章，深入理解每一条规范的设计背景和目标。</p><p>由于解读文章仅有两篇，所以按照阿里的篇幅权重分为上篇仅针对 Java 语言本身的编码规约，下篇包含日志管理、异常处理、单元测试、MySQL 规范、工程规范等方面内容进行解读。本文是上篇，主要针对编码规约部分进行解读，由于篇幅限制，仅挑选一小部分进行解读，如果需要全篇，请联系本文作者。</p><h2 id="一、编码规约"><a href="#一、编码规约" class="headerlink" title="一、编码规约"></a>一、编码规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><h4 id="1-下划线或者美元符号"><a href="#1-下划线或者美元符号" class="headerlink" title="1. 下划线或者美元符号"></a>1. 下划线或者美元符号</h4><p>阿里强制规定代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p><p>反例：<code>Java_name/__name/$Object/name_/name$/Object$</code></p><p><strong>我的理解：</strong></p><p>Oracle 官网建议不要使用$或者开始变量命名，并且建议在命名中完全不要使用”$”字符，原文是”The convention,however,is to always begin your variable names with a letter,not ‘$’ or ‘‘”。对于这一条，腾讯的看法是一样的，百度认为虽然类名可以支持使用”$”符号，但只在系统生成中使用（如匿名类、代理类），编码不能使用。</p><p>这类问题在 StackOverFlow 上有很多人提出，主流意见为人不需要过多关注，只需要关注原先的代码是否存在”“，如果存在就继续保留，如果不存在则尽量避免使用。也有一位提出尽量不适用”“的原因是低分辨率的显示器，肉眼很难区分”“（一个下划线）和”_“（两个下划线）。</p><p>我个人觉得可能是由于受 C 语言的编码规范所影响。因为在 C 语言里面，系统头文件里将宏名、变量名、内部函数名用开头，因为当你#include 系统头文件时，这些文件里的名字都有了定义，如果与你用的名字冲突，就可能引起各种奇怪的现象。综合各种信息，建议不要使用”“、”$”、空格作为命名开始，以免不利于阅读或者产生奇怪的问题。</p><h4 id="2-类命名"><a href="#2-类命名" class="headerlink" title="2. 类命名"></a>2. 类命名</h4><p>阿里强制规定类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO&#x2F;BO&#x2F;DTO&#x2F;VO&#x2F;AO。 </p><p>正例：<code>MarcoPolo/UserDO/XmlService/TcpUdpDeal/TarPromotion</code></p><p>反例：<code>macroPolo/UserDo/XMLService/TCPUDPD/TAPromotion</code></p><p><strong>我的理解：</strong></p><p>百度除了支持阿里的规范以外，规定虽然类型支持”$”符号，但只在系统生成中使用（如匿名类、代理类），编码中不能使用。</p><p>对于类名，俄罗斯 Java 专家 Yegor Bugayenko 给出的建议是尽量采用现实生活中实体的抽象，如果类的名字以”-er”结尾，这是不建议的命名方式。他指出针对这一条有一个例外，那就是工具类，例如 StringUtils、FileUtils、IOUtils。对于接口名称，不要使用 IRecord、IfaceEmployee、RedcordInterface，而是使用现实世界的实体命名。如清单 3 所示。</p><p>清单 3 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class SimpleUser implements User&#123;&#125;;</span><br><span class="line">Class DefaultRecord implements Record&#123;&#125;;</span><br><span class="line">Class Suffixed implements Name&#123;&#125;;</span><br><span class="line">Class Validated implements Content&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-抽象类的命名"><a href="#3-抽象类的命名" class="headerlink" title="3. 抽象类的命名"></a>3. 抽象类的命名</h4><p>阿里强制规定抽象类命名使用 Abstratc 或 Base 开头。</p><p><strong>我的理解：</strong></p><p>Oracle 的抽象类和方法规范并没有要求必须采用 Abstract 或者 Base 开头命名，事实上官网上的示例没有这种命名规范要求，如清单 4 所示。</p><p>清单 4 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GraphicObject</span>&#123;</span><br><span class="line">    <span class="comment">//declare fields</span></span><br><span class="line">    <span class="comment">//declare nonabstract methods</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也查了一下 JDK，确实源码里很多类都是以这样的方式命名的，例如抽象类 java.util.AbstractList。</p><p>Stackoverflow 上对于这个问题的解释是，由于这些类不会被使用，一定会由其他的类继承并实现内部细节，所以需要明白地告诉读者这是一个抽象类，那以 Abstract 开头比较合适。</p><p>JoshuaBloch的理解是支持以 Abstract 开头。我的理解是不要以 Base 开头命名，因为实际的基类也以 Base 开头居多，这样意义有多样性，不够直观。</p><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><h4 id="1-避免魔法值的使用"><a href="#1-避免魔法值的使用" class="headerlink" title="1. 避免魔法值的使用"></a>1. 避免魔法值的使用</h4><p>阿里强制规定不允许任何魔法值（未经定义的常量）直接出现在代码中。</p><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;Id#taobao_&quot;</span> + tradeId；</span><br><span class="line">cache.put(key,value);</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>魔法值确实让你很疑惑，比如你看下面这个例子：</p><p>int priceTable[] &#x3D; new int[16];&#x2F;&#x2F;这样定义错误；这个 16 究竟代表什么？</p><p>正确的定义方式是这样的：</p><p>static final int PRICE_TABLE_MAX &#x3D; 16; &#x2F;&#x2F;这样定义正确，通过使用完整英语单词的常量名明确定义</p><p>int price Table[] &#x3D; new int[PRICE_TABLE_MAX];</p><p>魔法值会让代码的可读性大大降低，而且如果同样的数值多次出现时，容易出现不清楚这些数值是否代表同样的含义。另一方面，如果本来应该使用相同的数值，一旦用错，也难以发现。因此可以采用以下两点，极力避免使用魔法数值。</p><ol><li>不适用魔法数值，使用带名字的 Static final 或者 enum 值；</li><li>原则上 0 不用于魔法值，这是因为 0 经常被用作数组的最小下标或者变量初始化的缺省值。</li></ol><h4 id="2-变量值范围"><a href="#2-变量值范围" class="headerlink" title="2. 变量值范围"></a>2. 变量值范围</h4><p>阿里推荐如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面这个正例中的数字就是延伸信息，表示星期几。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum &#123;MONDAY(<span class="number">1</span>),TUESDAY(<span class="number">2</span>),WEDNESDAY(<span class="number">3</span>),THURSDAY(<span class="number">4</span>),FRIDAY(<span class="number">5</span>),SATURDAY(<span class="number">6</span>),SUNDAY(<span class="number">7</span>);&#125;</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>对于固定并且编译时对象，如 Status、Type 等，应该采用 enum 而非自定义常量实现，enum 的好处是类型更清楚，不会再编译时混淆。这是一个建议性的试用推荐，枚举可以让开发者在 IDE 下使用更方便，也更安全。另外就是枚举类型是一种具有特殊约束的类类型，这些约束的存在使得枚举类本身更加简洁、安全、便捷。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h4 id="1-大括号的使用约定"><a href="#1-大括号的使用约定" class="headerlink" title="1. 大括号的使用约定"></a>1. 大括号的使用约定</h4><p>阿里强制规定如果是大括号为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则遵循如下原则：</p><ol><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>右大括号后还有 else 等代码则不换行表示终止的右大括号后必须换行</li></ol><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// try to do...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// do somthing...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// do somthing...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>阿里的这条规定应该是参照了 SUN 公司 1997 年发布的代码规范（SUN 公司是 JAVA 的创始者），Google 也有类似的规定，大家都是遵循 K&amp;R 风格（Kernighan 和 Ritchie），Kernighan 和 Ritchie 在《The C Programming Language》一书中推荐这种风格，JAVA 语言的大括号风格就是受到了 C 语言的编码风格影响。</p><p>注意，SUN 公司认为方法名和大括号之间不应该有空格。</p><h4 id="2-单行字符数限制"><a href="#2-单行字符数限制" class="headerlink" title="2. 单行字符数限制"></a>2. 单行字符数限制</h4><p>阿里强制规定单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p><ol><li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>方法调用时，多个参数，需要换行时，在逗号后进行。</li><li>在括号前不要换行，见反例。</li></ol><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>).append</span><br><span class="line">(<span class="string">&quot;huang&quot;</span>);</span><br><span class="line"><span class="comment">//参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1,args2,args3,....,argsX);</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong><br>SUN 公司 1997 年的规范中指出单行不要超过 80 个字符，对于文档里面的代码行，规定不要超过 70 个字符单行。当表达式不能在一行内显示的时候，遵循以下原则进行切分：</p><ol><li>在逗号后换行；</li><li>在操作符号前换行；</li><li>倾向于高级别的分割；</li><li>尽量以描述完整作为换行标准；</li><li>如果以下标准造成代码阅读困难，直接采用 8 个空格方式对第二行代码留出空白。</li></ol><h3 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h3><h4 id="1-静态变量及方法调用"><a href="#1-静态变量及方法调用" class="headerlink" title="1. 静态变量及方法调用"></a>1. 静态变量及方法调用</h4><p>阿里强制规定代码中避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p><p><strong>我的理解：</strong></p><p>谷歌公司在代码规范中指出必须直接使用类名对静态成员进行引用。并同时举例说明，如清单 9 所示。</p><p>清单 9 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">aFoo</span> <span class="operator">=</span> …;</span><br><span class="line">Foo.aStaticMethod();<span class="comment">//good</span></span><br><span class="line">aFoo.aStaticMethod();<span class="comment">//bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod();<span class="comment">//very bad</span></span><br></pre></td></tr></table></figure><p>SUN 公司 1997 年发布的代码规范也做了类似的要求。</p><p>为什么需要这样做呢？因为被 static 修饰过的变量或者方法都是随着类的初始化产生的，在堆内存中有一块专门的区域用来存放，后续直接用类名访问即可，避免编译成本的增加和实例对象存放空间的浪费。</p><p>StackOverflow 上也有人提出了相同的疑问，网友较为精辟的回复是”<strong>这是由于生命周期决定的，静态方法或者静态变量不是以实例为基准的，而是以类为基准，所以直接用类访问，否则违背了设计初衷</strong>“。那为什么还保留了实例的访问方式呢？可能是因为允许应用方无污染修改吧。</p><h4 id="2-可变参数编程"><a href="#2-可变参数编程" class="headerlink" title="2. 可变参数编程"></a>2. 可变参数编程</h4><p>阿里强制规定相同参数类型、相同业务类型，才可以使用 Java 的可变参数，避免使用 Object，并且要求可变参数必须放置在参数列表的最后（提倡同学们尽量不用可变参数编程）。</p><p><strong>我的理解：</strong><br>我们先来了解可变参数的使用方式：</p><ol><li>在方法中定义可变参数后，我们可以像操作数组一样操作该参数。</li><li>如果该方法除了可变参数还有其他的参数，可变参数必须放到最后。</li><li>拥有可变参数的方法可以被重载，在被调用时，如果能匹配到参数定长的方法则优先调用参数定长的方法。</li><li><strong>可变参数可以兼容数组参数，但数组参数暂时无法兼容可变参数</strong>。</li></ol><p>至于为什么可变参数需要被放在最后一个，这是因为参数个数不定，所以当其后还有相同类型参数时，编译器无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p><p>可变参数编程有一些好处，例如反射、过程建设、格式化等。对于阿里同学提出的尽量不使用可变参数编程，我猜测的原因是不太可控，比如 Java8 推出 Lambda 表达式之后，可变参数编程遇到了实际的实现困难。</p><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><h4 id="1-单例模式需要保证线程安全"><a href="#1-单例模式需要保证线程安全" class="headerlink" title="1. 单例模式需要保证线程安全"></a>1. 单例模式需要保证线程安全</h4><p>阿里强制要求获取单例对象需要保证线程安全，其中的方法也要保证线程安全，并进一步说明资源驱动类、工具类、单例工厂类都需要注意。</p><p><strong>我的理解：</strong></p><p>对于这一条规范是通识化规定，我这里进一步讲讲如何做好针对单例对象的线程安全，主要有以下几种方式：</p><p><strong>1. 方法中申明 synchronized 关键字</strong></p><p>出现非线程安全问题，是由于多个线程可以同时进入 getInstance()方法，那么只需要对该方法进行 synchronized 锁同步即可，如清单 15 所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 清单 15 synchronized 关键字方式</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式</span></span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//创建实例之前可能会有一些准备性的耗时工作</span></span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">             Instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从执行结果上来看，多线程访问的问题已经解决了，返回的是一个实例。但是这种实现方式的运行效率很低。我们接下来采用同步方法块实现。</p><p><strong>2. 2. 同步方法块实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (MySingleton.class) &#123;          </span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式   </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;      </span><br><span class="line">                    <span class="comment">//创建实例之前可能会有一些准备性的耗时工作 </span></span><br><span class="line">                    Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。</p><p><strong>3. 针对某些重要的代码来进行单独的同步:</strong></p><p>针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式                    </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="comment">//创建实例之前可能会有一些准备性的耗时工作 </span></span><br><span class="line">                Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                <span class="keyword">synchronized</span> (MySingleton.class) &#123; </span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。</p><p><strong>4. 双检查锁机制（Double Check Locking）</strong></p><p>为了达到线程安全，又能提高代码执行效率，我们这里可以采用 DCL 的双检查锁机制来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="comment">//使用 volatile 关键字保其可见性 </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式 </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="comment">//创建实例之前可能会有一些准备性的耗时工作  </span></span><br><span class="line">                Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                <span class="keyword">synchronized</span> (MySingleton.class) &#123; </span><br><span class="line">                    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;<span class="comment">//二次检查  </span></span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在声明变量时使用了 volatile 关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p><p><strong>5. 静态内置类方式</strong></p><p>DCL 解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123;          </span><br><span class="line">    <span class="comment">//内部类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySingletonHandler</span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> MySingletonHandler.instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 序列化与反序列化方式</strong></p><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySingletonHandler</span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> MySingletonHandler.instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. 使用枚举数据类型方式</strong></p><p>枚举 enum 和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumFactory</span>&#123; </span><br><span class="line">    singletonFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> MySingleton instance; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumFactory</span><span class="params">()</span>&#123;<span class="comment">//枚举类的构造方法在类加载是被实例化</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;<span class="comment">//需要获实现单例的类，比如数据库连接 Connection  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写枚举类被完全暴露了，据说违反了”职责单一原则”，我们可以按照下面的代码改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFactory</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">MyEnumSingleton</span>&#123; </span><br><span class="line">        singletonFactory; </span><br><span class="line">        <span class="keyword">private</span> MySingleton instance; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">MyEnumSingleton</span><span class="params">()</span>&#123;<span class="comment">//枚举类的构造方法在类加载是被实例化 </span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> instance; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> MyEnumSingleton.singletonFactory.getInstance(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;<span class="comment">//需要获实现单例的类，比如数据库连接 Connection  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不太理解这种写法，为什么不直接把单例类改成枚举呢？？（2020.11.12）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MySingleton</span>&#123; </span><br><span class="line">    instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="1-Switch-语句的使用"><a href="#1-Switch-语句的使用" class="headerlink" title="1. Switch 语句的使用"></a>1. Switch 语句的使用</h4><p>阿里强制规定在一个 switch 块内，每个 case 要么通过 break&#x2F;return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</p><p><strong>我的理解：</strong></p><p>首先理解前半部分，”每个 case 要么通过 break&#x2F;return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止”。因为这样可以比较清楚地表达程序员的意图，有效防止无故遗漏的 break 语句。default 语句里面也应该有 break&#x2F;return。</p><h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h4 id="1-集合转数组处理"><a href="#1-集合转数组处理" class="headerlink" title="1. 集合转数组处理"></a>1. 集合转数组处理</h4><p>阿里强制规定使用集合转数组的方法，必须使用集合的 toArray(T[] arrays)，传入的是类型完全一样的数组，大小就是 list.size()。使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[list.size()]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。正例如清单 25 所示。</p><p>清单 25 正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="string">&quot;guan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bao&quot;</span>);</span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line">array = list.toArray(array);</span><br></pre></td></tr></table></figure><h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><h4 id="1-方法注释要求"><a href="#1-方法注释要求" class="headerlink" title="1. 方法注释要求"></a>1. 方法注释要求</h4><p>阿里强制要求方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释使用&#x2F;**&#x2F;注释，注意与代码对照。</p><p><strong>我的理解：</strong></p><p>百度规定方法注释采用标准的 Javadoc 注释规范，注释中必须提供方法说明、参数说明及返回值和异常说明。腾讯规定采用 JavaDoc 文档注释，在方法定义之前应该对其进行注释，包括方法的描述、输入、输出以及返回值说明、抛出异常说明、参考链接等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1-数据结构初始化大小"><a href="#1-数据结构初始化大小" class="headerlink" title="1. 数据结构初始化大小"></a>1. 数据结构初始化大小</h4><p>阿里推荐任何数据结构的构造或初始化，都应指定大小，避免数据结构暂时无限增长吃光内存。</p><p><strong>我的理解：</strong></p><p>首先明确一点，阿里这里指的大小具体是指数据结构的最大长度。大部分 Java 集合类在构造时指定的大小都是初始尺寸（initial Capacity），而不是尺寸上限（Capacity），只有几种队列除外，例如 ArrayBlockingQueue、LinkedBlockingQueue，它们在构造时可以指定队列的最大长度。阿里推荐的目的是为了合理规划内存，避免出现 OOM（Out of Memory）异常。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="1-不要捕获-RuntimeException"><a href="#1-不要捕获-RuntimeException" class="headerlink" title="1. 不要捕获 RuntimeException"></a>1. 不要捕获 RuntimeException</h4><p>阿里强制规定 Java 类库中的 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，例如 IndexOutOfBoundsException、NullPointerException 等。</p><p><strong>我的理解：</strong></p><p>RuntimeException，也被称为运行时异常，通常是由于代码中的 bug 引起的，正确的处理方式是去检查代码，通过添加数据长度判断，判断对象是否为空等方法区规避，而不是靠捕获来规避这种异常。</p><h4 id="2-事务中的异常需要回滚"><a href="#2-事务中的异常需要回滚" class="headerlink" title="2. 事务中的异常需要回滚"></a>2. 事务中的异常需要回滚</h4><p>阿里强制规定有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p><strong>我的理解：</strong></p><p>try catch 代码块中对异常的处理，可能会遗漏事务的一致性，当事务控制不使用其他框架管理时，事务需要手动回滚。实际使用如果引入第三方的框架对事务进行管理，比如 Spring，则根据第三方框架的实际实现情况，确定是否有必要手动回滚。当第三方事务管理框架本身就会对于异常进行抛出时需要做事务回滚。例如 Spring 在@Transactional 的 annotation 注解下，会默认开启运行时异常事务回滚。</p><h4 id="3-不能在-finally-块中使用-return"><a href="#3-不能在-finally-块中使用-return" class="headerlink" title="3. 不能在 finally 块中使用 return"></a>3. 不能在 finally 块中使用 return</h4><p>阿里强制要求 finally 块中不使用 return，因为执行完该 return 后方法结束执行，不会再执行 try 块中的 return 语句。</p><p><strong>我的理解：</strong></p><p>在try-catch-finally中, 当return遇到finally，return对finally无效，即:<br>1.在try catch块里return的时候，finally也会被执行。<br>2.finally里的return语句会把try catch块里的return语句效果给覆盖掉。</p><p>return语句并不一定都是函数的出口，执行return时，只是把return后面的值复制了一份到返回值变量里去了。所以在finally有return时，会覆盖掉try-catch中的return。</p><p>finally语句是不是总会被执行？</p><p>答案是否。以下情况finally语句不会执行：</p><ol><li>try语句没有被执行到，如在try语句之前return就返回了，这样finally语句就不会执行。这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。</li><li>在try块|catch块中有System.exit(0);这样的语句。System.exit(0)是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。</li></ol><h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><h4 id="1-不可直接使用日志系统"><a href="#1-不可直接使用日志系统" class="headerlink" title="1. 不可直接使用日志系统"></a>1. 不可直接使用日志系统</h4><p>阿里强制规定应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><p><strong>我的理解：</strong></p><p>SLF4J 即简单日志门面模式，不是具体的日志解决方案，它只服务于各种各样的日志系统。在使用 SLF4J 时不需要指定哪个具体的日志系统，只需要将使用到的具体日志系统的配置文件放到类路径下去。</p><p>正例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;please use SLF4J,rather than logback or log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;please use SLF4J,rather than logback or log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-日志文件保留时间"><a href="#2-日志文件保留时间" class="headerlink" title="2. 日志文件保留时间"></a>2. 日志文件保留时间</h4><p>阿里强制规定日志文件至少保存 15 天，因为有些异常具备以”周”为频次发生的特点。</p><p><strong>我的理解：</strong></p><p>日志保留时间推荐 15 天以上，但是保留时间也不宜过长，一般不超过 21 天，否则造成硬盘空间的浪费。对于一些长周期性执行的逻辑，可以根据实际情况调整该保存时间，同时也需要保证日志能够监控到关键的应用。</p><p>对于长周期执行的逻辑，可以使用特定的 appender，并使用不同的日志清理规则，如时间、大小等。如一月执行一次的定时任务，可以将日志输出到新的日志文件，然后通过大小限定的规则进行清理，并不一定要使用时间清理的逻辑。</p><h3 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h3><h4 id="1-权限控制校验"><a href="#1-权限控制校验" class="headerlink" title="1. 权限控制校验"></a>1. 权限控制校验</h4><p>阿里强制要求对于隶属于用户个人的页面或者功能必须进行权限控制校验。</p><p><strong>我的理解：</strong></p><p>涉及到对于数据的增删改查，必须有权限的控制和校验，要有一个黑白名单的控制，不能依赖于前台页面的简单控制，后台要有对于完整的权限控制的实现。这样就能尽可能地防治数据的错误修改。</p><h4 id="2-用户传入参数校验"><a href="#2-用户传入参数校验" class="headerlink" title="2. 用户传入参数校验"></a>2. 用户传入参数校验</h4><p>阿里强制要求用户请求传入的任何参数必须做有效校验。</p><p><strong>我的理解：</strong></p><p>对于用户输入的任何参数，前端页面上都必须要做一定的有效性校验，并且在数据发送至服务器的时候在页面上给出验证结果提示，那么在用户请求传入的任务参数，后台同样也要对其有效性进行验证，防止前端页面未能过滤或者暂时无法验证的错误参数。忽略参数的验证会导致的问题很多，page size 过大会导致内存溢出、SQL 溢出等，只有验证才能尽可能地减少这些问题的出现，进而减少错误的排查几率。</p><p>所以说在前端已经做了参数校验的情况下，后端也有必要做参数校验。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="1-单元测试应该自动执行"><a href="#1-单元测试应该自动执行" class="headerlink" title="1. 单元测试应该自动执行"></a>1. 单元测试应该自动执行</h4><p>阿里强制单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个号的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p><p><strong>我的理解：</strong></p><p>这条原则比较容易理解。单元测试是整个系统的最小测试单元，针对的是一个类中一个方法的测试，如果这些测试的结果需要人工校验是否正确，那么对于验证人来说是一项痛苦而且耗时的工作。另外，单元测试作为系统最基本的保障，需要在修改代码、编译、打包过程中都会运行测试用例，保障基本功能，自动化的测试是必要条件。其实自动化测试不仅是单元测试特有的，包括集成测试、系统测试等，都在慢慢地转向自动化测试，以降低测试的人力成本。</p><h4 id="2-单元测试应该是独立的"><a href="#2-单元测试应该是独立的" class="headerlink" title="2. 单元测试应该是独立的"></a>2. 单元测试应该是独立的</h4><p>阿里强制保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p><p>反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p><p><strong>我的理解：</strong></p><p>单元测试作为系统的最小测试单元，主要目的是尽可能早地测试编写的代码，降低后续集成测试期间的测试成本，以及在运行测试用例的时候能够快速地定位到对应的代码段并解决相关问题。</p><p>我们假设这么一个场景，method1 方法被 10 个其他 method 方法调用，如果 10 个 method 方法的测试用例都需要依赖 method1，那么当 methdo1 被修改导致运行出错的情况下，会导致 method1 以及依赖它的 10 个 method 的所有测试用例报错，这样就需要排查这 11 个方法到底哪里出了问题，这与单元测试的初衷不符，也会大大的增加排查工作量，所以单元测试必须是独立的，不会因为受到外部修改（这里的修改包括了依赖方法的修改以及外部环境的修改），编写单元测试时遇到的这类依赖可以使用 mock 来模拟输入和期望的返回，这样所以来的方法内部逻辑的变更就不会影响到外部的实现。</p><h4 id="3-BCDE-原则"><a href="#3-BCDE-原则" class="headerlink" title="3. BCDE 原则"></a>3. BCDE 原则</h4><p>阿里推荐编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</p><p><strong>我的理解：</strong></p><p>BCDE 原则逐一解释如下：</p><p>B（Border）：确保参数边界值均被覆盖。</p><p>例如：对于数字，测试负数、0、正数、最小值、最大值、NaN（非数字）、无穷大值等。对于字符串，测试空字符串、单字符、非 ASCII 字符串、多字节字符串等。对于集合类型，测试空、第一个元素、最后一个元素等。对于日期，测试 1 月 1 日、2 月 29 日、12 月 31 日等。被测试的类本身也会暗示一些特定情况下的边界值。对于边界情况的测试一定要详尽。</p><p>C（Connect）：确保输入和输出的正确关联性。</p><p>例如，测试某个时间判断的方法 boolean inTimeZone(Long timeStamp)，该方法根据输入的时间戳判断该事件是否存在于某个时间段内，返回 boolean 类型。如果测试输入的测试数据为 Long 类型的时间戳，对于输出的判断应该是对于 boolean 类型的处理。如果测试输入的测试数据为非 Long 类型数据，对于输出的判断应该是报错信息是否正确。</p><p>D（Design）：任务程序的开发包括单元测试都应该遵循设计文档。</p><p>E（Error）：单元测试包括对各种方法的异常测试，测试程序对异常的响应能力。</p><p>除了这些解释之外，《单元测试之道（Java 版）》这本书里面提到了关于边界测试的 <strong>CORRECT</strong> 原则：</p><p>一致性（Conformance）：值是否符合预期格式（正常的数据），列出所有可能不一致的数据，进行验证。</p><p>有序性（Ordering）：传入的参数的顺序不同的结果是否正确，对排序算法会产生影响，或者是对类的属性赋值顺序不同会不会产生错误。</p><p>区间性（Range）：参数的取值范围是否在某个合理的区间范围内。</p><p>引用&#x2F;耦合性（Reference）：程序依赖外部的一些条件是否已满足。前置条件：系统必须处于什么状态下，该方法才能运行。后置条件，你的方法将会保证哪些状态发生改变。</p><p>存在性（Existence）：参数是否真的存在，引用为 Null，String 为空，数值为 0 或者物理介质不存在时，程序是否能正常运行。</p><p>基数性（Cardinality）：考虑以”0-1-N 原则”，当数值分别为 0、1、N 时，可能出现的结果，其中 N 为最大值。</p><p>时间性（Time）：相对时间指的是函数执行的依赖顺序，绝对时间指的是超时问题、并发问题。</p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="1-建表的是与否规则"><a href="#1-建表的是与否规则" class="headerlink" title="1. 建表的是与否规则"></a>1. 建表的是与否规则</h4><p>阿里强制要求如果遇到需要表达是与否的概念时，必须使用 is_xxx 的方法命令，数据类型是 unsigned tinyint，1 表示是，0 表示否。</p><p>说明：任务字段如果为非负数，必须是 unsigned。</p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p><p><strong>我的理解：</strong></p><p>命名使用 is_xxx 第一个好处是比较清晰的，第二个好处是使用者根据命名就可以知道这个字段的取值范围，也方便做参数验证。</p><p>类型使用 unsigned 的好处是如果只存整数，unsigned 类型有更大的取值范围，可以节约磁盘和内存使用。</p><p>对于表的名字，MySQL 社区有自己推荐的命名规范：</p><p>表包含多个英文单词时，需要用下划线进行单词分割，这一点类似于 Java 类名的命名规范，例如 master_schedule、security_user_permission；<br>由于 InnoDB 存储引擎本身是针对操作系统的可插拔设计的，所以原则上所有的表名组成全部由小写字母组成；<br>不允许出现空格，需要分割一律采用下划线；<br>名字不允许出现数字，仅包含英文字母；<br>名字需要总长度少于 64 个字符。</p><h4 id="2-数据类型精度考量"><a href="#2-数据类型精度考量" class="headerlink" title="2. 数据类型精度考量"></a>2. 数据类型精度考量</h4><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p><p><strong>我的理解：</strong></p><p>我们先来看看各个精度的范围。</p><p>Float：浮点型，4 字节数 32 位，表示数据范围-3.4E38~3.4E38</p><p>Double：双精度型，8 字节数 64 位，表示数据范围-1.7E308~1.7E308</p><p>Decimal：数字型，16 字节数 128 位，不存在精度损失，常用于银行账目计算</p><p>在精确计算中使用浮点数是非常危险的，在对精度要求高的情况下，比如银行账目就需要使用 Decimal 存储数据。</p><p>实际上，所有涉及到数据存储的类型定义，都会涉及数据精度损失问题。Java 的数据类型也存在 float 和 double 精度损失情况，阿里没有指出这条规约，就全文来说，这是一个比较严重的规约缺失。</p><p>Joshua Bloch（著名的 Effective Java 书作者）认为，float 和 double 这两个原生的数据类型本身是为了科学和工程计算设计的，它们本质上都采用单精度算法，也就是说在较宽的范围内快速获得精准数据值。但是，需要注意的是，这两个原生类型都不保证也不会提供很精确的值。单精度和双精度类型特别不适用于货币计算，因为不可能准确地表示 0.1（或者任何其他十的负幂）。</p><p>我们再来看一个实际的例子。假设你有 1 块钱，现在每次购买蛋糕的价格都会递增 0.10 元，为我们一共可以买几块蛋糕。口算一下，应该是 4 块（因为 0.1+0.2+0.3+0.4&#x3D;1.0），我们写个程序验证看看，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方式</span></span><br><span class="line"><span class="type">double</span> <span class="variable">funds1</span> <span class="operator">=</span> <span class="number">1.00</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">itemsBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">.10</span>;funds&gt;=price;price+=<span class="number">.10</span>)&#123;</span><br><span class="line"> funds1 -=price;</span><br><span class="line"> itemsBought++;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(itemsBought+<span class="string">&quot; items boughts.&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;Changes:&quot;</span>+funds1);</span><br><span class="line"> <span class="comment">// 3 items boughts.</span></span><br><span class="line"><span class="comment">// Changes:0.3999999999999999</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//正确的方式</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">BigDecimal</span> <span class="variable">TEN_CENTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;.10&quot;</span>);</span><br><span class="line"> itemsBought = <span class="number">0</span>;</span><br><span class="line"> <span class="type">BigDecimal</span> <span class="variable">funds2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> TEN_CENTS;funds2.compareTo(price)&gt;<span class="number">0</span>;price =</span><br><span class="line"> price.add(TEN_CENTS))&#123;</span><br><span class="line"> fund2 = fund2.substract(price);</span><br><span class="line"> itemsBought++;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(itemsBought+<span class="string">&quot; items boughts.&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;Changes:&quot;</span>+funds2);</span><br><span class="line"><span class="comment">// 4 items boughts.</span></span><br><span class="line"><span class="comment">// Changes:0.00</span></span><br></pre></td></tr></table></figure><p>这里我们可以看到使用了 BigDecimal 解决了问题，实际上 int、long 也可以解决这类问题。采用 BigDecimal 有一个缺点，就是使用过程中没有原始数据这么方便，效率也不高。如果采用 int 方式，最好不要在有小数点的场景下使用，可以在 100、10 这样业务场景下选择使用。</p><h4 id="3-使用-Char"><a href="#3-使用-Char" class="headerlink" title="3. 使用 Char"></a>3. 使用 Char</h4><p>阿里强制要求如果存储的字符串长度几乎相等，使用 Char 定长字符串类型。</p><p><strong>我的理解：</strong></p><p>从性能上分析，character(n)通常是最慢的，在大多数情况下，应该使用 text 或者 character varying。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><h4 id="1-服务间依赖关系"><a href="#1-服务间依赖关系" class="headerlink" title="1. 服务间依赖关系"></a>1. 服务间依赖关系</h4><p>阿里推荐默认上层依赖于下层，箭头关系表示可直接依赖，如：Controller层可以依赖于 Web 层，也可以直接依赖于 Service 层。</p><p><strong>我的理解：</strong></p><p>《软件架构模式》一书中介绍了分层架构思想：</p><p>分层架构是一种很常见的架构模式，它也被叫做 N 层架构。这种架构是大多数 Java EE 应用的实际标准。许多传统 IT 公司的组织架构和分层模式十分的相似，所以它很自然地成为大多数应用的架构模式。</p><p>分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能（展示逻辑或者业务逻辑）。尽管分层架构没有规定自身要分成几层几种，大多数的结构都分成四个层次，即展示层、业务层、持久层和数据库层。业务层和持久层有时候可以合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层的组件当中。因此，有一些小的应用可能只有三层，一些有着更复杂的业务的大应用可能有五层甚至更多的层。</p><p>分层架构中的每一层都有着特定的角色和职能。举个例子，展示层负责所有的界面展示以及交互逻辑，业务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请求。比如说展示层并不关心如何得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关心要展示在屏幕上的用户数据格式，也不关心这些用户数据从哪里来，它只需要从持久层得到数据，执行与数据有关的相应业务逻辑，然后把这些信息传递给展示层。</p><p>分层架构的一个突出特性地组件间关注点分离。一个层中的组件只会处理本层的逻辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。因为有了组件分离设计方式，让我们更容易构造有效的角色和强力的模型，这样应用变得更好开发、测试、管理和维护。</p><h4 id="2-高并发服务器-time-wait"><a href="#2-高并发服务器-time-wait" class="headerlink" title="2. 高并发服务器 time_wait"></a>2. 高并发服务器 time_wait</h4><p>阿里推荐高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><p>说明：操作系统默认 240 秒后才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</p><p>正例：在 Linux 服务器上通过变更&#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout&#x3D;30</p><p><strong>我的理解：</strong></p><p>服务器在处理完客户端的连接后，主动关闭，就会有 time_wait 状态。TCP 连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发 FIN 包的一方执行的是主动关闭，后发 FIN 包的一方执行的是被动关闭。主动关闭的一方会进入 time_wait 状态，并且在此状态停留两倍的 MSL 时长。</p><p>主动关闭的一方收到被动关闭的一方发出的 FIN 包后，回应 ACK 包，同时进入 time_wait 状态，但是因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回就是两倍的 MSL 时长。如果主动关闭的一方跳过 time_wait 直接进入 closed，或者在 time_wait 停留的时长不足两倍的 MSL，那么当被动关闭的一方早于先发出的延迟包达到后，就可能出现类似下面的问题：</p><ol><li><p>旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包</p></li><li><p>新的 TCP 连接被建立起来了，延迟包可能干扰新的连接</p></li></ol><p>不管是哪种情况都会让 TCP 不再可靠，所以 time_wait 状态有存在的必要性。</p><p>修改 net.ipv4.tcp_fin_timeout 也就是修改了 MSL 参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/&quot;&gt;https://developer.ibm.com/zh/articles/deconding-</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="解读阿里巴巴 Java 代码规范" scheme="https://tianxiafeiyu.github.io/tags/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>TCP 协议灵魂 12 问 【转】</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/TCP%20%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82%2012%20%E9%97%AE%20%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/TCP%20%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82%2012%20%E9%97%AE%20%E3%80%90%E8%BD%AC%E3%80%91/</id>
    <published>2022-12-15T23:41:00.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://my.oschina.net/u/4192546/blog/4644900">https://my.oschina.net/u/4192546/blog/4644900</a></p><h3 id="01-能不能说一说-TCP-和-UDP-的区别？"><a href="#01-能不能说一说-TCP-和-UDP-的区别？" class="headerlink" title="01. 能不能说一说 TCP 和 UDP 的区别？"></a>01. 能不能说一说 TCP 和 UDP 的区别？</h3><p>基本区别：</p><p>TCP是一个面向连接的、可靠的、基于字节流的传输层协议。</p><p>而UDP是一个面向无连接的传输层协议。(就这么简单，其它TCP的特性也就没有了)。</p><p>具体分析：</p><p>和 UDP 相比，TCP 有三大核心特性:</p><ol><li><p>面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p></li><li><p>可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。<br>当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。相应的，UDP 就是无状态, 不可控的。</p></li><li><p>面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</p></li></ol><h3 id="02-说说-TCP-三次握手的过程？为什么是三次而不是两次、四次？"><a href="#02-说说-TCP-三次握手的过程？为什么是三次而不是两次、四次？" class="headerlink" title="02. 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？"></a>02. 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</h3><p>TCP 的三次握手，目的是确认双方的两样能力: 发送的能力和接收的能力。</p><ol><li>客户端：“喂，能听到我说话吗”</li><li>服务端：“我能听到，你能听到我吗”</li><li>客户端：“能听到”</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/4085089A13624557A4019F74C06BB727?method=download&shareKey=c1fd86182fb4e46caef87b65223d45db" alt="tcp三次握手"></p><p>从图中可以看出，SYN （同步序列标志 Synchronize Sequence Numbers）是需要消耗一个序列号的，下次发送对应的 ACK（确认标志  Acknowledgement Number） 序列号要加1，为什么呢？只需要记住一个规则:</p><p>凡是需要对端确认的，一定消耗TCP报文的序列号。</p><p>SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。</p><p><strong>为什么不是两次？</strong> 根本原因: 无法确认客户端的接收能力。</p><p>分析如下:</p><p>如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p><p>看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。</p><p>看到问题的吧，这就带来了连接资源的浪费。</p><p><strong>为什么不是四次？</strong> 三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？</p><p>当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。</p><p>三次握手过程中可以携带数据么？ 第三次握手的时候，可以携带。前两次握手不能携带数据。</p><p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p><p>第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p><h3 id="03-说说-TCP-四次挥手的过程"><a href="#03-说说-TCP-四次挥手的过程" class="headerlink" title="03. 说说 TCP 四次挥手的过程"></a>03. 说说 TCP 四次挥手的过程</h3><ol><li>客户端：我好了。</li><li>服务端：收到。</li><li>服务端：我也好了。</li><li>客户端：收到。</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/82900C4A92994B989F6A19895365E10C?method=download&shareKey=46fc8447859229c1b2d41e489b9f4c75" alt="tcp四次挥手"></p><p>需要注意的是，第4步客户端发送确认响应给服务端后，连接并不会马上断开。<strong>客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK</strong>。</p><p><strong>等待2MSL的意义 如果不等待会怎样？</strong></p><p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。</p><p>那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</p><p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端<br>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。<br>为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p><strong>如果是三次挥手会有什么问题？</strong> 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。</p><h3 id="04-说说半连接队列和-SYN-Flood-攻击的关系"><a href="#04-说说半连接队列和-SYN-Flood-攻击的关系" class="headerlink" title="04. 说说半连接队列和 SYN Flood 攻击的关系"></a>04. 说说半连接队列和 SYN Flood 攻击的关系</h3><p>三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。</p><p><strong>半连接队列</strong> 当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。</p><p><strong>全连接队列</strong> 当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</p><p><strong>SYN Flood 攻击原理</strong> SYN Flood 属于典型的 DoS&#x2F;DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:</p><p>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</p><p>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</p><p><strong>如何应对 SYN Flood 攻击？</strong></p><ol><li>增加 SYN 连接，也就是增加半连接队列的容量。</li><li>减少 SYN + ACK 重试次数，避免大量的超时重发。</li><li>利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。</li></ol><h3 id="05-介绍一下-TCP-报文头部的字段"><a href="#05-介绍一下-TCP-报文头部的字段" class="headerlink" title="05. 介绍一下 TCP 报文头部的字段"></a>05. 介绍一下 TCP 报文头部的字段</h3><p>报文头部结构如下(单位为字节):<br><img src="/" alt="TCP 报文头部的字段"></p><p><strong>源端口、目标端口</strong> 如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。</p><p>那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。</p><p><strong>序列号</strong> 即Sequence number, 指的是本报文段第一个字节的序列号。</p><p>从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。</p><p>序列号在 TCP 通信的过程中有两个作用:</p><p>在 SYN 报文中交换彼此的初始序列号。<br>保证数据包按正确的顺序组装。</p><p><strong>ISN</strong> 即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。</p><p>ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？</p><p>如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。</p><p>而动态增长的 ISN 大大提高了猜测 ISN 的难度。</p><p><strong>确认号</strong> 即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。</p><p><strong>标记位</strong> 常见的标记位有SYN,ACK,FIN,RST,PSH。</p><p>SYN 和 ACK 已经在上文说过，后三个解释如下: FIN：即 Finish，表示发送方准备断开连接。</p><p>RST：即 Reset，用来强制断开连接。</p><p>PSH：即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p><p><strong>窗口大小</strong> 占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</p><p><strong>校验和</strong> 占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。</p><p><strong>可选项</strong> 可选项的格式如下: 在这里插入图片描述 常用的可选项有以下几个:</p><ul><li>TimeStamp: TCP 时间戳，后面详细介绍。</li><li>MSS: 指的是 TCP 允许的从对方接收的最大报文段。</li><li>SACK: 选择确认选项。</li><li>Window Scale：窗口缩放选项。</li></ul><h2 id="06-说说-TCP-快速打开的原理-TFO"><a href="#06-说说-TCP-快速打开的原理-TFO" class="headerlink" title="06. 说说 TCP 快速打开的原理(TFO)"></a>06. 说说 TCP 快速打开的原理(TFO)</h2><p>第一节讲了 TCP 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？</p><p>可以啊。今天来说说这个优化后的 TCP 握手流程，也就是 TCP 快速打开(TCP Fast Open, 即TFO)的原理。</p><p>优化的过程是这样的，还记得我们说 SYN Flood 攻击时提到的 SYN Cookie 吗？这个 Cookie 可不是浏览器的Cookie, 用它同样可以实现 TFO。</p><p>TFO 流程</p><p>首轮三次握手 首先客户端发送SYN给服务端，服务端接收到。</p><p>注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。</p><p>客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。</p><p>首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！</p><p>后面的三次握手 在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。</p><p>重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。</p><p>当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。</p><p><img src="/" alt="TCP 快速打开流程"></p><p>注意：客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。</p><p>TFO 的优势 TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。</p><h3 id="07-能不能说说TCP报文中时间戳的作用？"><a href="#07-能不能说说TCP报文中时间戳的作用？" class="headerlink" title="07.  能不能说说TCP报文中时间戳的作用？"></a>07.  能不能说说TCP报文中时间戳的作用？</h3><p>timestamp是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:</p><p>kind(1 字节) + length(1 字节) + info(8 个字节) 其中 kind &#x3D; 8， length &#x3D; 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节。</p><p>那么这些字段都是干嘛的呢？它们用来解决那些问题？</p><p>接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题:</p><ul><li>计算往返时延 RTT(Round-Trip Time)</li><li>防止序列号的回绕问题:<br>  序列号的范围其实是在0 ~ 2 ^ 32 - 1浮动，在一次传输中可能存在相同的序列号报文，这时可用时间戳区分。</li></ul><h3 id="08-TCP-的超时重传时间是如何计算的？"><a href="#08-TCP-的超时重传时间是如何计算的？" class="headerlink" title="08. TCP 的超时重传时间是如何计算的？"></a>08. TCP 的超时重传时间是如何计算的？</h3><p>TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。</p><p>那么这个重传间隔是如何来计算的呢？</p><p>…</p><h3 id="09-能不能说一说-TCP-的流量控制？"><a href="#09-能不能说一说-TCP-的流量控制？" class="headerlink" title="09.  能不能说一说 TCP 的流量控制？"></a>09.  能不能说一说 TCP 的流量控制？</h3><p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。</p><p>而流量控制索要做的事情，就是在通过设置接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p><p>要具体理解流量控制，首先需要了解滑动窗口的概念。</p><p>TCP 滑动窗口 TCP 滑动窗口分为两种: 发送窗口和接收窗口。</p><p>流量控制过程 这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。</p><p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。</p><p>假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。</p><p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。</p><p>注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。</p><p>因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。</p><p>此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。</p><p>这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。</p><h3 id="10-能不能说说-TCP-的拥塞控制？"><a href="#10-能不能说说-TCP-的拥塞控制？" class="headerlink" title="10. 能不能说说 TCP 的拥塞控制？"></a>10. 能不能说说 TCP 的拥塞控制？</h3><p>上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。</p><p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p><ul><li>拥塞窗口（Congestion Window，cwnd）</li><li>慢启动阈值（Slow Start Threshold，ssthresh）</li></ul><p>涉及到的算法有这几个:</p><ul><li>慢启动</li><li>拥塞避免</li><li>快速重传和快速恢复</li></ul><p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。</p><p><strong>拥塞窗口</strong> 拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。</p><p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p><ul><li>接收窗口(rwnd)是接收端给的限制</li><li>拥塞窗口(cwnd)是发送端的限制</li></ul><p>限制谁呢？</p><p>限制的是发送窗口的大小。</p><p>有了这两个窗口，如何来计算发送窗口？</p><p>发送窗口大小 &#x3D; min(rwnd, cwnd) 取两者的较小值。而拥塞控制，就是来控制cwnd的变化。</p><p><strong>慢启动</strong> 刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。</p><p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:</p><p>首先，三次握手，双方宣告自己的接收窗口大小<br>双方初始化自己的拥塞窗口(cwnd)大小<br>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。<br>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！</p><p>在到达阈值后，如何来控制 cwnd 的大小呢？</p><p>这就是拥塞避免做的事情了。</p><p>拥塞避免 原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 &#x2F; cwnd。那你仔细算算，一轮 RTT（往返时延） 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。</p><p>也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。</p><p>当然，慢启动和拥塞避免是一起作用的，是一体的。</p><p><strong>快速重传和快速恢复</strong></p><p><strong>快速重传</strong> 在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。</p><p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。</p><p>这就是快速重传，它解决的是是否需要重传的问题。</p><p><strong>选择性重传</strong> 那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？</p><p>当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。</p><p>在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。</p><p><strong>快速恢复</strong> 当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。</p><p>在这个阶段，发送端如下改变：</p><ul><li>拥塞阈值降低为 cwnd 的一半</li><li>cwnd 的大小变为拥塞阈值</li><li>cwnd 线性增加</li></ul><p>以上就是 TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。</p><h3 id="11-能不能说说-Nagle-算法和延迟确认？"><a href="#11-能不能说说-Nagle-算法和延迟确认？" class="headerlink" title="11. 能不能说说 Nagle 算法和延迟确认？"></a>11. 能不能说说 Nagle 算法和延迟确认？</h3><p>**Nagle 算法 ** 试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。</p><p>而避免小包的频繁发送，这就是 Nagle 算法要做的事情。</p><p>具体来说，Nagle 算法的规则如下:</p><p>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送 后面发送满足下面条件之一就可以发了: 数据包大小达到最大段大小(Max Segment Size, 即 MSS) 之前所有包的 ACK 都已接收到</p><p><strong>延迟确认</strong> 试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？</p><p>延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。</p><p>不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:</p><ul><li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li><li>TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）</li><li>发现了乱序包</li></ul><p><strong>两者一起使用会怎样？</strong> 前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p><h3 id="12-如何理解-TCP-的-keep-alive？"><a href="#12-如何理解-TCP-的-keep-alive？" class="headerlink" title="12. 如何理解 TCP 的 keep-alive？"></a>12. 如何理解 TCP 的 keep-alive？</h3><p>大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。</p><p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。</p><p>这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。</p><p>在 Linux 下，可以这样查看相关的配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -a | grep keepalive</span><br><span class="line"></span><br><span class="line">// 每隔 7200 s 检测一次</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">// 一次最多重传 9 个包</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">// 每个包的间隔重传间隔 75 s</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75</span><br></pre></td></tr></table></figure><p>不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？</p><p>站在应用的角度:</p><ul><li>7200s 也就是两个小时检测一次，时间太长</li><li>时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接</li></ul><p>因此是一个比较尴尬的设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://my.oschina.net/u/4192546/blog/4644900&quot;&gt;https://my.oschina.net/u/4192546/blog/4644900&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;01-能不能说一说-TCP-和</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="os" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/"/>
    
    
    <category term="TCP 协议灵魂 12 问 【转】" scheme="https://tianxiafeiyu.github.io/tags/TCP-%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82-12-%E9%97%AE-%E3%80%90%E8%BD%AC%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>NaN代表什么意思</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</id>
    <published>2022-12-15T23:40:42.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>返回NaN的运算有如下三种：</p><ul><li>至少有一个参数是NaN的运算</li><li>不定式  <ul><li>除法运算：0&#x2F;0、∞&#x2F;∞、∞&#x2F;−∞、−∞&#x2F;∞、−∞&#x2F;−∞  </li><li>乘法运算：0×∞、0×−∞   </li><li>加法运算：∞ + (−∞)、(−∞) + ∞  </li><li>减法运算：∞ - ∞、(−∞) - (−∞)</li></ul></li><li>产生复数结果的实数运算。例如：<br>对负数进行开偶次方的运算<br>对负数进行对数运算<br>对正弦或余弦到达域以外的数进行反正弦或反余弦运算。</li></ul><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul><li>NaN 表示无效数据（超出表示范围、不是有效整数等）</li><li>Perl的BigInt包用“NaN”来表示不含有效整数数据字符串的处理结果</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="NaN代表什么意思" scheme="https://tianxiafeiyu.github.io/tags/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>jsonpath使用心得</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/jsonpath%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/jsonpath%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</id>
    <published>2022-12-15T23:40:42.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>JsonPath表达式通常是用来路径检索或设置Json的。其表达式可以接受“dot–notation”和“bracket–notation”格式，例如$.store.book[0].title、$[‘store’][‘book’][0][‘title’]</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>$</td><td>查询的根节点对象，用于表示一个json数据，可以是数组或对象</td></tr><tr><td>@</td><td>当前节点，类似于this</td></tr><tr><td>*</td><td>通配符，可以表示一个名字或数字</td></tr><tr><td>.<name></td><td>表示一个子节点</td></tr><tr><td>..<name></td><td>深度查询</td></tr><tr><td>[‘<name>’ (, ‘<name>’)]</td><td>一个或多个子节点</td></tr><tr><td>[<number> (, <number>)]</td><td>一个或多个数组下标</td></tr><tr><td>[start:end]</td><td>数组片段，区间为[start,end),不包含end</td></tr><tr><td>[?(<expression>)]</td><td>过滤器表达式，表达式结果必须是boolean</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以在JsonPath表达式执行后进行调用，其输入值为表达式的结果。</p><table><thead><tr><th>名称</th><th>描述</th><th>输出</th></tr></thead><tbody><tr><td>min()</td><td>获取数值类型数组的最小值</td><td>Double</td></tr><tr><td>max()</td><td>获取数值类型数组的最大值</td><td>Double</td></tr><tr><td>avg()</td><td>获取数值类型数组的平均值</td><td>Double</td></tr><tr><td>stddev()</td><td>获取数值类型数组的标准差</td><td>Double</td></tr><tr><td>length()</td><td>获取数值类型数组的长度</td><td>Integer</td></tr></tbody></table><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器是用于过滤数组的逻辑表达式，一个通常的表达式形如：<code>[?(@.age &gt; 18)]</code>，可以通过逻辑表达式&amp;&amp;或||组合多个过滤器表达式，例如 <code>[?(@.price &lt; 10 &amp;&amp; @.category == ‘fiction’)]</code>，字符串必须用单引号或双引号包围，例如 <code>[?(@.color == ‘blue’)] or [?(@.color == “blue”)]</code>。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于符号，但数字1不等于字符1(note that 1 is not equal to ‘1’)</td></tr><tr><td>!&#x3D;</td><td>不等于符号</td></tr><tr><td>&lt;</td><td>小于符号</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于符号</td></tr></tbody></table><blockquote><p>|大于符号<br>&#x3D; |大于等于符号<br>&#x3D;~ |判断是否符合正则表达式，例如[?(@.name &#x3D;~ &#x2F;foo.*?&#x2F;i)]<br>in |所属符号，例如[?(@.size in [‘S’, ‘M’])]<br>nin |排除符号<br>size |size of left (array or string) should match right<br>empty |判空符号</p></blockquote><p>注意：正则过滤 &#x3D;~，貌似是无效的</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;count&quot;: 2,</span><br><span class="line">    &quot;success&quot;: 1,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xiaoxing-y9000p&quot;,</span><br><span class="line">            &quot;cpu&quot;: &quot;i7 12700k&quot;,</span><br><span class="line">            &quot;gpu&quot;: &quot;RTX3080&quot;,</span><br><span class="line">            &quot;price&quot;: 9999</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;xiaomi4&quot;,</span><br><span class="line">            &quot;cpu&quot;: &quot;rz6800h&quot;,</span><br><span class="line">            &quot;gpu&quot;: &quot;RTX3060&quot;,</span><br><span class="line">            &quot;price&quot;: 6999,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json数据是一条接口查询返回</p><ul><li>$.count 获得数据条数</li><li>$.data.name 获取所有电脑名称</li><li>$.data[?(@.price)&gt;9000] 获取价格超过9000的电脑</li></ul><p>python中使用过jsonpath获取json指定数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import jsonpath</span><br><span class="line"></span><br><span class="line">laptop_json = &#x27;&#123;&quot;count&quot;:2,&quot;success&quot;:1,&quot;data&quot;:[&#123;&quot;name&quot;:&quot;xiaoxing-y9000p&quot;,&quot;cpu&quot;:&quot;i7 12700k&quot;,&quot;gpu&quot;:&quot;RTX3080&quot;,&quot;price&quot;:9999&#125;,&#123;&quot;name&quot;:&quot;xiaomi4&quot;,&quot;cpu&quot;:&quot;rz6800h&quot;,&quot;gpu&quot;:&quot;RTX3060&quot;,&quot;price&quot;:6999&#125;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">laptop_data= json.loads(laptop_json)</span><br><span class="line"></span><br><span class="line">names = jsonpath.jsonpath(laptop_data, &quot;$.data.name&quot;)</span><br><span class="line"># [&quot;xiaoxing-y9000p&quot;, &quot;name&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JsonPath表达式通常是用来路径检索或设置Json的。其表达式可以接受“dot–notation”和“bracket–notation”格式，例如$.store.book[0].title、$[‘store’][‘book’][0][‘title’]&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="jsonpath使用心得" scheme="https://tianxiafeiyu.github.io/tags/jsonpath%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>k8s国际化实现</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-15T23:40:42.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>k8s用的是 github.com&#x2F;gosexy&#x2F;gettext&#x2F;go-xgettext 翻译库</p><p>项目中提供shell脚本，通过翻译库自带的 go-xgettext 工具进行词条扫描，生成template.po文件</p><p>不支持增量扫描</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;k8s用的是 github.com&amp;#x2F;gosexy&amp;#x2F;gettext&amp;#x2F;go-xgettext 翻译库&lt;/p&gt;
&lt;p&gt;项目中提供shell脚本，通过翻译库自带的 go-xgettext 工具进行词条扫描，生成template.po文件&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="k8s国际化实现" scheme="https://tianxiafeiyu.github.io/tags/k8s%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>maven使用本地依赖</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/maven%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/maven%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/</id>
    <published>2022-12-15T23:40:30.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/lib/jasperreports-html-component-6.5.0.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="maven使用本地依赖" scheme="https://tianxiafeiyu.github.io/tags/maven%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring 注解</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20%E6%B3%A8%E8%A7%A3/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/Spring%20%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-12-15T23:39:58.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h4><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。</p><h4 id="注解与什么用？"><a href="#注解与什么用？" class="headerlink" title="注解与什么用？"></a>注解与什么用？</h4><ol><li><p>生成文档，通过代码里标识的元数据生成javadoc文档。</p></li><li><p>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</p></li><li><p>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</p></li><li><p>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例</p></li></ol><p>注解和XML的区别：</p><ul><li>注解：是一种分散式的元数据，与源代码紧绑定。</li><li>xml：是一种集中式的元数据，与源代码无绑定</li></ul><h4 id="怎么实现注解？"><a href="#怎么实现注解？" class="headerlink" title="怎么实现注解？"></a>怎么实现注解？</h4><p>1、使用 @interface 定义注解。</p><p>2、通过继承以下注解，实现功能：</p><p> 元注解@Target,@Retention,@Documented,@Inherited </p><p>元注解：</p><ol><li><p>@Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括：</p><ul><li>ElemenetType.CONSTRUCTOR 构造器声明 </li><li>ElemenetType.FIELD 域声明（包括 enum 实例） </li><li>ElemenetType.LOCAL_VARIABLE 局部变量声明 </li><li>ElemenetType.METHOD 方法声明 </li><li>ElemenetType.PACKAGE 包声明 </li><li>ElemenetType.PARAMETER 参数声明 </li><li>ElemenetType.TYPE 类，接口（包括注解类型）或enum声明</li></ul></li><li><p>@Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括：</p><ul><li>RetentionPolicy.SOURCE 注解将被编译器丢弃 </li><li>RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 </li><li>RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。</li></ul></li><li><p>@Documented 将此注解包含在 javadoc 中 </p></li><li><p>@Inherited 允许子类继承父类中的注解</p></li></ol><h4 id="注解工作过程"><a href="#注解工作过程" class="headerlink" title="注解工作过程"></a>注解工作过程</h4><p>以 spring 的 @controller 来当做示例:</p><p>@Controller继承@Component注解的方法，将其以单例的形式放入spring容器，然后spring会通过配置文件中的<a href="context:component-scan">context:component-scan</a>的配置，进行如下操作：</p><ol><li><p>使用asm技术扫描.class文件，并将包含@Component及元注解为@Component的注解@Controller、@Service、@Repository或者其他自定义的的bean注册到beanFactory中，</p></li><li><p>然后spring注册注解处理器。注解处理器是一个在javac编译期处理注解的工具，你可以创建注解处理器并注册，在编译期你创建的处理器以Java代码作为输入，生成文件.java文件作为输出。 </p></li><li><p>实例化处理器，然后将其放到beanPostFactory中，然后我们就可以在类中进行使用了。</p></li><li><p>创建bean时，会自动调用相应的处理器进行处理。</p></li></ol><p>spring @Controller源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.stereotype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Component.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AliasFor 表示别名，它可以注解到自定义注解的两个属性上，表示这两个互为别名，也就是说这两个属性其实同一个含义</p><p>@Component</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.stereotype;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.ElementType;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.RetentionPolicy;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Indexed</span><br><span class="line">public @interface Component &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个注解里面都有一个默认的value()方法，为当前的注解声明一个名字，一般默认为类名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是注解？&quot;&gt;&lt;a href=&quot;#什么是注解？&quot; class=&quot;headerlink&quot; title=&quot;什么是注解？&quot;&gt;&lt;/a&gt;什么是注解？&lt;/h4&gt;&lt;p&gt;注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="Spring 注解" scheme="https://tianxiafeiyu.github.io/tags/Spring-%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dalin blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-13T04:34:58.261Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dalin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/GraphQL%20%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/12/13/开发笔记/GraphQL 入门/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphQL-入门"><a href="#GraphQL-入门" class="headerlink" title="GraphQL 入门"></a>GraphQL 入门</h2><p>GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。</p><p>一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是 me，这个用户的名称可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  me: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID</span><br><span class="line">  name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一并的还有每个类型上字段的解析函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Query_me(request) &#123;</span><br><span class="line">  return request.auth.user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User_name(user) &#123;</span><br><span class="line">  return user.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL 上），它就能接收 GraphQL 查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然后运行指定的解析函数来生成结果。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  me &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;me&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GraphQL-的查询和变更"><a href="#GraphQL-的查询和变更" class="headerlink" title="GraphQL 的查询和变更"></a>GraphQL 的查询和变更</h2><h4 id="字段（Fields）"><a href="#字段（Fields）" class="headerlink" title="字段（Fields）"></a>字段（Fields）</h4><p>简单而言，GraphQL 是关于请求对象上的特定字段。我们以一个非常简单的查询以及其结果为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询和其结果拥有几乎一样的结构。这是 GraphQL 最重要的特性，因为这样一来，你就总是能得到你想要的数据，而服务器也准确地知道客户端请求的字段。</p><p><code>name</code> 字段返回 <code>String</code> 类型，在这个示例中是《星球大战》主角的名字是：<code>&quot;R2-D2&quot;</code>。</p><p>前一例子中，我们请求了我们主角的名字，返回了一个字符串类型（String），但是字段也能指代对象类型（Object）。这个时候，你可以对这个对象的字段进行次级选择（sub-selection）。GraphQL 查询能够遍历相关对象及其字段，使得客户端可以一次请求查询大量相关数据，而不像传统 REST 架构中那样需要多次往返查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    # 查询可以有备注！</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，friends 返回了一个数组的项目，GraphQL 查询会同等看待单个项目或者一个列表的项目，然而我们可以通过 schema 所指示的内容来预测将会得到哪一种。</p><h4 id="参数（Arguments）"><a href="#参数（Arguments）" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h4><p>即使我们能做的仅仅是遍历对象及其字段，GraphQL 就已经是一个非常有用的数据查询语言了。但是当你加入给字段传递参数的能力时，事情会变得更加有趣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  human(id: &quot;1000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    height</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;human&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;height&quot;: 1.72</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数可以是多种不同的类型。上面例子中，我们使用了一个枚举类型，其代表了一个有限选项集合（本例中为长度单位，即是 METER 或者 FOOT）。GraphQL 自带一套默认类型，但是 GraphQL 服务器可以声明一套自己的定制类型，只要能序列化成你的传输格式即可。</p><p><a href="https://graphql.cn/learn/schema">更多的 GraphQL 类型系统请点击这里</a></p><h4 id="别名（Aliases）"><a href="#别名（Aliases）" class="headerlink" title="别名（Aliases）"></a>别名（Aliases）</h4><p>如果你眼睛够锐利，你可能已经发现，即便结果中的字段与查询中的字段能够匹配，但是因为他们并不包含参数，你就没法通过不同参数来查询相同字段。这便是为何你需要别名 —— 这可以让你重命名结果中的字段为任意你想到的名字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  empireHero: hero(episode: EMPIRE) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  jediHero: hero(episode: JEDI) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;empireHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;jediHero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，两个 hero 字段将会存在冲突，但是因为我们可以将其另取一个别名，我们也就可以在一次请求中得到两个结果。</p><h4 id="片段（Fragments）"><a href="#片段（Fragments）" class="headerlink" title="片段（Fragments）"></a>片段（Fragments）</h4><p>假设我们的 app 有比较复杂的页面，将正反派主角及其友军分为两拨。你立马就能想到对应的查询会变得复杂，因为我们需要将一些字段重复至少一次 —— 两方各一次以作比较。</p><p>这就是为何 GraphQL 包含了称作片段的可复用单元。片段使你能够组织一组字段，然后在需要它们的的地方引入。下面例子展示了如何使用片段解决上述场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  appearsIn</span><br><span class="line">  friends &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ],</span><br><span class="line">      &quot;friends&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到上面的查询如何漂亮地重复了字段。片段的概念经常用于将复杂的应用数据需求分割成小块，特别是你要将大量不同片段的 UI 组件组合成一个初始数据获取的时候。</p><p>在片段内使用变量 </p><p>片段可以访问查询或变更中声明的变量。详见 <a href="https://graphql.cn/learn/queries/#variables">变量</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query HeroComparison($first: Int = 3) &#123;</span><br><span class="line">  leftComparison: hero(episode: EMPIRE) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">  rightComparison: hero(episode: JEDI) &#123;</span><br><span class="line">    ...comparisonFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment comparisonFields on Character &#123;</span><br><span class="line">  name</span><br><span class="line">  friendsConnection(first: $first) &#123;</span><br><span class="line">    totalCount</span><br><span class="line">    edges &#123;</span><br><span class="line">      node &#123;</span><br><span class="line">        name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;leftComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 4,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;rightComparison&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;friendsConnection&quot;: &#123;</span><br><span class="line">        &quot;totalCount&quot;: 3,</span><br><span class="line">        &quot;edges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Luke Skywalker&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;node&quot;: &#123;</span><br><span class="line">              &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h4><p>目前为止，我们将参数写在了查询字符串内。但是在很多应用中，字段的参数可能是动态的：例如，可能是一个”下拉菜单”让你选择感兴趣的《星球大战》续集，或者是一个搜索区，或者是一组过滤器。</p><p>将这些动态参数直接传进查询字符串并不是好主意，因为这样我们的客户端就得动态地在运行时操作这些查询字符串了，再把它序列化成 GraphQL 专用的格式。其实，GraphQL 拥有一级方法将动态值提取到查询之外，然后作为分离的字典传进去。这些动态值即称为变量。</p><p>使用变量之前，我们得做三件事：</p><ol><li>使用 <code>$variableName</code> 替代查询中的静态值。</li><li>声明 <code>$variableName</code> 为查询接受的变量之一。</li><li>将 <code>variableName: value</code> 通过传输专用（通常是 JSON）的分离的变量字典中。</li></ol><p>全部做完之后就像这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># &#123; &quot;graphiql&quot;: true, &quot;variables&quot;: &#123; &quot;episode&quot;: JEDI &#125; &#125;</span><br><span class="line">query HeroNameAndFriends($episode: Episode) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们的客户端代码就只需要传入不同的变量，而不用构建一个全新的查询了。这事实上也是一个良好实践，意味着查询的参数将是动态的 —— 我们决不能使用用户提供的值来字符串插值以构建查询。</p><h4 id="变量定义（Variable-definitions）"><a href="#变量定义（Variable-definitions）" class="headerlink" title="变量定义（Variable definitions）"></a>变量定义（Variable definitions）</h4><p>变量定义看上去像是上述查询中的 ($episode: Episode)。其工作方式跟类型语言中函数的参数定义一样。它以列出所有变量，变量前缀必须为 $，后跟其类型，本例中为 Episode。</p><p>所有声明的变量都必须是标量、枚举型或者输入对象类型。所以如果想要传递一个复杂对象到一个字段上，你必须知道服务器上其匹配的类型。可以从Schema页面了解更多关于输入对象类型的信息。</p><p>变量定义可以是可选的或者必要的。上例中，Episode 后并没有 !，因此其是可选的。但是如果你传递变量的字段要求非空参数，那变量一定是必要的。</p><p>如果想要进一步了解变量定义的句法，可以学习 GraphQL 的 schema 语言。schema 语言在 Schema 中有细述。</p><h4 id="默认变量（Default-variables）"><a href="#默认变量（Default-variables）" class="headerlink" title="默认变量（Default variables）"></a>默认变量（Default variables）</h4><p>可以通过在查询中的类型定义后面附带默认值的方式，将默认值赋给变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query HeroNameAndFriends($episode: Episode = &quot;JEDI&quot;) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有变量都有默认值的时候，你可以不传变量直接调用查询。如果任何变量作为变量字典的部分传递了，它将覆盖其默认值。</p><h4 id="指令（Directives）"><a href="#指令（Directives）" class="headerlink" title="指令（Directives）"></a>指令（Directives）</h4><p>我们上面讨论的变量使得我们可以避免手动字符串插值构建动态查询。传递变量给参数解决了一大堆这样的问题，但是我们可能也需要一个方式使用变量动态地改变我们查询的结构。譬如我们假设有个 UI 组件，其有概括视图和详情视图，后者比前者拥有更多的字段。</p><p>我们来构建一个这种组件的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query Hero($episode: Episode, $withFriends: Boolean!) &#123;</span><br><span class="line">  hero(episode: $episode) &#123;</span><br><span class="line">    name</span><br><span class="line">    friends @include(if: $withFriends) &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;episode&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;withFriends&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试修改上面的变量，传递 true 给 withFriends，看看结果的变化。</p><p>我们用了 GraphQL 中一种称作指令的新特性。一个指令可以附着在字段或者片段包含的字段上，然后以任何服务端期待的方式来改变查询的执行。GraphQL 的核心规范包含两个指令，其必须被任何规范兼容的 GraphQL 服务器实现所支持：</p><ul><li>@include(if: Boolean) 仅在参数为 true 时，包含此字段。</li><li>@skip(if: Boolean) 如果参数为 true，跳过此字段。</li></ul><p>指令在你不得不通过字符串操作来增减查询的字段时解救你。服务端实现也可以定义新的指令来添加新的特性。</p><h4 id="变更（Mutations）"><a href="#变更（Mutations）" class="headerlink" title="变更（Mutations）"></a>变更（Mutations）</h4><p>GraphQL 的大部分讨论集中在数据获取，但是任何完整的数据平台也都需要一个改变服务端数据的方法。</p><p>REST 中，任何请求都可能最后导致一些服务端副作用，但是约定上建议不要使用 GET 请求来修改数据。GraphQL 也是类似 —— 技术上而言，任何查询都可以被实现为导致数据写入。然而，建一个约定来规范任何导致写入的操作都应该显式通过变更（mutation）来发送。</p><p>就如同查询一样，如果任何变更字段返回一个对象类型，你也能请求其嵌套字段。获取一个对象变更后的新状态也是十分有用的。我们来看看一个变更例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>createReview</code> 字段如何返回了新建的 <code>review</code> 的 <code>stars</code> 和 <code>commentary</code> 字段。这在变更已有数据时特别有用，例如，当一个字段自增的时候，我们可以在一个请求中变更并查询这个字段的新值。</p><p>你也可能注意到，这个例子中，我们传递的 review 变量并非标量。它是一个输入对象类型，一种特殊的对象类型，可以作为参数传递。你可以在 Schema 页面上了解到更多关于输入类型的信息。</p><h5 id="变更中的多个字段（Multiple-fields-in-mutations）"><a href="#变更中的多个字段（Multiple-fields-in-mutations）" class="headerlink" title="变更中的多个字段（Multiple fields in mutations）"></a>变更中的多个字段（Multiple fields in mutations）</h5><p>一个变更也能包含多个字段，一如查询。查询和变更之间名称之外的一个重要区别是：</p><p>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</p><p>这意味着如果我们一个请求中发送了两个 incrementCredits 变更，第一个保证在第二个之前执行，以确保我们不会出现竞态。</p><h4 id="内联片段（Inline-Fragments）"><a href="#内联片段（Inline-Fragments）" class="headerlink" title="内联片段（Inline Fragments）"></a>内联片段（Inline Fragments）</h4><p>跟许多类型系统一样，GraphQL schema 也具备定义接口和联合类型的能力。在 <a href="https://graphql.cn/learn/schema/#interfaces">schema 指南中可了解更多</a>。</p><p>如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用内联片段来取出下层具体类型的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询中，<code>hero</code> 字段返回 <code>Character</code> 类型，取决于 <code>episode</code> 参数，其可能是 <code>Human</code> 或者 <code>Droid</code> 类型。在直接选择的情况下，你只能请求 <code>Character</code> 上存在的字段，譬如 <code>name</code>。</p><p>如果要请求具体类型上的字段，你需要使用一个类型条件内联片段。因为第一个片段标注为 <code>... on Droid</code>，<code>primaryFunction</code> 仅在 <code>hero</code> 返回的 <code>Character</code> 为 <code>Droid</code> 类型时才会执行。同理适用于 <code>Human</code> 类型的 <code>height</code> 字段。</p><p>具名片段也可以用于同样的情况，因为具名片段总是附带了一个类型。</p><h4 id="元字段（Meta-fields）"><a href="#元字段（Meta-fields）" class="headerlink" title="元字段（Meta fields）"></a>元字段（Meta fields）</h4><p>某些情况下，你并不知道你将从 GraphQL 服务获得什么类型，这时候你就需要一些方法在客户端来决定如何处理这些数据。GraphQL 允许你在查询的任何位置请求 __typename，一个元字段，以获得那个位置的对象类型名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的查询中，search 返回了一个联合类型，其可能是三种选项之一。没有 __typename 字段的情况下，几乎不可能在客户端分辨开这三个不同的类型。</p><p>GraphQL 服务提供了不少元字段，剩下的部分用于描述 内省 系统。</p><h2 id="Schema-和类型"><a href="#Schema-和类型" class="headerlink" title="Schema 和类型"></a>Schema 和类型</h2><p>在本节中，，你将学到关于 GraphQL 类型系统中所有你需要了解的知识，以及类型系统如何描述可以查询的数据。因为 GraphQL 可以运行在任何后端框架或者编程语言之上，我们将摒除实现上的细节而仅仅专注于其概念。</p><h4 id="类型系统（Type-System）"><a href="#类型系统（Type-System）" class="headerlink" title="类型系统（Type System）"></a>类型系统（Type System）</h4><p>如果你之前见到过 GraphQL 查询，你就知道 GraphQL 查询语言基本上就是关于选择对象上的字段。因此，例如在下列查询中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们以一个特殊的对象 “root” 开始</li><li>选择其上的 hero 字段</li><li>对于 hero 返回的对象，我们选择 name 和 appearsIn 字段</li></ol><p>因为一个 GraphQL 查询的结构和结果非常相似，因此即便不知道服务器的情况，你也能预测查询会返回什么结果。但是一个关于我们所需要的数据的确切描述依然很有意义，我们能选择什么字段？服务器会返回哪种对象？这些对象下有哪些字段可用？这便是引入 schema 的原因。</p><p>每一个 GraphQL 服务都会定义一套类型，用以描述你可能从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询。</p><h4 id="类型语言（Type-Language）"><a href="#类型语言（Type-Language）" class="headerlink" title="类型语言（Type Language）"></a>类型语言（Type Language）</h4><p>GraphQL 服务可以用任何语言编写，因为我们并不依赖于任何特定语言的句法句式（譬如 JavaScript）来与 GraphQL schema 沟通，我们定义了自己的简单语言，称之为 “GraphQL schema language” —— 它和 GraphQL 的查询语言很相似，让我们能够和 GraphQL schema 之间可以无语言差异地沟通。</p><h4 id="对象类型和字段（Object-Types-and-Fields）"><a href="#对象类型和字段（Object-Types-and-Fields）" class="headerlink" title="对象类型和字段（Object Types and Fields）"></a>对象类型和字段（Object Types and Fields）</h4><p>一个 GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段。使用 GraphQL schema language，我们可以这样表示它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这语言可读性相当好，但我们还是一起看看其用语，以便我们可以有些共通的词汇：</p><ul><li>Character 是一个 GraphQL 对象类型，表示其是一个拥有一些字段的类型。你的 schema 中的大多数类型都会是对象类型。</li><li>name 和 appearsIn 是 Character 类型上的字段。这意味着在一个操作 Character 类型的 GraphQL 查询中的任何部分，都只能出现 name 和 appearsIn 字段。</li><li>String 是内置的标量类型之一 —— 标量类型是解析到单个标量对象的类型，无法在查询中对它进行次级选择。后面我们将细述标量类型。</li><li>String! 表示这个字段是非空的，GraphQL 服务保证当你查询这个字段后总会给你返回一个值。在类型语言里面，我们用一个感叹号来表示这个特性。</li><li>[Episode!]! 表示一个 Episode 数组。因为它也是非空的，所以当你查询 appearsIn 字段的时候，你也总能得到一个数组（零个或者多个元素）。且由于 Episode! 也是非空的，你总是可以预期到数组中的每个项目都是一个 Episode 对象。</li></ul><p>现在你知道一个 GraphQL 对象类型看上去是怎样，也知道如何阅读基础的 GraphQL 类型语言了。</p><h4 id="参数（Arguments）-1"><a href="#参数（Arguments）-1" class="headerlink" title="参数（Arguments）"></a>参数（Arguments）</h4><p>GraphQL 对象类型上的每一个字段都可能有零个或者多个参数，例如下面的 length 字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Starship &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  length(unit: LengthUnit = METER): Float</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有参数都是具名的，不像 JavaScript 或者 Python 之类的语言，函数接受一个有序参数列表，而在 GraphQL 中，所有参数必须具名传递。本例中，length 字段定义了一个参数，unit。</p><p>参数可能是必选或者可选的，当一个参数是可选的，我们可以定义一个默认值 —— 如果 unit 参数没有传递，那么它将会被默认设置为 METER。</p><h4 id="查询和变更类型（The-Query-and-Mutation-Types）"><a href="#查询和变更类型（The-Query-and-Mutation-Types）" class="headerlink" title="查询和变更类型（The Query and Mutation Types）"></a>查询和变更类型（The Query and Mutation Types）</h4><p>你的 schema 中大部分的类型都是普通对象类型，但是一个 schema 内有两个特殊类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 GraphQL 服务都有一个 query 类型，可能有一个 mutation 类型。这两个类型和常规对象类型无差，但是它们之所以特殊，是因为它们定义了每一个 GraphQL 查询的入口。因此如果你看到一个像这样的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  droid(id: &quot;2000&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;droid&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;C-3PO&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那表示这个 GraphQL 服务需要一个 Query 类型，且其上有 hero 和 droid 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  hero(episode: Episode): Character</span><br><span class="line">  droid(id: ID!): Droid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变更也是类似的工作方式 —— 你在 Mutation 类型上定义一些字段，然后这些字段将作为 mutation 根字段使用，接着你就能在你的查询中调用。</p><p>有必要记住的是，除了作为 schema 的入口，Query 和 Mutation 类型与其它 GraphQL 对象类型别无二致，它们的字段也是一样的工作方式。</p><h4 id="标量类型（Scalar-Types）"><a href="#标量类型（Scalar-Types）" class="headerlink" title="标量类型（Scalar Types）"></a>标量类型（Scalar Types）</h4><p>一个对象类型有自己的名字和字段，而某些时候，这些字段必然会解析到具体数据。这就是标量类型的来源：它们表示对应 GraphQL 查询的叶子节点。</p><p>下列查询中，name 和 appearsIn 字段将解析到标量类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  hero &#123;</span><br><span class="line">    name</span><br><span class="line">    appearsIn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;appearsIn&quot;: [</span><br><span class="line">        &quot;NEWHOPE&quot;,</span><br><span class="line">        &quot;EMPIRE&quot;,</span><br><span class="line">        &quot;JEDI&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道这些字段没有任何次级字段 —— 因为让它们是查询的叶子节点。</p><p>GraphQL 自带一组默认标量类型：</p><ul><li>Int：有符号 32 位整数。</li><li>Float：有符号双精度浮点值。</li><li>String：UTF‐8 字符序列。</li><li>Boolean：true 或者 false。</li><li>ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。</li></ul><p>大部分的 GraphQL 服务实现中，都有自定义标量类型的方式。例如，我们可以定义一个 Date 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scalar Date</span><br></pre></td></tr></table></figure><p>然后就取决于我们的实现中如何定义将其序列化、反序列化和验证。例如，你可以指定 Date 类型应该总是被序列化成整型时间戳，而客户端应该知道去要求任何 date 字段都是这个格式。</p><h4 id="枚举类型（Enumeration-Types）"><a href="#枚举类型（Enumeration-Types）" class="headerlink" title="枚举类型（Enumeration Types）"></a>枚举类型（Enumeration Types）</h4><p>也称作枚举（enum），枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内。这让你能够：</p><ol><li>验证这个类型的任何参数是可选值的的某一个</li><li>与类型系统沟通，一个字段总是一个有限值集合的其中一个值。</li></ol><p>下面是一个用 GraphQL schema 语言表示的 enum 定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Episode &#123;</span><br><span class="line">  NEWHOPE</span><br><span class="line">  EMPIRE</span><br><span class="line">  JEDI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示无论我们在 schema 的哪处使用了 Episode，都可以肯定它返回的是 NEWHOPE、EMPIRE 和 JEDI 之一。</p><p>注意，各种语言实现的 GraphQL 服务会有其独特的枚举处理方式。对于将枚举作为一等公民的语言，它的实现就可以利用这个特性；而对于像 JavaScript 这样没有枚举支持的语言，这些枚举值可能就被内部映射成整数值。当然，这些细节都不会泄漏到客户端，客户端会根据字符串名称来操作枚举值。</p><h4 id="列表和非空（Lists-and-Non-Null）"><a href="#列表和非空（Lists-and-Non-Null）" class="headerlink" title="列表和非空（Lists and Non-Null）"></a>列表和非空（Lists and Non-Null）</h4><p>对象类型、标量以及枚举是 GraphQL 中你唯一可以定义的类型种类。但是当你在 schema 的其他部分使用这些类型时，或者在你的查询变量声明处使用时，你可以给它们应用额外的类型修饰符来影响这些值的验证。我们先来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Character &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处我们使用了一个 String 类型，并通过在类型名后面添加一个感叹号!将其标注为非空。这表示我们的服务器对于这个字段，总是会返回一个非空值，如果它结果得到了一个空值，那么事实上将会触发一个 GraphQL 执行错误，以让客户端知道发生了错误。</p><p>非空类型修饰符也可以用于定义字段上的参数，如果这个参数上传递了一个空值（不管通过 GraphQL 字符串还是变量），那么会导致服务器返回一个验证错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query DroidById($id: ID!) &#123;</span><br><span class="line">  droid(id: $id) &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Variable \&quot;$id\&quot; of required type \&quot;ID!\&quot; was not provided.&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 1,</span><br><span class="line">          &quot;column&quot;: 17</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列表的运作方式也类似：我们也可以使用一个类型修饰符来标记一个类型为 List，表示这个字段会返回这个类型的数组。在 GraphQL schema 语言中，我们通过将类型包在方括号（[ 和 ]）中的方式来标记列表。列表对于参数也是一样的运作方式，验证的步骤会要求对应值为数组。</p><p>非空和列表修饰符可以组合使用。例如你可以要求一个非空字符串的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String!]</span><br></pre></td></tr></table></figure><p>这表示数组本身可以为空，但是其不能有任何空值成员。用 JSON 举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: null // 有效</span><br><span class="line">myField: [] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, &#x27;b&#x27;] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, null, &#x27;b&#x27;] // 错误</span><br></pre></td></tr></table></figure><p>然后，我们来定义一个不可为空的字符串数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myField: [String]!</span><br></pre></td></tr></table></figure><p>这表示数组本身不能为空，但是其可以包含空值成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myField: null // 错误</span><br><span class="line">myField: [] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, &#x27;b&#x27;] // 有效</span><br><span class="line">myField: [&#x27;a&#x27;, null, &#x27;b&#x27;] // 有效</span><br></pre></td></tr></table></figure><p>你可以根据需求嵌套任意层非空和列表修饰符。</p><h4 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h4><p>跟许多类型系统一样，GraphQL 支持接口。一个接口是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口。</p><p>例如，你可以用一个 Character 接口用以表示《星球大战》三部曲中的任何角色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着任何实现 Character 的类型都要具有这些字段，并有对应参数和返回类型。</p><p>例如，这里有一些可能实现了 Character 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Human implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  starships: [Starship]</span><br><span class="line">  totalCredits: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Droid implements Character &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  friends: [Character]</span><br><span class="line">  appearsIn: [Episode]!</span><br><span class="line">  primaryFunction: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这两个类型都具备 Character 接口的所有字段，但也引入了其他的字段 totalCredits、starships 和 primaryFunction，这都属于特定的类型的角色。</p><p>当你要返回一个对象或者一组对象，特别是一组不同的类型时，接口就显得特别有用。</p><p>注意下面例子的查询会产生错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    primaryFunction</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;message&quot;: &quot;Cannot query field \&quot;primaryFunction\&quot; on type \&quot;Character\&quot;. Did you mean to use an inline fragment on \&quot;Droid\&quot;?&quot;,</span><br><span class="line">      &quot;locations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;line&quot;: 4,</span><br><span class="line">          &quot;column&quot;: 5</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hero 字段返回 Character 类型，取决于 episode 参数，它可能是 Human 或者 Droid 类型。上面的查询中，你只能查询 Character 接口中存在的字段，而其中并不包含 primaryFunction。</p><p>如果要查询一个只存在于特定对象类型上的字段，你需要使用内联片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">query HeroForEpisode($ep: Episode!) &#123;</span><br><span class="line">  hero(episode: $ep) &#123;</span><br><span class="line">    name</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;hero&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;R2-D2&quot;,</span><br><span class="line">      &quot;primaryFunction&quot;: &quot;Astromech&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在查询指南的 <a href="https://graphql.cn/learn/queries/#inline-fragments">内联片段</a> 章节了解更多相关信息。</p><h4 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h4><p>联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union SearchResult = Human | Droid | Starship</span><br></pre></td></tr></table></figure><p>在我们的schema中，任何返回一个 SearchResult 类型的地方，都可能得到一个 Human、Droid 或者 Starship。注意，联合类型的成员需要是具体对象类型；你不能使用接口或者其他联合类型来创造一个联合类型。</p><p>这时候，如果你需要查询一个返回 SearchResult 联合类型的字段，那么你得使用条件片段才能查询任意字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      name</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      name</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;search&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Han Solo&quot;,</span><br><span class="line">        &quot;height&quot;: 1.8</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Human&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Leia Organa&quot;,</span><br><span class="line">        &quot;height&quot;: 1.5</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;__typename&quot;: &quot;Starship&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;TIE Advanced x1&quot;,</span><br><span class="line">        &quot;length&quot;: 9.2</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_typename 字段解析为 String，它允许你在客户端区分不同的数据类型。</p><p>此外，在这种情况下，由于 Human 和 Droid 共享一个公共接口（Character），你可以在一个地方查询它们的公共字段，而不必在多个类型中重复相同的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  search(text: &quot;an&quot;) &#123;</span><br><span class="line">    __typename</span><br><span class="line">    ... on Character &#123;</span><br><span class="line">      name</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Human &#123;</span><br><span class="line">      height</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Droid &#123;</span><br><span class="line">      primaryFunction</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Starship &#123;</span><br><span class="line">      name</span><br><span class="line">      length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 name 仍然需要指定在 Starship 上，否则它不会出现在结果中，因为 Starship 并不是一个 Character！</p><h4 id="输入类型（Input-Types）"><a href="#输入类型（Input-Types）" class="headerlink" title="输入类型（Input Types）"></a>输入类型（Input Types）</h4><p>目前为止，我们只讨论过将例如枚举和字符串等标量值作为参数传递给字段，但是你也能很容易地传递复杂对象。这在变更（mutation）中特别有用，因为有时候你需要传递一整个对象作为新建对象。在 GraphQL schema language 中，输入对象看上去和常规对象一模一样，除了关键字是 input 而不是 type：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input ReviewInput &#123;</span><br><span class="line">  stars: Int!</span><br><span class="line">  commentary: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样在变更（mutation）中使用输入对象类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123;</span><br><span class="line">  createReview(episode: $ep, review: $review) &#123;</span><br><span class="line">    stars</span><br><span class="line">    commentary</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ep&quot;: &quot;JEDI&quot;,</span><br><span class="line">  &quot;review&quot;: &#123;</span><br><span class="line">    &quot;stars&quot;: 5,</span><br><span class="line">    &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createReview&quot;: &#123;</span><br><span class="line">      &quot;stars&quot;: 5,</span><br><span class="line">      &quot;commentary&quot;: &quot;This is a great movie!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入对象类型上的字段本身也可以指代输入对象类型，但是你不能在你的 schema 混淆输入和输出类型。输入对象类型的字段当然也不能拥有参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GraphQL-入门&quot;&gt;&lt;a href=&quot;#GraphQL-入门&quot; class=&quot;headerlink&quot; title=&quot;GraphQL 入门&quot;&gt;&lt;/a&gt;GraphQL 入门&lt;/h2&gt;&lt;p&gt;GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/REST%E9%A3%8E%E6%A0%BC%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/12/13/开发笔记/REST风格理解/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.jianshu.com/p/6e8381c9b01d">https://www.jianshu.com/p/6e8381c9b01d</a></p><h4 id="一、什么是REST"><a href="#一、什么是REST" class="headerlink" title="一、什么是REST"></a>一、什么是REST</h4><p>一句话来概括RESTful API(具有REST风格的API): 用URL定位资源，用HTTP动词（GET,HEAD,POST,PUT,PATCH,DELETE）描述操作，用响应状态码表示操作结果。</p><p>REST是一种软件架构风格，或者说是一种规范，其强调HTTP应当以资源为中心，并且规范了URI的风格；规范了HTTP请求动作（GET&#x2F;PUT&#x2F;POST&#x2F;DELETE&#x2F;HEAD&#x2F;OPTIONS）的使用，具有对应的语义。 核心概念包括：</p><h4 id="资源（Resource）："><a href="#资源（Resource）：" class="headerlink" title="资源（Resource）："></a>资源（Resource）：</h4><p>在REST中，资源可以简单的理解为URI，表示一个网络实体。比如，&#x2F;users&#x2F;1&#x2F;name，对应id&#x3D;1的用户的属性name。既然资源是URI，就会具有以下特征：名词，代表一个资源；它对应唯一的一个资源，是资源的地址。</p><h4 id="表现（Representation）："><a href="#表现（Representation）：" class="headerlink" title="表现（Representation）："></a>表现（Representation）：</h4><p>资源呈现出来的形式，比如上述URI返回的HTML或JSON，包括HTTP Header等；  REST是一个无状态的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布REST服务，客户端通过URL来定位这些资源并通过HTTP协议来访问它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自 &lt;a href=&quot;https://www.jianshu.com/p/6e8381c9b01d&quot;&gt;https://www.jianshu.com/p/6e8381c9b01d&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、什么是REST&quot;&gt;&lt;a href=&quot;#一、什么是RES
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/dalin%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2022/12/13/开发笔记/dalin的服务器配置记录/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>阿里云上重新买了台穷鬼t5，菜是菜了点，但是该折腾还是要折腾的。。。</p><h2 id="设置虚拟内存"><a href="#设置虚拟内存" class="headerlink" title="设置虚拟内存"></a>设置虚拟内存</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>free -m</code> 查看内存状态, <code>Swap</code> 的值都是0，说明还没有安装虚拟内存</p><p>在 &#x2F;opt 下创建虚拟内存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=/opt/swap bs=2048 count=2048000</span><br></pre></td></tr></table></figure><p>将swap文件设置为swap分区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 /opt/swap    //注意更改swap文件的权限</span><br><span class="line">mkswap /opt/swap</span><br></pre></td></tr></table></figure><p>激活swap,启用分区交换文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /opt/swap</span><br></pre></td></tr></table></figure><p>查看结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 opt]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1829        1329         169           0         330         357</span><br><span class="line">Swap:          3999         429        3570</span><br></pre></td></tr></table></figure><p>重启自动启用设置，否则机器重启后分区就失效了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure><p>底部添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /home/swap</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>停止swap分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff /opt/swap</span><br></pre></td></tr></table></figure><p>删除掉swap文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /opt/swap</span><br></pre></td></tr></table></figure><p>查看磁盘情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 opt]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        900M     0  900M   0% /dev</span><br><span class="line">tmpfs           915M     0  915M   0% /dev/shm</span><br><span class="line">tmpfs           915M  612K  915M   1% /run</span><br><span class="line">tmpfs           915M     0  915M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1        40G  9.5G   31G  24% /</span><br><span class="line">tmpfs           183M     0  183M   0% /run/user/1000</span><br><span class="line">overlay          40G  9.5G   31G  24% /var/lib/docker/overlay2/cb6202d7408b52de4ca486b57263e33e6dbb34d3adf35e86bfdffe62b9d33339/merged</span><br><span class="line">overlay          40G  9.5G   31G  24% /var/lib/docker/overlay2/25f9d8b78fa8906f7b379efce90fdd90f8e5771399f537988cf15ca450641596/merged</span><br></pre></td></tr></table></figure><h2 id="mysql-安装"><a href="#mysql-安装" class="headerlink" title="mysql 安装"></a>mysql 安装</h2><p>上一次鄙人的mysql开启了远程访问，并且没有注意安全防范，被比特币勒索了。。。但是使用远程msql服务的需求还是需要的，毕竟真的是方便，这次注意一下安全方面的配置，应该不至于再没了吧。。。</p><h4 id="1-centos8-安装mysql8"><a href="#1-centos8-安装mysql8" class="headerlink" title="1. centos8 安装mysql8"></a>1. centos8 安装mysql8</h4><p>使用最新的包管理器安装MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install @mysql</span><br></pre></td></tr></table></figure><p>设置开机自启并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable --now mysqld</span><br></pre></td></tr></table></figure><p>运行mysql_secure_installation脚本，该脚本执行一些与安全性相关的操作并设置MySQL根密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>按提示往下走即可，注意在 <code>Disallow root login remotely?</code>选项中选择 <code>n</code></p><h4 id="2-更换-mysql-默认端口"><a href="#2-更换-mysql-默认端口" class="headerlink" title="2. 更换 mysql 默认端口"></a>2. 更换 mysql 默认端口</h4><p><code>vim /etc/my.cnf</code>，添加字段 <code>port=6612</code></p><p><code>systemctl restart mysqld</code> 重启 mysql</p><p>防火墙添加6612端口白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=6612/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>centos默认使用的是firewall作为防火墙，一些常用命令：</p><ol><li>firewall-cmd –list-ports       ##查看已开放的端口</li><li>firewall-cmd –add-port&#x3D;6612&#x2F;tcp –permanent ##永久开放6612端口</li><li>firewall-cmd –remove-port&#x3D;6612&#x2F;tcp –permanent ##永久关闭6612端口</li><li>firewall-cmd –reload ##刷新</li></ol><p>阿里云控制台安全组开放 6612 端口</p><h4 id="3-mysql-允许远程主机访问"><a href="#3-mysql-允许远程主机访问" class="headerlink" title="3. mysql 允许远程主机访问"></a>3. mysql 允许远程主机访问</h4><p>登录mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p&lt;密码&gt;</span><br></pre></td></tr></table></figure><p>将 <code>mysql.user</code> 中的 <code>root</code> 的 <code>host</code> 字段设为<code>&#39;%&#39;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h4 id="4-使用脚本自动备份数据"><a href="#4-使用脚本自动备份数据" class="headerlink" title="4. 使用脚本自动备份数据"></a>4. 使用脚本自动备份数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#数据库服务器</span><br><span class="line">dbserver=&#x27;localhost&#x27;</span><br><span class="line">#数据库用户名</span><br><span class="line">dbuser=&#x27;root&#x27;</span><br><span class="line">#数据库用密码</span><br><span class="line">dbpasswd=&#x27;********&#x27;</span><br><span class="line">#需要备份的数据库，多个数据库用空格分开</span><br><span class="line">dbname=&#x27;backdata01 backdata02&#x27;</span><br><span class="line">#备份时间</span><br><span class="line">backtime=`date +%Y%m%d`</span><br><span class="line">#日志备份路径</span><br><span class="line">logpath=&#x27;/opt/data/mysqlbak/&#x27;</span><br><span class="line">#数据备份路径</span><br><span class="line">datapath=&#x27;/opt/data/mysqlbak/&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">echo &#x27;##################$backtime##########################&#x27;</span><br><span class="line"> </span><br><span class="line">#日志记录头部</span><br><span class="line">echo ‘&quot;备份时间为$&#123;backtime&#125;,备份数据库表 $&#123;dbname&#125; 开始&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">#正式备份数据库</span><br><span class="line">for table in $dbname; do</span><br><span class="line">source=`mysqldump -h $&#123;dbserver&#125; -u $&#123;dbuser&#125; -p$&#123;dbpasswd&#125; $&#123;table&#125; &gt; $&#123;logpath&#125;/$&#123;backtime&#125;.sql` 2&gt;&gt; $&#123;logpath&#125;/mysqlback.log;</span><br><span class="line">#备份成功以下操作</span><br><span class="line">if [ &quot;$?&quot; == 0 ];then</span><br><span class="line">cd $datapath</span><br><span class="line">#为节约硬盘空间，将数据库压缩</span><br><span class="line">tar zcf $&#123;table&#125;$&#123;backtime&#125;.tar.gz $&#123;backtime&#125;.sql &gt; /dev/null</span><br><span class="line">#删除原始文件，只留压缩后文件</span><br><span class="line">rm -f $&#123;datapath&#125;/$&#123;backtime&#125;.sql</span><br><span class="line">#删除七天前备份，也就是只保存7天内的备份</span><br><span class="line">find $datapath -name &quot;*.tar.gz&quot; -type f -mtime +7 -exec rm -rf &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">echo &quot;数据库表 $&#123;dbname&#125; 备份成功!!&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">else</span><br><span class="line">#备份失败则进行以下操作</span><br><span class="line">echo &quot;数据库表 $&#123;dbname&#125; 备份失败!!&quot; &gt;&gt; $&#123;logpath&#125;/mysqlback.log</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">echo &#x27;##################完成############################&#x27;</span><br></pre></td></tr></table></figure><p>创建定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">59 23 * * * ./opt/mysqldata/mysqlbak.sh  ## 每天23:59执行命令</span><br></pre></td></tr></table></figure><h2 id="redis-安装"><a href="#redis-安装" class="headerlink" title="redis 安装"></a>redis 安装</h2><h4 id="5-安装redis并且设置远程访问和密码配置"><a href="#5-安装redis并且设置远程访问和密码配置" class="headerlink" title="5. 安装redis并且设置远程访问和密码配置"></a>5. 安装redis并且设置远程访问和密码配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum -y install redis</span><br><span class="line">[root@dalin1 ~]# systemctl enable --now redis</span><br></pre></td></tr></table></figure><p>修改redis端口、设置密码、允许远程访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# vim /etc/redis.conf</span><br></pre></td></tr></table></figure><p>修改 <code>port 6369</code></p><p>注释掉 <code>bind 127.0.0.1</code>，以便让外网访问</p><p>去掉 <code>#requirepass foobared</code> 注释，foobared改为自己的密码</p><p>防火墙添加6369端口白名单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=6369/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>阿里云控制台安全组开放 6369 端口</p><h4 id="6-创建普通用户，以后尽量使用普通用户操作"><a href="#6-创建普通用户，以后尽量使用普通用户操作" class="headerlink" title="6. 创建普通用户，以后尽量使用普通用户操作"></a>6. 创建普通用户，以后尽量使用普通用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# adduser dalin  #创建普通用户 dalin</span><br><span class="line">[root@dalin1 ~]# passwd dalin   #修改密码</span><br><span class="line">[root@dalin1 ~]# su dalin   #切换用户</span><br></pre></td></tr></table></figure><p>普通用户只在 <code>/home/&lt;username&gt;</code> 目录下有完整权限</p><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>docker这么方便的东西怎么能不用呢，但是因为服务器实在太菜了，可能会卡顿，而且要时刻注意内存使用情况</p><h4 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install -y yum-utils   device-mapper-persistent-data   lvm2</span><br></pre></td></tr></table></figure><h4 id="2-设置Docker源"><a href="#2-设置Docker源" class="headerlink" title="2. 设置Docker源"></a>2. 设置Docker源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum-config-manager     --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="3-安装Docker-CE"><a href="#3-安装Docker-CE" class="headerlink" title="3. 安装Docker CE"></a>3. 安装Docker CE</h4><h5 id="3-1-docker安装版本查看"><a href="#3-1-docker安装版本查看" class="headerlink" title="3.1 docker安装版本查看"></a>3.1 docker安装版本查看</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><h4 id="3-2-安装docker"><a href="#3-2-安装docker" class="headerlink" title="3.2 安装docker"></a>3.2 安装docker</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install docker-ce-18.09.6 docker-ce-cli-18.09.6 containerd.io</span><br></pre></td></tr></table></figure><p>指定安装的docker版本为18.09.6，由于该版本目前为最新版，故可以直接安装，不用指定版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h4 id="4-启动Docker并设置开机自启"><a href="#4-启动Docker并设置开机自启" class="headerlink" title="4. 启动Docker并设置开机自启"></a>4. 启动Docker并设置开机自启</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# systemctl enable --now docker</span><br></pre></td></tr></table></figure><h4 id="5-镜像加速"><a href="#5-镜像加速" class="headerlink" title="5. 镜像加速"></a>5. 镜像加速</h4><p>使用阿里云镜像加速地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# mkdir -p /etc/docker</span><br><span class="line">[root@dalin1 ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://khv87vsk.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="docker-下安装Elasticsearch和Kibana"><a href="#docker-下安装Elasticsearch和Kibana" class="headerlink" title="docker 下安装Elasticsearch和Kibana"></a>docker 下安装Elasticsearch和Kibana</h2><p>服务器太菜，基本跑不动</p><h3 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h3><p>下载镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker pull elasticsearch:7.2.0</span><br></pre></td></tr></table></figure><p>启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -d elasticsearch:7.2.0</span><br></pre></td></tr></table></figure><p>大概率启动失败，查看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 temp]# docker logs elasticsearch</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: starting java failed with [1]</span><br><span class="line">output:</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 1073741824 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># logs/hs_err_pid132.log</span><br><span class="line">error:</span><br><span class="line">OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c0000000, 1073741824, 0) failed; error=&#x27;Not enough space&#x27; (errno=12)</span><br><span class="line">at org.elasticsearch.tools.launchers.JvmErgonomics.flagsFinal(JvmErgonomics.java:126)</span><br><span class="line">at org.elasticsearch.tools.launchers.JvmErgonomics.finalJvmOptions(JvmErgonomics.java:88)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>jvm内存不足。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1]# find / -name jvm.options</span><br><span class="line">/var/lib/docker/overlay2/aa7a9ac9f293452ddf8947e9fdf3af24d602566d54b6278284751239b43e37e5/diff/usr/share/elasticsearch/config/jvm.options</span><br><span class="line">[root@dalin1]# vim /var/lib/docker/overlay2/aa7a9ac9f293452ddf8947e9fdf3af24d602566d54b6278284751239b43e37e5/diff/usr/share/elasticsearch/config/jvm.options</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">## JVM configuration</span><br><span class="line"></span><br><span class="line">################################################################</span><br><span class="line">## IMPORTANT: JVM heap size</span><br><span class="line">################################################################</span><br><span class="line">##</span><br><span class="line">## You should always set the min and max JVM heap</span><br><span class="line">## size to the same value. For example, to set</span><br><span class="line">## the heap to 4 GB, set:</span><br><span class="line">##</span><br><span class="line">## -Xms4g</span><br><span class="line">## -Xmx4g</span><br><span class="line">##</span><br><span class="line">## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html</span><br><span class="line">## for more information</span><br><span class="line">##</span><br><span class="line">################################################################</span><br><span class="line"></span><br><span class="line"># Xms represents the initial size of total heap space</span><br><span class="line"># Xmx represents the maximum size of total heap space</span><br><span class="line"></span><br><span class="line">-Xms1g      #服务器实在太菜了，我改成256m</span><br><span class="line">-Xmx1g      #服务器实在太菜了，我改成256m</span><br><span class="line"></span><br><span class="line">################################################################</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重新启动容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker start elasticsearch</span><br></pre></td></tr></table></figure><p>检测是否启动成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# curl http://localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;c19d1882a695&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;-zKpqN7TQMqmPULGgdMz3w&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.2.0&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;508c38a&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2019-06-20T15:54:18.811730Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.0.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决跨域访问问题</p><p>进入容器，修改elasticsearch.yml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dalin1 ~]# docker exec -it elasticsearch /bin/bash</span><br><span class="line">vim /usr/share/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p>在elasticsearch.yml的文件末尾加上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure><p>es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">`exit` 退出容器后 `docker restart elasticsearch` 重启容器</span><br><span class="line"></span><br><span class="line">#### kibana安装</span><br><span class="line">下载镜像</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker pull kibana:7.2.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">启动kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker run –name kibana –link&#x3D;elasticsearch:es -e ELASTICSEARCH_URL&#x3D;<a href="http://172.17.0.2:9200/">http://172.17.0.2:9200</a>  -p 5601:5601 -d kibana:7.7.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用--link连接到elasticsearch容器，并添加环境变量，指定安装es的容器地址</span><br><span class="line"></span><br><span class="line">当然也可以进入容器内部修改配置文件来设置es访问地址</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker exec -it kibana &#x2F;bin&#x2F;bash<br>vi config&#x2F;kibana.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kibana默认是优先使用环境变量的地址，然后才是配置文件kibana.yml</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">如何查询容器地址？</span><br></pre></td></tr></table></figure><h1 id="获取到容器的元数据信息"><a href="#获取到容器的元数据信息" class="headerlink" title="获取到容器的元数据信息"></a>获取到容器的元数据信息</h1><p>[root@dalin1 ~]# docker inspect [id&#x2F;name]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最后，配置安全组和防火墙，开放9200、5601端口</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# firewall-cmd –add-port&#x3D;5601&#x2F;tcp –permanent<br>[root@dalin1 ~]# firewall-cmd –add-port&#x3D;9200&#x2F;tcp –permanent</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这就结束了吗？是的，网上几乎所有的关于docker下安装kibana教程都是到了这一步就说完事收工、开始体验。。。但是！！！我遇到的情况是访问 `http//:ip:5601`，只会给我冰冷的大字：</span><br></pre></td></tr></table></figure><p>Kibana server is not ready yet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker logs kibana`打印日志，报错：</span><br></pre></td></tr></table></figure><p>{“type”:”log”,”@timestamp”:”2020-06-04T08:25:57Z”,”tags”:[“warning”,”elasticsearch”,”admin”],”pid”:6,”message”:”Unable to revive connection: <a href="http://172.17.0.2:9200/%22%7D">http://172.17.0.2:9200/&quot;}</a><br>{“type”:”log”,”@timestamp”:”2020-06-04T08:25:57Z”,”tags”:[“warning”,”elasticsearch”,”admin”],”pid”:6,”message”:”No living connections”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip地址是没问题的，es服务也确实起了，为什么呢？？这个问题花了我大半天的时间，找遍了网上的教程都没有相关的介绍，官网上关于docker安装kibana的教程更是少。 </span><br><span class="line"></span><br><span class="line">进入kibana容器中</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# docker exec -it kibana &#x2F;bin&#x2F;bash<br>bash-4.2$ ping 172.17.0.2    #没有问题，能ping通<br>bash-4.2$ curl <a href="http://120.79.43.44:9200/">http://120.79.43.44:9200</a><br>curl: (7) Failed connect to 120.79.43.44:9200; No route to host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题就出在这里！应该是防火墙的原因导致容器之间无法进行通信</span><br><span class="line"></span><br><span class="line">解决方法，依次执行以下命令</span><br></pre></td></tr></table></figure><p>[root@dalin1 ~]# nmcli connection modify docker0 connection.zone trusted</p><p>[root@dalin1 ~]# systemctl stop NetworkManager.service</p><p>[root@dalin1 ~]# firewall-cmd –permanent –zone&#x3D;trusted –change-interface&#x3D;docker0</p><p>[root@dalin1 ~]# systemctl start NetworkManager.service</p><p>[root@dalin1 ~]# nmcli connection modify docker0 connection.zone trusted</p><p>[root@dalin1 ~]# systemctl restart docker.service</p><p>&#96;&#96;&#96;<br>把 <code>docker0</code> 加入防火墙白名单</p><p>重新启动容器，访问地址 <a href="http://ip:5601/">http://ip:5601</a> ，总算没有了 <code>Kibana server is not ready yet</code>,显示正在加载的图像，稍作等候即可，部署完成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阿里云上重新买了台穷鬼t5，菜是菜了点，但是该折腾还是要折腾的。。。&lt;/p&gt;
&lt;h2 id=&quot;设置虚拟内存&quot;&gt;&lt;a href=&quot;#设置虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;设置虚拟内存&quot;&gt;&lt;/a&gt;设置虚拟内存&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/12/13/开发笔记/k8s配置文件详解/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s-yaml文件"><a href="#k8s-yaml文件" class="headerlink" title="k8s yaml文件"></a>k8s yaml文件</h2><h3 id="yaml基础"><a href="#yaml基础" class="headerlink" title="yaml基础"></a>yaml基础</h3><p>YAML是专门用来写配置文件的语言，非常简洁和强大，使用比json更方便。它实质上是一种通用的数据串行化格式。</p><p>YAML语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大小写敏感</span><br><span class="line">使用缩进表示层级关系</span><br><span class="line">缩进时不允许使用Tal键，只允许使用空格</span><br><span class="line">缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class="line">”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略　</span><br></pre></td></tr></table></figure><p>在Kubernetes中，只需要知道两种结构类型即可：Lists和Maps</p><p>YAML Maps：</p><p>Map顾名思义指的是字典，即一个Key:Value 的键值对信息。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">　　注：---为可选的分隔符 ，当需要在一个文件中定义多个结构的时候需要使用。上述内容表示有两个键apiVersion和kind，分别对应的值为v1和Pod。</span><br></pre></td></tr></table></figure><p>Maps的value既能够对应字符串也能够对应一个Maps。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br></pre></td></tr></table></figure><p>List即列表，说白了就是数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args</span><br><span class="line"> -beijing</span><br><span class="line"> -shanghai</span><br><span class="line"> -shenzhen</span><br><span class="line"> -guangzhou</span><br></pre></td></tr></table></figure><p>当然Lists的子项也可以是Maps，Maps的子项也可以是List，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: front-end</span><br><span class="line">      image: nginx</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">    - name: flaskapp-demo</span><br><span class="line">      image: jcdemo/flaskapp</span><br><span class="line">      ports: 8080</span><br></pre></td></tr></table></figure><h3 id="k8s-yaml"><a href="#k8s-yaml" class="headerlink" title="k8s yaml"></a>k8s yaml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1             #指定api版本，此值必须在kubectl apiversion中  </span><br><span class="line">kind: Pod                  #指定创建资源的角色/类型  </span><br><span class="line">metadata:                  #资源的元数据/属性  </span><br><span class="line">  name: web04-pod          #资源的名字，在同一个namespace中必须唯一  </span><br><span class="line">  labels:                  #设定资源的标签，详情请见http://blog.csdn.net/liyingke112/article/details/77482384</span><br><span class="line">    k8s-app: apache  </span><br><span class="line">    version: v1  </span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;  </span><br><span class="line">  annotations:             #自定义注解列表  </span><br><span class="line">    - name: String         #自定义注解名字  </span><br><span class="line">spec:#specification of the resource content 指定该资源的内容  </span><br><span class="line">  restartPolicy: Always    #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器  </span><br><span class="line">  nodeSelector:            #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1  </span><br><span class="line">    zone: node1  </span><br><span class="line">  containers:  </span><br><span class="line">  - name: web04-pod        #容器的名字  </span><br><span class="line">    image: web:apache      #容器使用的镜像地址  </span><br><span class="line">    imagePullPolicy: Never #三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略，</span><br><span class="line">                           # Always，每次都检查</span><br><span class="line">                           # Never，每次都不检查（不管本地是否有）</span><br><span class="line">                           # IfNotPresent，如果本地有就不检查，如果没有就拉取</span><br><span class="line">    command: [&#x27;sh&#x27;]        #启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT  </span><br><span class="line">    args: [&quot;$(str)&quot;]       #启动容器的命令参数，对应Dockerfile中CMD参数  </span><br><span class="line">    env:                   #指定容器中的环境变量  </span><br><span class="line">    - name: str            #变量的名字  </span><br><span class="line">      value: &quot;/etc/run.sh&quot; #变量的值  </span><br><span class="line">    resources:             #资源管理，请求请见http://blog.csdn.net/liyingke112/article/details/77452630</span><br><span class="line">      requests:            #容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行  </span><br><span class="line">        cpu: 0.1           #CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m）</span><br><span class="line">        memory: 32Mi       #内存使用量  </span><br><span class="line">      limits:              #资源限制  </span><br><span class="line">        cpu: 0.5  </span><br><span class="line">        memory: 32Mi  </span><br><span class="line">    ports:  </span><br><span class="line">    - containerPort: 80    #容器开放对外的端口</span><br><span class="line">      name: httpd          #名称</span><br><span class="line">      protocol: TCP  </span><br><span class="line">    livenessProbe:         #pod内容器健康检查的设置，详情请见http://blog.csdn.net/liyingke112/article/details/77531584</span><br><span class="line">      httpGet:             #通过httpget检查健康，返回200-399之间，则认为容器正常  </span><br><span class="line">        path: /            #URI地址  </span><br><span class="line">        port: 80  </span><br><span class="line">        #host: 127.0.0.1   #主机地址  </span><br><span class="line">        scheme: HTTP  </span><br><span class="line">      initialDelaySeconds: 180 #表明第一次检测在容器启动后多长时间后开始  </span><br><span class="line">      timeoutSeconds: 5    #检测的超时时间  </span><br><span class="line">      periodSeconds: 15    #检查间隔时间  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常  </span><br><span class="line">      #  command:  </span><br><span class="line">      #    - cat  </span><br><span class="line">      #    - /tmp/health  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #tcpSocket: //通过tcpSocket检查健康   </span><br><span class="line">      #  port: number   </span><br><span class="line">    lifecycle:             #生命周期管理  </span><br><span class="line">      postStart:           #容器运行之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command:  </span><br><span class="line">            - &#x27;sh&#x27;  </span><br><span class="line">            - &#x27;yum upgrade -y&#x27;  </span><br><span class="line">      preStop:             #容器关闭之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command: [&#x27;service httpd stop&#x27;]  </span><br><span class="line">    volumeMounts:          #详情请见http://blog.csdn.net/liyingke112/article/details/76577520</span><br><span class="line">    - name: volume         #挂载设备的名字，与volumes[*].name 需要对应    </span><br><span class="line">      mountPath: /data     #挂载到容器的某个路径下  </span><br><span class="line">      readOnly: True  </span><br><span class="line">  volumes:                 #定义一组挂载设备  </span><br><span class="line">  - name: volume           #定义一个挂载设备的名字  </span><br><span class="line">    #meptyDir: &#123;&#125;  </span><br><span class="line">    hostPath:  </span><br><span class="line">      path: /opt           #挂载设备类型为hostPath，路径为宿主机下的/opt,这里设备类型支持很多种  </span><br></pre></td></tr></table></figure><h3 id="k8s-使用过程笔记"><a href="#k8s-使用过程笔记" class="headerlink" title="k8s 使用过程笔记"></a>k8s 使用过程笔记</h3><h5 id="如何进入kubernetes的一个pod"><a href="#如何进入kubernetes的一个pod" class="headerlink" title="如何进入kubernetes的一个pod"></a>如何进入kubernetes的一个pod</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类似于docker</span><br><span class="line">进入docker容器 ：</span><br><span class="line">docker exec -ti  &lt;your-container-name&gt;   /bin/sh</span><br><span class="line"></span><br><span class="line">进入pod：</span><br><span class="line">kubectl exec -ti &lt;your-pod-name&gt;  -n &lt;your-namespace&gt;  -- /bin/sh</span><br></pre></td></tr></table></figure><h5 id="关于k8s使用镜像创建pod的坑"><a href="#关于k8s使用镜像创建pod的坑" class="headerlink" title="关于k8s使用镜像创建pod的坑"></a>关于k8s使用镜像创建pod的坑</h5><p>k8s默认从远程仓库中获取镜像，可以使用镜像获取策略从本地获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">   - name: test</span><br><span class="line">     image: nginx:1.7.9     #必须带上tag</span><br><span class="line">     imagePullPolicy: Never</span><br></pre></td></tr></table></figure><p>Always 总是拉取镜像</p><p>IfNotPresent 本地有则使用本地镜像,不拉取</p><p>Never 只使用本地镜像，从不拉取，即使本地没有</p><p>如果省略imagePullPolicy 镜像tag为 :latest 策略为always ，否则 策略为 IfNotPresent</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;k8s-yaml文件&quot;&gt;&lt;a href=&quot;#k8s-yaml文件&quot; class=&quot;headerlink&quot; title=&quot;k8s yaml文件&quot;&gt;&lt;/a&gt;k8s yaml文件&lt;/h2&gt;&lt;h3 id=&quot;yaml基础&quot;&gt;&lt;a href=&quot;#yaml基础&quot; class=&quot;
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/session%EF%BC%8Ccookie%EF%BC%8Ctoken%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/13/开发笔记/session，cookie，token学习【转】/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://segmentfault.com/a/1190000017831088">https://segmentfault.com/a/1190000017831088</a></p><h2 id="session，cookie和token究竟是什么"><a href="#session，cookie和token究竟是什么" class="headerlink" title="session，cookie和token究竟是什么"></a>session，cookie和token究竟是什么</h2><h4 id="1-http是一个无状态协议"><a href="#1-http是一个无状态协议" class="headerlink" title="1. http是一个无状态协议"></a>1. http是一个无状态协议</h4><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把 <a href="http://www.zhihu.com/login.html">www.zhihu.com/login.html</a> 和 <a href="http://www.zhihu.com/index.html">www.zhihu.com/index.html</a> 关联起来，必须使用某些手段和工具</p><h4 id="2-cookie和session"><a href="#2-cookie和session" class="headerlink" title="2. cookie和session"></a>2. cookie和session</h4><p>2.1 http请求过程</p><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下：<br>Set-Cookie: value[; expires&#x3D;date][; domain&#x3D;domain][; path&#x3D;path][; secure]</li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/567D6B03A5704ABCA184CCB2CFA9D8E7?method=download&shareKey=712516258a5c4b9bcc0375ff5e046231" alt="请求过程"></p><p>2.2 注意</p><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie的方式，但是只用session不用cookie，或是只用cookie不用session，在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><p>2.3 小结</p><p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行</p><h4 id="3-token"><a href="#3-token" class="headerlink" title="3. token"></a>3. token</h4><p>3.1 概念</p><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><p>3.2 组成</p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash&#x2F;encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><p>3.3 token认证流程</p><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h4 id="4-token可以抵抗csrf，cookie-session不行"><a href="#4-token可以抵抗csrf，cookie-session不行" class="headerlink" title="4. token可以抵抗csrf，cookie+session不行"></a>4. token可以抵抗csrf，cookie+session不行</h4><p>假如用户正在登录银行网页，登录了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<a href="http://www.bank.com/api/transfer%EF%BC%8Cbody%E4%B8%BAcount=1000&to=Tom%E3%80%82%E5%80%98%E8%8B%A5%E6%98%AFsession+cookie%EF%BC%8C%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%BD%AC%E7%BB%99Tom1000%E5%85%83%E4%BA%86.%E5%9B%A0%E4%B8%BAform">http://www.bank.com/api/transfer，body为count=1000&amp;to=Tom。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form</a> 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h4 id="5-分布式情况下的session和token"><a href="#5-分布式情况下的session和token" class="headerlink" title="5. 分布式情况下的session和token"></a>5. 分布式情况下的session和token</h4><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><p>token是无状态的，token字符串里就保存了所有的用户信息。</p><p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><p>转载自 <a href="https://segmentfault.com/a/1190000015419746">https://segmentfault.com/a/1190000015419746</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。</p><h2 id="cookie机制"><a href="#cookie机制" class="headerlink" title="cookie机制"></a>cookie机制</h2><p>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。</p><p>具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。</p><p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p><p>而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。</p><p>session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。</p><p>就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。</p><h2 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h2><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p><p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p><p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p><h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><p>Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比较阐明二者的特性以及适用的场所。</p><h4 id="1-存取方式的不同"><a href="#1-存取方式的不同" class="headerlink" title="1. 存取方式的不同"></a>1. 存取方式的不同</h4><p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比较艰难的。</p><p>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p><h4 id="2-隐私策略的不同"><a href="#2-隐私策略的不同" class="headerlink" title="2. 隐私策略的不同"></a>2. 隐私策略的不同</h4><p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</p><p>假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。</p><h4 id="3-有效期上的不同"><a href="#3-有效期上的不同" class="headerlink" title="3. 有效期上的不同"></a>3. 有效期上的不同</h4><p>使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。</p><p>由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p><h4 id="4-服务器压力的不同"><a href="#4-服务器压力的不同" class="headerlink" title="4. 服务器压力的不同"></a>4. 服务器压力的不同</h4><p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。</p><p>而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。</p><h4 id="5-浏览器支持的不同"><a href="#5-浏览器支持的不同" class="headerlink" title="5. 浏览器支持的不同"></a>5. 浏览器支持的不同</h4><p>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。</p><p>假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。</p><p>假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）</p><p>6、跨域支持上的不同<br>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</p><p>仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自 &lt;a href=&quot;https://segmentfault.com/a/1190000017831088&quot;&gt;https://segmentfault.com/a/1190000017831088&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;session，cookie和toke
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/13/开发笔记/一次完整的HTTP请求过程【转】/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器的地址栏输入 <a href="http://www.linux178.com/">www.linux178.com</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>以Chrome浏览器为例：</p><hr><h4 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h4><p> 首先Chrome浏览器会解析 <a href="http://www.linux178.com/">www.linux178.com</a> 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p><p> ① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.linux178.com/">www.linux178.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p><p>注：我们怎么查看Chrome自身的缓存？可以使用 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 来进行查看</p><p> ② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p><p> 注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig &#x2F;displaydns 来进行查看</p><p> ③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p><p> ④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找到根域的DNS地址，就会向其发起请求（请问<a href="http://www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。">www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。</a></p><p> 注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p><p>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p><p>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p><p>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</p><p>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><hr><h4 id="2-发起TCP的3次握手"><a href="#2-发起TCP的3次握手" class="headerlink" title="2.发起TCP的3次握手"></a>2.发起TCP的3次握手</h4><p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP&#x2F;IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP&#x2F;IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP&#x2F;IP的连接。</p><p><img src="https://note.youdao.com/yws/api/personal/file/DCF671839B464E2EBDEC1EEEB14CE5EF?method=download&shareKey=8d356f928b246d083b2f839834f486b2" alt="image"></p><p>1） Client首先发送一个连接试探，ACK&#x3D;0 表示确认号无效，SYN &#x3D; 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq &#x3D; x 表示Client自己的初始序号（seq &#x3D; 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p><p>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack &#x3D; x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack&#x3D;1其实是ack&#x3D;0+1,也就是期望客户端的第1个包），seq &#x3D; y 表示Server 自己的初始序号（seq&#x3D;0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p><p>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack&#x3D; y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq&#x3D; x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p><p>TCP 为什么需要3次握手？</p><p>2个计算机通信是靠协议（目前流行的TCP&#x2F;IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP&#x2F;IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p><p>为什么HTTP协议要基于TCP来实现？</p><p>目前在Internet中所有的传输都是通过TCP&#x2F;IP进行的，HTTP协议作为TCP&#x2F;IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p><hr><h4 id="3-建立TCP连接后发起http请求"><a href="#3-建立TCP连接后发起http请求" class="headerlink" title="3.建立TCP连接后发起http请求"></a>3.建立TCP连接后发起http请求</h4><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成</p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1) 请求行"></a>1) 请求行</h5><p>请求行分为三个部分：请求方法、请求地址和协议版本</p><p>请求方法：</p><p>HTTP&#x2F;1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>GET: 完整请求一个资源 （常用）</p><p>  HEAD: 仅请求响应首部</p><p>  POST：提交表单  （常用）</p><p>  PUT: (webdav) 上传文件（但是浏览器不支持该方法）</p><p>  DELETE：(webdav) 删除</p><p>  OPTIONS：返回请求的资源所支持的方法的方法</p><p>  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><p>请求地址：</p><p>URL:统一资源定位符，是一种资源位置的抽象唯一识别方法。</p><p>组成：&lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;</p><p>端口和路径有时可以省略（HTTP默认端口号是80），GET请求可能会带参数</p><p>什么是URL、URI、URN？<br>URI  Uniform Resource Identifier 统一资源标识符。<br>格式：  scheme:&#x2F;&#x2F;[username:password@]HOST:port&#x2F;path&#x2F;to&#x2F;source</p><p>URL  Uniform Resource Locator 统一资源定位符<br>格式：  <a href="http://www.magedu.com/downloads/nginx-1.5.tar.gz">http://www.magedu.com/downloads/nginx-1.5.tar.gz</a></p><p>URN  Uniform Resource Name 统一资源名称</p><p>URL和URN 都属于 URI</p><p>协议版本：</p><p>协议版本的格式为：HTTP&#x2F;主版本号.次版本号</p><p>协议有：</p><p>http&#x2F;0.9: stateless</p><p>http&#x2F;1.0: MIME, keep-alive (保持连接), 缓存</p><p>http&#x2F;1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用</p><hr><h5 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2) 请求头部"></a>2) 请求头部</h5><p>请求头部为请求报文添加了一些附加信息，如token等，由“名&#x2F;值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><p>下面是Chrome发起的http请求报文头部信息：</p><p><img src="https://note.youdao.com/yws/api/personal/file/8A64C49298E4491CB00EEFEB9F0912F1?method=download&shareKey=7afada5151ba5d6873064b543a997589" alt="http request header"></p><p>Accept  就是告诉服务器端，我接受那些MIME类型</p><p>Accept-Encoding  这个看起来是接受那些压缩方式的文件</p><p>Accept-Lanague   告诉服务器能够发送哪些语言</p><p>Connection       告诉服务器支持keep-alive特性</p><p>Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</p><p>Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机，这里就是用来标识要访问那个虚拟主机。</p><p>User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等  </p><br/><p>条件请求首部：</p><p>If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件</p><p>安全请求首部：</p><p>Authorization: 客户端提供给服务器的认证信息；</p><br/><p>什么是MIME？</p><p>MIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p><p>MIME 遵循以下格式：major&#x2F;minor 主类型&#x2F;次类型 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image/jpg</span><br><span class="line">image/gif</span><br><span class="line">text/html</span><br><span class="line">video/quicktime</span><br><span class="line">appliation/x-httpd-php</span><br></pre></td></tr></table></figure><hr><h5 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3) 请求数据"></a>3) 请求数据</h5><p>可选部分，比如GET请求就没有请求数据。</p><h2 id="下面是一个POST方法的请求报文："><a href="#下面是一个POST方法的请求报文：" class="headerlink" title="下面是一个POST方法的请求报文："></a>下面是一个POST方法的请求报文：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST 　/index.php　HTTP/1.1 　　 请求行 </span><br><span class="line">Host: localhost </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头 </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 </span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5 </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Referer: http://localhost/ </span><br><span class="line">Content-Length：25 </span><br><span class="line">Content-Type：application/x-www-form-urlencoded </span><br><span class="line">　　空行 </span><br><span class="line">username=aa&amp;password=1234　　请求数据</span><br></pre></td></tr></table></figure></h2><h4 id="4-服务器端响应http请求，浏览器得到html代码"><a href="#4-服务器端响应http请求，浏览器得到html代码" class="headerlink" title="4.服务器端响应http请求，浏览器得到html代码"></a>4.服务器端响应http请求，浏览器得到html代码</h4><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><p>1)状态行<br>由3部分组成，分别为：协议版本，状态码，状态码描述。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><p>状态码</p><p>1xx: 信息性状态码</p><pre><code>100, 101</code></pre><p>2xx: 成功状态码</p><pre><code>200OK请求成功。一般用于GET与POST请求201Created已创建。成功请求并创建了新的资源202Accepted已接受。已经接受请求，但未处理完成</code></pre><p>3xx: 重定向状态码</p><pre><code>301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;302: 临时重定向，显式重定向, Location响应首部的值为新的URL304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，                    告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</code></pre><p>4xx: 客户端错误状态码</p><pre><code>400：Bad Request客户端请求的语法错误，服务器无法理解401：Unauthorized请求要求用户的身份认证403：Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求404: Not Found  请求的URL资源并不存在</code></pre><p>5xx: 服务器端错误状态码</p><pre><code>500: Internal Server Error  服务器内部错误501：Not Implemented服务器不支持请求的功能，无法完成请求502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</code></pre><p>2.响应头部<br>与请求头部类似，为响应报文添加了一些附加信息</p><p>3.响应数据<br>用于存放需要返回给客户端的数据信息。</p><p><img src="https://note.youdao.com/yws/api/personal/file/9961EAC9AE7346CCB188AEEF8D7DBF45?method=download&shareKey=7ec4caa1f9d7133568247c1b2cd569bb" alt="http响应头"></p><p>Connection            使用keep-alive特性</p><p>Content-Encoding      使用gzip方式对资源压缩</p><p>Content-type          MIME类型为html类型，字符集是 UTF-8</p><p>Date                  响应的日期</p><p>Server                使用的WEB服务器</p><p>Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP&#x2F;1.1）中提供</p><p>Vary  这个可以参考（<a href="http://blog.csdn.net/tenfyguo/article/details/5939000%EF%BC%89">http://blog.csdn.NET/tenfyguo/article/details/5939000）</a></p><p>X-Pingback  参考（<a href="http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html%EF%BC%89">http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）</a></p><hr><p>那到底服务器端接收到http请求后是怎么样生成html文件？</p><p>假设服务器端使用nginx+PHP(fastcgi)架构提供服务</p><p>① nginx读取配置文件</p><p>我们在浏览器的地址栏里面输入的是 <a href="http://www.linux178.com/">http://www.linux178.com</a> （http:&#x2F;&#x2F;可以不用输入，浏览器会自动帮我们添加），其实完整的应该是<a href="http://www.linux178.com./">http://www.linux178.com./</a> 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的&#x2F;也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是<a href="http://www.linux178.com/%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A5%BD%E4%BA%86Nginx%E5%9C%A8%E6%94%B6%E5%88%B0">http://www.linux178.com/，那么好了Nginx在收到</a> 浏览器 GET &#x2F; 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /web/echo</span><br></pre></td></tr></table></figure><p>通过这个就知道所有网页文件的就在这个目录下 这个目录就是&#x2F; 当我们<a href="http://www.linux178.com/%E6%97%B6%E5%B0%B1%E6%98%AF%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BE%8B%E5%A6%82%E8%AE%BF%E9%97%AEhttp://www.linux178.com/index.html,%E9%82%A3%E4%B9%88%E4%BB%A3%E8%A1%A8/web/echo%E4%B8%8B%E9%9D%A2%E6%9C%89%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%ABindex.html">http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index index.html index.htm index.php</span><br></pre></td></tr></table></figure><p>通过这个就能得知网站的首页文件是那个文件，也就是我们在入<a href="http://www.linux178.com/">http://www.linux178.com/</a> ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是&#x2F;index.php,然后根据后面的配置进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php(\/.*)*$ &#123;</span><br><span class="line">   root /web/echo;</span><br><span class="line">   fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">   fastcgi_index  index.php;</span><br><span class="line">   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">   include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。</p><p>② 把php文件交给fastcgi进程去处理<br>于是nginx把&#x2F;index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。</p><p>注1：nginx是怎么找index.php文件的？</p><p>当nginx发现需要&#x2F;web&#x2F;echo&#x2F;index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从&#x2F;开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。</p><p>注2：寻找文件在文件系统层面是怎么操作的？</p><p>比如nginx需要得到&#x2F;web&#x2F;echo&#x2F;index.php这个文件</p><p>每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/62D4C30149744CCBBB205E93ECD804BB?method=download&shareKey=87e1aaf71c8e7d88f224dc2bad6b7f3f" alt="数据区"></p><p> 还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。</p><p> 那到底目录里面存放着什么，难道不是文件或者其他目录吗？</p><p> 其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如</p><table><thead><tr><th>文件名</th><th>innode号</th></tr></thead><tbody><tr><td>test1.txt</td><td>100</td></tr><tr><td>test2.txt</td><td>101</td></tr></tbody></table><p>假设</p><p>&#x2F;           在数据区占据 1、2号block ，&#x2F;其实也是一个目录 里面有3个目录  web 111</p><p>web         占据 5号block  是目录 里面有2个目录 echo data</p><p>echo        占据 11号 block  是目录  里面有1个文件 index.php</p><p>index.php   占据 15 16号 block  是文件</p><p>其在文件系统中分布如下图所示</p><p><img src="https://note.youdao.com/yws/api/personal/file/6311A126C78449E789B73AABB91AEF88?method=download&shareKey=03739ab95a25d66303f5a35f9d216e77" alt="文件系统分布"></p><p>那么内核究竟是怎么找到index.php这个文件的呢？</p><p>内核拿到nginx的IO系统调用要获取&#x2F;web&#x2F;echo&#x2F;index.php这个文件请求之后</p><p>① 内核读取元数据区 &#x2F; 的inode，从inode里面读取&#x2F;所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号</p><p>② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode</p><p>③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号</p><p>④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容</p><hr><h4 id="5-浏览器解析html代码，并请求html代码中的资源"><a href="#5-浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="5. 浏览器解析html代码，并请求html代码中的资源"></a>5. 浏览器解析html代码，并请求html代码中的资源</h4><p>浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js&#x2F;css&#x2F;image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><br/><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><p><img src="https://note.youdao.com/yws/api/personal/file/040A9AB67B684F2C910A080CE06A29EB?method=download&shareKey=da1371351e72b4bb34552edacabc0a3d" alt="浏览器静态资源请求"></p><p>详细的浏览器工作原理请看：<a href="http://kb.cnblogs.com/page/129756/">http://kb.cnblogs.com/page/129756/</a> </p><h4 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6.浏览器对页面进行渲染呈现给用户"></a>6.浏览器对页面进行渲染呈现给用户</h4><p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p><p>自此一次完整的HTTP事务宣告完成.</p><br/><h4 id="本文出自-“雷纳科斯的博客”-博客，转载自http-linux5588-blog-51cto-com-65280-1351007"><a href="#本文出自-“雷纳科斯的博客”-博客，转载自http-linux5588-blog-51cto-com-65280-1351007" class="headerlink" title="本文出自 “雷纳科斯的博客” 博客，转载自http://linux5588.blog.51cto.com/65280/1351007"></a>本文出自 “雷纳科斯的博客” 博客，转载自<a href="http://linux5588.blog.51cto.com/65280/1351007">http://linux5588.blog.51cto.com/65280/1351007</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在浏览器的地址栏输入 &lt;a href=&quot;http://www.linux178.com/&quot;&gt;www.linux178.com&lt;/a&gt; ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？&lt;/p&gt;
&lt;p&gt;域名解析 –&amp;gt; 发起TCP的3次握手 –&amp;gt; 建立TCP
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88bk-cmdb%E4%B8%8D%E7%94%A8go%20mod%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/12/13/开发笔记/为什么bk-cmdb不用go mod管理/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址 <a href="https://github.com/Tencent/bk-cmdb">https://github.com/Tencent/bk-cmdb</a></p><p>为什么不用官方推荐的 go mod 管理依赖呢？</p><p>bk-cmdb vendor下的一些依赖库都是有修改过的：</p><ul><li>vendor&#x2F;go.mongodb.org&#x2F;mongo-driver&#x2F;mongo&#x2F;session_exposer.go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CmdbPrepareCommitOrAbort set state to InProgress, so that we can commit with other</span></span><br><span class="line"><span class="comment">// operation directly. otherwise mongodriver will do a false commit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CmdbPrepareCommitOrAbort</span><span class="params">(sess Session)</span></span> &#123;</span><br><span class="line">i, ok := sess.(*sessionImpl)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;the session is not type *sessionImpl&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i.clientSession.SetState(<span class="number">2</span>)</span><br><span class="line">i.didCommitAfterStart=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CmdbContextWithSession set the session into context if context includes session info</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CmdbContextWithSession</span><span class="params">(ctx context.Context, sess Session)</span></span> SessionContext &#123;</span><br><span class="line"><span class="keyword">return</span> contextWithSession(ctx, sess)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在mongo driver中添加了CmdbPrepareCommitOrAbort、 CmdbReloadSessio等方法</li></ul><p>这些在官方库是没有的，如果切换 go mod,从官方源获取依赖，肯定是不行的</p><p>issue：<a href="https://github.com/Tencent/bk-cmdb/issues/4748">https://github.com/Tencent/bk-cmdb/issues/4748</a></p><p>如果将修改后的官方库上传到github，应该可以解决go mod难切换的问题</p><p>会不会有版权问题？</p><p>所以，尽量不要修改官方库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址 &lt;a href=&quot;https://github.com/Tencent/bk-cmdb&quot;&gt;https://github.com/Tencent/bk-cmdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么不用官方推荐的 go mod 管理依赖呢？&lt;/p&gt;
&lt;p&gt;bk-cmdb v
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E7%9A%84%20Helloworld/"/>
    <id>http://example.com/2022/12/13/开发笔记/各种语言版本的 Helloworld/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>接触过C、C++、Java、C#、Python、Go，自认为接触过的编程语言很多了，那么各种语言的经典程序 Hello World 都是什么样的呢？</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello,World!&quot;);</span><br><span class="line">    return (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void main()                 </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello,World!\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello,World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace log&#123;</span><br><span class="line">    class helloworld&#123;</span><br><span class="line">        static void  Main(string[] args)&#123;</span><br><span class="line">            Console.WriteLine(&quot;Hello,World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello,World!&quot;</span><br></pre></td></tr></table></figure><p>Python3.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello,World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Printf(&quot;Hello,World!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello,World!&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接触过C、C++、Java、C#、Python、Go，自认为接触过的编程语言很多了，那么各种语言的经典程序 Hello World 都是什么样的呢？&lt;/p&gt;
&lt;h3 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/"/>
    <id>http://example.com/2022/12/13/开发笔记/服务缓存数据更新/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>内存缓存作为最方便的提升效率的手段，很多程序都有使用到。</p><p>缓存痛点：</p><ol><li>内存占用</li><li>缓存一致性</li><li>缓存并发</li></ol><p>怎么解决时效性，保证缓存能够及时更新：</p><p>更新方法：</p><ol><li>定时更新</li><li>动态更新</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存缓存作为最方便的提升效率的手段，很多程序都有使用到。&lt;/p&gt;
&lt;p&gt;缓存痛点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;缓存一致性&lt;/li&gt;
&lt;li&gt;缓存并发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;怎么解决时效性，保证缓存能够及时更新：&lt;/p&gt;
&lt;p&gt;更新方法：&lt;/
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2022/12/13/开发笔记/进程间通信技术/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://my.oschina.net/taogang/blog/4313908">https://my.oschina.net/taogang/blog/4313908</a></p><p>最早在Unix&#x2F;Linux的编程领域，提供了进程间通信的手段，例如：管道，信号量，消息队列，套接字（Socket）等。如果你的应用是由不同语言编写的，那么这里只能选择Socket通信作为应用之间的API手段。但是Socket通信是一种非常低Level的通信手段，它以底层的数据包作为抽象和通信内容，很难维护和使用。</p><p>早期的进程间通信技术包括：</p><ul><li>DCOM （ Distributed Component Object Model ）分布式组件对象模型，这个是微软的技术，只能用于Windows平台， 通过网络实现远程对象间的通信</li><li>RMI （ Remote Method Call) Java的远程方法调用，这个是Java自己的RPC，只能用于Java应用之间的远程调用。</li><li>JNI Java的本地接口， 支持Java应用调用本地方法，这个是跨越语言障碍的，但是仅仅局限于Java应用调用其它的本地应用，不具备互操作性，是个单项通道。</li></ul><h3 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h3><p>1991年一种名叫CORBA （ Common Object Request Broker Architecture ） 的技术出现。</p><p>CORBA和之前提到的DCOM和RMI类似，都提供了远程的对象&#x2F;方法调用，但是CORBA是一种与语言和实现无关的技术</p><p>CORBA定了与语言解耦的系统间通信的标准。开发CORAB的过程从IDL的定义开始，用户通过IDL定义了对象，然后在Server端实现该对象的应用逻辑，在Client端调用该对象。</p><p>CORBA存在的主要问题：</p><ul><li>对象的生命周期管理比较复杂。远程对象的发现，创建和销毁都会带来问题</li><li>整个CORAB的架构比较复杂</li></ul><h3 id="XML-RPC-x2F-SOAP"><a href="#XML-RPC-x2F-SOAP" class="headerlink" title="XML-RPC &#x2F; SOAP"></a>XML-RPC &#x2F; SOAP</h3><p>XML-RPC发表于1998年，由UserLand Software（UserLand Software）的Dave Winer及Microsoft共同发表。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协议。</p><p>下面是一个 XML-RPC的请求&#x2F;响应的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">  &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">  &lt;params&gt;</span><br><span class="line">    &lt;param&gt;</span><br><span class="line">        &lt;value&gt;&lt;i4&gt;40&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/param&gt;</span><br><span class="line">  &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodResponse&gt;</span><br><span class="line">  &lt;params&gt;</span><br><span class="line">    &lt;param&gt;</span><br><span class="line">        &lt;value&gt;&lt;string&gt;South Dakota&lt;/string&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/param&gt;</span><br><span class="line">  &lt;/params&gt;</span><br><span class="line">&lt;/methodResponse&gt;</span><br></pre></td></tr></table></figure><p>SOAP是 Simple Object Access Protocol 的缩写。SOAP为Web服务提供了Web服务协议栈的Messaging Protocol层。它是一个基于XML的协议，由三部分组成：</p><ol><li>一个信封，它定义了消息结构以及如何处理它</li><li>一组用于表达应用程序定义的数据类型实例的编码规则</li><li>表示过程调用和响应的约定</li></ol><p>SOAP具有三个主要特征：</p><ol><li>可扩展性（安全性和WS-Addressing在开发中）</li><li>中立性（SOAP可以通过HTTP，SMTP，TCP，UDP等任何协议进行操作）</li><li>独立性（SOAP允许任何编程语言）</li></ol><p>作为SOAP过程可以执行的操作的示例，应用程序可以将SOAP请求发送到启用了带有搜索参数的Web服务的服务器（例如，房地产价格数据库）。然后，服务器返回SOAP响应（包含结果数据的XML格式的文档），例如价格，位置，功能。由于生成的数据采用标准化的机器可解析格式，因此发出请求的应用程序可以直接将其集成。</p><p>SOAP体系结构由以下几层规范组成：</p><ul><li>讯息格式</li><li>邮件交换模式（MEP）</li><li>底层传输协议绑定</li><li>消息处理模型</li><li>协议可扩展性</li></ul><p>下面是一个SOAP消息的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 299</span><br><span class="line">SOAPAction: &quot;http://www.w3.org/2003/05/soap-envelope&quot;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:m=&quot;http://www.example.org&quot;&gt;</span><br><span class="line">  &lt;soap:Header&gt;</span><br><span class="line">  &lt;/soap:Header&gt;</span><br><span class="line">  &lt;soap:Body&gt;</span><br><span class="line">    &lt;m:GetStockPrice&gt;</span><br><span class="line">      &lt;m:StockName&gt;T&lt;/m:StockName&gt;</span><br><span class="line">    &lt;/m:GetStockPrice&gt;</span><br><span class="line">  &lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>相比较XML-RPC，他的功能更多，当然消息结构也更复杂。</p><p>SOAP是W3C推荐的Webservice标准，一度也是非常的流行，但是我们看到基于XML的消息比较复杂，消息本身因为XML的原因，有相当多的开销。于是后面又有了基于JSON的RPC格式。但总的来说，SOAP也已经是昨日黄花，当今的应用构建，你选它的概率应该也不大了。</p><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST是当今最为流行的API。因为大量的Web应用采用REST作为其API的选择。REST是 Representational State Transfer 的缩写。是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件&#x2F;程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。所以我么可以看到软件的发展，大体是从复杂变得简单，只有简单的东西才会变的更有生命力。</p><p>为了使任何应用程序真正实现RESTful，必须遵循六个体系结构约束：</p><ol><li>统一接口：意味着必须向Web应用程序中的API使用者提供API接口。</li><li>客户端服务器：客户端和服务器必须彼此独立，并且客户端应仅知道资源的URI。</li><li>无状态：服务器不得存储与客户端请求相关的任何内容。 客户端负责维护应用程序的状态。</li><li>可缓存的：资源必须可缓存。</li><li>分层系统：体系结构必须是分层的，这意味着体系结构的组件可以位于多个服务器中。</li><li>按需代码：客户端必须能够获取可执行代码作为响应。 这是一个可选约束。</li></ol><p>基于REST的Web服务被称为RESTful Web服务。 在这些应用程序中，每个组件都是一种资源，可以使用HTTP标准方法通过公共接口访问这些资源。 以下四种HTTP方法通常用于基于REST的体系结构中：</p><ol><li>GET-对资源的只读访问。</li><li>POST —创建一个新资源。</li><li>DELETE—删除资源。</li><li>PUT-更新现有资源&#x2F;创建新资源。</li></ol><p>RESTFul风格API所有的操作都是一个动词，对应HTTP请求的一种类型。每一个操作都定义了对操作的资源的某种行为。这种抽象，特别适合相当多的Web应用，后台是一个数据库，每一个REST的端点对应了一张数据库的表，很自然的利用REST操作来实现表的增删查改。</p><p>当然RESTFul的风格也有它的不足：</p><ul><li>不是所有的应用操作都可以用资源的增删查改来对应，在实际的开发中经常会需要把一个操作映射为一个资源这种不伦不类的行为。</li><li>REST是同步服务，如果需要可能要引入回调机制。例如Webhook。</li><li>REST只提供客户端调用服务器的选项，不支持服务器端发起请求。</li></ul><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>GraphQL是一个开源的API数据查询和操作语言及实现为了实现上述操作的相应运行环境。 2012年，GraphQL由Facebook内部开发，2015年公开公布。 2018年11月7日，Facebook将GraphQL项目转移到新成立的GraphQL基金会 。</p><p>GraphQL规范概述了5条设计原则，这使其成为现代前端开发的精心设计的解决方案:</p><ul><li>查询是分层结构的，具有分层和嵌套字段，查询与响应数据一对一匹配。 查询和响应的形状像树，可以查询每个项目的其他嵌套字段。</li><li>该结构以产品为中心，着重于前端希望如何接收数据，并构建交付所需的运行时。 这样一来，就可以向后端请求一个所需的所有数据，然后让服务器根据GraphQL的规范从不同的端点获取数据。</li><li>它使用特定于应用程序的类型系统，使开发人员能够确保查询使用有效类型，并且在执行之前在语法上正确。</li><li>GraphQL查询是在客户端指定的，因此客户端确切知道它将以什么格式接收数据。</li><li>带有GraphQL的服务器结构必须是自省的，或者可由GraphQL本身查询。 这将启用功能强大的开发人员工具，例如GraphiQL或GraphQL Playground，这两种工具都将使开发人员能够准确查看哪些查询和字段可供他们在服务器中使用。</li></ul><p>像RESTful API一样，GraphQL API旨在处理HTTP请求并提供对这些请求的响应。 但是，相似之处到此结束。 在REST API建立在请求方法和端点之间的连接上的情况下，GraphQL API设计为仅使用一个始终通过POST请求查询的端点，通常使用URL <a href="http://yourdomain.com/graphql%E3%80%82">yourdomain.com&#x2F;graphql。</a></p><p>达到GraphQL端点后，客户端请求的负担将完全在请求主体内处理。 该请求主体必须遵守GraphQL规范，并且API必须具有适当的服务器端逻辑来处理这些请求并提供适当的响应。 与RESTful API相比，这提供了更流畅的客户端体验，后者可能要求客户端对多个数据进行多次请求，并在数据返回后进行操作。</p><p>GraphQL提供的性能优于REST API，可以为前端开发人员带来回报。 使用GraphQL规范创建服务器可能需要更多设置和编写预测性服务器端逻辑来解析和处理请求。 尽管GraphQL的安装成本可能会高于传统的REST架构，但更具可维护性的代码，强大的开发工具以及简化的客户端查询，这些都是不错的收益。</p><p>除了灵活性这个最大的优点外，GraphQL还有以下的优点：</p><ul><li>声明性的数据获取，避免了客户端和服务器端的额外交互</li><li>优秀的开发体验，不需要版本控制，因为引入新的字段不会影响到API查询。同时客户端和服务器端的团队可以并行的独立工作。</li><li>强类型的GraphQL模式使得代码可预测，并及早发现错误。</li></ul><p>当然，GraphQL也不是没有缺点：</p><ul><li>使用GraphQL，如果您需要查找有关列表或记录集合的信息，则处理起来会很棘手。 例如，如果您想获取包含其地址的用户列表的详细信息，则它将执行n + 1个查询。 一个用于用户列表，然后n查询每个用户的地址。现在它会严重影响性能，因此必须非常小心地处理它。</li><li>很难缓存，缓存API响应的目的主要是为了更快地从将来的请求中获取响应。 与GraphQL不同，RESTful API可以利用HTTP规范中内置的缓存。 正如前面提到的，GraphQL查询可以请求资源的任何字段，因此缓存本质上是困难的。</li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC是一个开源的远程过程调用框架，用于在服务之间进行高性能的通信。 这是将以不同语言编写的服务与可插拔支持（用于负载平衡，跟踪，运行状况检查和身份验证）相连接的有效方法。 默认情况下，gRPC使用Protobuf（协议缓冲区）序列化结构化数据。 通常，对于微服务体系结构，gRPC被认为是REST协议的更好替代方案。 gRPC中的” g”可以归因于最初开发该技术的Google。</p><p>gRPC是对传统RPC框架的改编。 那么，它与现有的RPC框架有何不同？</p><p>最重要的区别是gRPC使用protobuf 协议缓冲区作为接口定义语言进行序列化和通信，而不是JSON &#x2F; XML。 协议缓冲区可以描述数据的结构，并且可以从该描述中生成代码，以生成或解析表示结构化数据的字节流。 这就是为什么gRPC首选多语言（使用不同技术实现）的Web应用程序的原因。 二进制数据格式使通信更轻松。 gRPC也可以与其他数据格式一起使用，但是首选的是protobuf。</p><p>同样，gRPC建立在HTTP &#x2F; 2之上，它支持双向通信以及传统的请求&#x2F;响应。 gRPC允许服务器和客户端之间的松散耦合。 在实践中，客户端打开与gRPC服务器的长期连接，并且将为每个RPC调用打开一个新的HTTP &#x2F; 2流。</p><p>与使用JSON（主要是JSON）的REST不同，gRPC使用Protobuf，这是编码数据的更好方法。 由于JSON是基于文本的格式，因此它比protobuf格式的压缩数据要重得多。与REST相比，gRPC的另一个显着改进是它使用HTTP 2作为其传输协议。 REST使用的HTTP 1.1基本上是一个请求-响应模型。 gRPC利用HTTP 2的双向通信功能以及传统的响应请求结构。 在HTTP 1.1中，当多个请求来自多个客户端时，它们将被一一处理。 这会降低系统速度。 HTTP 2允许多路复用，因此可以同时处理多个请求和响应。</p><p>gRPC的开发模式和之前提到的CORBA有些类似。Protobuf充当了IDL的角色，然后利用工具生成各种语言的代码，最后在生成的代码上实现服务器端和客户端的逻辑。</p><p>gRPC的优点是：</p><ul><li>出色的性能，因为采用protobuf编码和http&#x2F;2</li><li>支持服务器端和客户端的双向通信</li><li>易用，相比REST开发，需要更少的代码</li></ul><p>缺点：</p><ul><li>更陡峭的学习曲线</li><li>支持的语言的种类没有REST多，当然它还在发展中</li><li>因为需要Protobuf的编译，这带来了服务器和客户端一定的耦合，因为接口变动的时候需要重新编译生成代码。REST的化，基于不同的工具链可能由不同的解决方案</li></ul><p>因为其高性能，gRPC更适合被用于系统内部组件的通信选择。比如微服务架构中，对外的服务采用了REST或者GraphQL的API，而内部微服务之间使用的是gRPC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自 &lt;a href=&quot;https://my.oschina.net/taogang/blog/4313908&quot;&gt;https://my.oschina.net/taogang/blog/4313908&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最早在Unix&amp;#x2F;Linux的编程领域，提
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/golang/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://example.com/2022/12/13/开发笔记/golang/学习大纲/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="golang" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/golang/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/2020%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/2020 学习计划（成长之路）/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>2020 学习计划（成长之路）</p><p>领导怎么说：</p><p>k8s</p><p>docker</p><p>多读源码</p><p>逛逛开源社区</p><p>提高英文文档阅读能力</p><p>设计模式，工作中体现</p><p>一个优秀的软件架构师，首先一定是一个出色的程序员</p><p>eBay的架构师[RandyShoup先生]是如何总结架构师在项目中的职责的：</p><p>l 具备丰富的一线大中型开发项目的整体规划、方案设计及技术队伍管理经验。</p><p>2 具备软件行业工作经验，熟悉业务领域的技术应用和发展。</p><p>3 具有项目管理理论基础，并在应用系统开发平台和项目管理上有实践经验。</p><p>4 对相关的技术标准有深刻的认识，对软件工程标准规范有良好的把握。 具备C&#x2F;S或B&#x2F;S体系结构或特定领域软件产品开发及架构和设计的经验。</p><p>5 具有面向对象分析（Object-Oriented Analysis, OOA）、设计（OOD）、开发（OOP）能力，精通UML和XML等，熟练使用Rational Rose、PowerDesigner等CASE工具进行设计开发。</p><p>6 对相关编程技术及整个解决方案有深刻的理解及熟练的应用，并且精通架构和设计模式，并在此基础上设计产品框架。</p><p>7 精通大型数据库如Oracle、Sql Server、MySQL等的开发。l 对计算机系统、网络和安全、应用系统架构等有全面的认识。</p><p>8 良好的团队意识和写作精神，有较强的内外沟通能力。</p><p>学习计划：</p><p>\1. Java 基础知识的深入理解</p><p>反射、IO、接口&#x2F;抽象类、内部类、异常、Enum、序列化、static、final、Iterator，Iterable和Comparable,Comparator 等等知识点，虽然都有学习，按实际上还差得很远，还有很多细节与需要深入学习理解。还应该尝试看 Java 源码，源码阅读理解是程序员成长中的必经之路，在源码中可以得到更多细节。最近在看《On Java 8》(事实上的 《Java 编程思想》第五版)这本书，书中讲解真的很详细，内容也非常多，需要反复深入学习。2020 年需要攻克完成这本书，不单单只是阅读浏览一遍，应该要融会贯通，对晦涩难懂的知识多思考，争取掌握。</p><p>\2. 设计模式</p><p>设计模式很重要，支撑起代码的整个生命历程。设计模式应该被理解，被应用到项目中，而不是只是简单的概念层面上的了解，当然，也不应该生搬硬套。能够简化流程，优化项目的设计模式，才是好的设计模式。2020年希望能够掌握常用的设计模式，理解设计模式的套路，加深编程经验。完成《大话设计模式》这本书的学习理解。四人帮(GOF)的书籍《. Design Patterns》可能较之有一定的学习难度，但是经典还是需要了解。</p><p>\3. 微服务、容器等知识</p><p>现如今，微服务非常重要，阿里系的Dubbo+Zookeeper，Spring系的SpringCloud，以及在此基础上二次开发可能更优秀的SpringCloud。主要学习SpringCloud。</p><p>Docker 是微服务中至关重要的工具，也需要学习。之前有比较简单的学习，还需要深入学习，注意在实践中多使用 Docker 技术，争取融会贯通，学以致用。</p><p>kubernetes 也需要学习理解，这是基于容器的集群管理平台，现在事实上的标准，需要掌握。主要通过网课学习。</p><p>\4. 分布式架构</p><p>分布式缓存、分布式存储、分布式锁、幂等性、分布式事务、流量削峰、服务容错、服务降级等等，现在的分布式太火了，必须要对分布式有一定的理解和把握。计划是通过网课学习分布式架构。</p><p>\5. 数据库等知识</p><p>常用的关系型数据库有MySQL、Oracle、DB2等，MySQL应该是使用最多的，深入学习和掌握MySQL，是高级程序员的基本要求。还又 Redis、消息中间件等也需要有一定的知识储备。</p><p>\6. 开发工具</p><p>开发工具保证了开发效率，现在基本上离不开开发工具了，一个项目的开发到部署的过程都设计到许多的软件工具。作为使用者和潜在使用者，更应该对它们有深入的了解，就算是最熟悉的 idea, 我也不敢说完全掌握，Idea、maven、git、svn、jenkins、tomcat 等等也需要学习掌握。</p><p>\7. 提高英语水平</p><p>如今流行的编程语言都是贴近英语语法。大家更倾向于写出来的代码是好读易懂的。能够快速的理解原作者的用词，就可以更快的读懂代码结构，这比纯粹的分析编程语法要简单且自然的多。</p><p>能够流畅的阅读英文文档，对于程序员而言，是非常重要的。这也是非常艰难的，英语也确实是我的短板，提高的英语的阅读能力，通过逼迫自己去看，去理解英文来实现，尝试去读英文的工具文档、逛外国的开发论坛，stackoverflow、github。YouTube、Reddit、ins 等也可以多逛逛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020 学习计划（成长之路）&lt;/p&gt;
&lt;p&gt;领导怎么说：&lt;/p&gt;
&lt;p&gt;k8s&lt;/p&gt;
&lt;p&gt;docker&lt;/p&gt;
&lt;p&gt;多读源码&lt;/p&gt;
&lt;p&gt;逛逛开源社区&lt;/p&gt;
&lt;p&gt;提高英文文档阅读能力&lt;/p&gt;
&lt;p&gt;设计模式，工作中体现&lt;/p&gt;
&lt;p&gt;一个优秀的软件架构师，首先
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/JTW%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/JTW详解/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JTW详解</strong></p><p><strong>spring boot集成jwt实现token认证；</strong></p><p>\1. 什么是jwt?</p><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。</p><p>\2. jwt的工作流程</p><p>\1. 用户使用账号和密码发出post请求；</p><p>\2. 服务器使用私钥创建一个jwt；</p><p>\3. 服务器返回这个jwt给浏览器；</p><p>\4. 浏览器将该jwt串在请求头中向服务器发送请求；</p><p>\5. 服务器验证该jwt；</p><p>\6. 返回响应的资源给浏览器。</p><p><img src="C:\Users\14133\AppData\Local\YNote\data\m18378511016@163.com\f5f9098e49bc44e887b4c730a09776c1\jwt.png" alt="img"></p><p>\3. jwt结构</p><p>1）Header 头部：JWT的头部承载两部分信息：token类型和采用的加密算法。</p><p>2）Payload：存放有效信息的地方。</p><p>3）Signature：签证信息。</p><p>（完整见博客<a href="https://www.jianshu.com/p/e88d3f8151db%EF%BC%89">https://www.jianshu.com/p/e88d3f8151db）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JTW详解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring boot集成jwt实现token认证；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\1. 什么是jwt?&lt;/p&gt;
&lt;p&gt;Json web token (JWT), 是为了在网络应用环境间传递声明
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/JVM%E4%B8%8EJava%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/JVM与Java程序/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>当启动一个Java程序时，一个JVM实例也就产生。当该程序关闭退出，这个JVM实例也就随之消亡。</p><p>JVM实例负责运行一个Java程序</p><h4 id="Java虚拟机及程序的生命周期："><a href="#Java虚拟机及程序的生命周期：" class="headerlink" title="Java虚拟机及程序的生命周期："></a>Java虚拟机及程序的生命周期：</h4><p>（1）通过java命令运行一个Java程序时，启动一个Java虚拟机进程；</p><p>（2）Java虚拟机进程从启动到终止的过程，称为Java虚拟机生命周期；</p><p>（3）程序生命周期和Java虚拟机生命周期是一致的，因为Java虚拟机进程从创建起的任务就是执行Java程序。</p><p>（4）每个运行中的Java程序会有独立的Java堆和非堆等物理资源，程序之间的jvm运行时状态是区分的。</p><h4 id="类的加载，连接和初始化："><a href="#类的加载，连接和初始化：" class="headerlink" title="类的加载，连接和初始化："></a>类的加载，连接和初始化：</h4><p>Java程序要使用某个类时，Java虚拟机要确保这个类被加载，连接和运行，其中连接包括验证，准备和解析。</p><p>1、装载：查找并加载类的二进制数据</p><p>装载的最终目标是实现将编译后的class文件（class文件采用字节码，是JVM的机器语言）装入内存运行时数据区的方法区中，并在内存运行时数据区的堆区生成一个class对象，这个对象可以引用到方法区中的类定义</p><p>2、连接</p><p>（1）验证：确保加载类的正确性；</p><p>（2）准备：为静态变量分配内存，并将其初始化为默认值；</p><p>（3）解析：将类中的符号引用转换为直接引用。</p><p>3、初始化：</p><p>类的初始化过程是执行类的初始化语句，包括静态变量的声明语句，以及静态代码块，静态代码块的作用即是为静态变量赋初始化值。</p><p>4、卸载</p><p>只有没有任何引用指向Class对象的时候，这时候才会卸载类，结束类的生命周期。</p><p>装载验证准备解析初始化对象实例化垃圾收集对象终结卸载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当启动一个Java程序时，一个JVM实例也就产生。当该程序关闭退出，这个JVM实例也就随之消亡。&lt;/p&gt;
&lt;p&gt;JVM实例负责运行一个Java程序&lt;/p&gt;
&lt;h4 id=&quot;Java虚拟机及程序的生命周期：&quot;&gt;&lt;a href=&quot;#Java虚拟机及程序的生命周期：&quot; class
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java 归并排序【转】/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>归并排序是一种概念上最简单的排序算法，与快速排序一样，归并排序也是基于分治法的。归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。合并两个子序列的过程也就是两路归并。</p><h3 id="2、复杂度"><a href="#2、复杂度" class="headerlink" title="2、复杂度"></a>2、复杂度</h3><p>归并排序是一种稳定的排序算法，归并排序的主要问题在于它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是nlog2n。 </p><p>我们可以通过下图非常容易看懂归并排序的过程： </p><p><img src="https://note.youdao.com/yws/api/personal/file/F94C8510579B48B38D52AC97D3E6C1B7?method=download&shareKey=65d334fbb49d6f315cc8421850dd33a4" alt="归并排序过程"></p><p>时间复杂度：</p><p><img src="https://note.youdao.com/yws/api/personal/file/E039B66FD79B46A4937A8C90D1AD018A?method=download&shareKey=f45e4224c86dbd0af47e81c6b20cb574" alt="归并排序复杂度"></p><h3 id="3、完整Java代码"><a href="#3、完整Java代码" class="headerlink" title="3、完整Java代码"></a>3、完整Java代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    //两路归并算法，两个排好序的子序列合并为一个子序列</span><br><span class="line">    public void merge(int []a,int left,int mid,int right)&#123;</span><br><span class="line">        int []tmp=new int[a.length];//辅助数组</span><br><span class="line">        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            if(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            else</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span><br><span class="line">        while(p2&lt;=right) tmp[k++]=a[p2++];//同上</span><br><span class="line"></span><br><span class="line">        //复制回原素组</span><br><span class="line">        for (int i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int [] a,int start,int end)&#123;</span><br><span class="line">        if(start&lt;end)&#123;//当子序列中只有一个元素时结束递归</span><br><span class="line">            int mid=(start+end)/2;//划分子序列</span><br><span class="line">            mergeSort(a, start, mid);//对左侧子序列进行递归排序</span><br><span class="line">            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序</span><br><span class="line">            merge(a, start, mid, end);//合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;;</span><br><span class="line">        mergeSort(a, 0, a.length-1);</span><br><span class="line">        System.out.println(&quot;排好序的数组：&quot;);</span><br><span class="line">        for (int e : a)</span><br><span class="line">            System.out.print(e+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/qq_36442947/article/details/81612870">https://blog.csdn.net/qq_36442947/article/details/81612870</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h3 id=&quot;1、原理&quot;&gt;&lt;a href=&quot;#1、原理&quot; class=&quot;headerlink&quot; title=&quot;1、原理&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java8新特性/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java8新特性</strong></p><p>（转载自<a href="https://www.runoob.com/java/java8-new-features.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E8%A7%81%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%94%A8%EF%BC%89">https://www.runoob.com/java/java8-new-features.html，具体内容见链接，非常详细实用）</a></p><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><ul><li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li><strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Java8新特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（转载自&lt;a href=&quot;https://www.runoob.com/java/java8-new-features.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%86%85%E5%
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java创建线程的4种方式/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h4><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程</p><h3 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2. 同步与异步"></a>2. 同步与异步</h3><p>同步（Synchronous）：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</p><p>异步（Asynchronous）：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理。</p><p>通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作</p><h3 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3. 并行与并发"></a>3. 并行与并发</h3><p>并行：时间上是由重叠的，也就是说并行才是真正意义上的同一时刻可以有多个任务同时执行。</p><p>并发：任务在执行的时候，并发是没有时间上的重叠的，两个任务是交替执行的，由于切换的非常快，对于外界调用者来说相当于同一时刻多个任务一起执行了。</p><h3 id="二、Java创建线程的3种方式"><a href="#二、Java创建线程的3种方式" class="headerlink" title="二、Java创建线程的3种方式"></a>二、Java创建线程的3种方式</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h4><ol><li>定义 Thread 类的子类,并重写该类的 run() 方法,该 run() 方法的方法体就代表了线程需要完成的任务.因此把 run() 方法称为线程执行体。</li><li>创建 Thread 子类的实例,即创建了线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">public MyThread() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int i=0;i&lt;10;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyThread mThread1=new MyThread();</span><br><span class="line">MyThread mThread2=new MyThread();</span><br><span class="line">MyThread myThread3=new MyThread();</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 Runnable 接口</h4><ol><li>定义 Runnable 接口的实现类,并重写该接口的 run() 方法,该 run() 方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable 实现类的实例,并以此实例作为 Thread 的target来创建 Thread 对象,该 Thread 对象才是真正的线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable&#123;</span><br><span class="line">public static int count=20;</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(count&gt;0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(200);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;-当前剩余票数:&quot;+count--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyThread Thread1=new MyThread();</span><br><span class="line">Thread mThread1=new Thread(Thread1,&quot;线程1&quot;);</span><br><span class="line">Thread mThread2=new Thread(Thread1,&quot;线程2&quot;);</span><br><span class="line">Thread mThread3=new Thread(Thread1,&quot;线程3&quot;);</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用此方式</p><h4 id="3-使用-Callable-和-Future"><a href="#3-使用-Callable-和-Future" class="headerlink" title="3. 使用 Callable 和 Future"></a>3. 使用 Callable 和 Future</h4><ol><li>创建 Callable 接口的实现类,并实现 call() 方法,该 call() 方法将作为线程执行体,且该 call() 方法有返回值,再创建 Callable 实现类的实例。</li><li>使用 FutureTask 类来包装 Callable 对象,该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"> </span><br><span class="line">public class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line">private int count = 20;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public String call() throws Exception &#123;</span><br><span class="line">for (int i = count; i &gt; 0; i--) &#123;</span><br><span class="line">        //Thread.yield();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;当前票数：&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">return &quot;sale out&quot;;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">Callable&lt;String&gt; callable  =new MyThread();</span><br><span class="line">FutureTask &lt;String&gt;futureTask=new FutureTask&lt;&gt;(callable);</span><br><span class="line">Thread mThread=new Thread(futureTask);</span><br><span class="line">Thread mThread2=new Thread(futureTask);</span><br><span class="line">Thread mThread3=new Thread(futureTask);</span><br><span class="line">        //mThread.setName(&quot;hhh&quot;);</span><br><span class="line">mThread.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">mThread3.start();</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h4><p>通过 <code>java.util.concurrent.Executors</code> 的工具类可以创建三种类型的普通线程池：</p><h5 id="1-SingleThreadPoolExecutor-单线程池"><a href="#1-SingleThreadPoolExecutor-单线程池" class="headerlink" title="(1)SingleThreadPoolExecutor :单线程池"></a>(1)SingleThreadPoolExecutor :单线程池</h5><p>适用于需要保证顺序执行各个任务的场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-FixThreadPool-int-n-固定大小的线程池"><a href="#2-FixThreadPool-int-n-固定大小的线程池" class="headerlink" title="(2) FixThreadPool(int n); 固定大小的线程池"></a>(2) FixThreadPool(int n); 固定大小的线程池</h5><p>使用于为了满足资源管理需求而需要限制当前线程数量的场合。使用于负载比较重的服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-CashedThreadPool-缓存线程池"><a href="#5-CashedThreadPool-缓存线程池" class="headerlink" title="(5)CashedThreadPool(); 缓存线程池"></a>(5)CashedThreadPool(); 缓存线程池</h5><p>当提交任务速度高于线程池中任务处理速度时，缓存线程池会不断的创建线程 适用于提交短期的异步小程序，以及负载较轻的服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;h4 id=&quot;1-线程与进程&quot;&gt;&lt;a href=&quot;#1-线程与进程&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java序列化与反序列化/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、序列化"><a href="#1、序列化" class="headerlink" title="1、序列化"></a>1、序列化</h4><p>把对象转换为字节序列的过程。</p><h4 id="2、反序列化"><a href="#2、反序列化" class="headerlink" title="2、反序列化"></a>2、反序列化</h4><p>把字节序列恢复为对象的过程。</p><h4 id="3、对象的序列化主要有两种用途："><a href="#3、对象的序列化主要有两种用途：" class="headerlink" title="3、对象的序列化主要有两种用途："></a>3、对象的序列化主要有两种用途：</h4><p>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</p><p>2） 在网络上传送对象的字节序列。</p><h4 id="4、serialVersionUID的作用"><a href="#4、serialVersionUID的作用" class="headerlink" title="4、serialVersionUID的作用"></a>4、serialVersionUID的作用</h4><p>对象序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p><p>如果没有显式定义serialVersionUID，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以class有了修改之后，已修改类的serialVersionUID和之前已经序列化的文件流中的类的的serialVersionUID是不一致的，处于安全机制考虑，程序抛出了错误，并且拒绝载入。</p><p>如果显式定义了serialVersionUID，在序列化后，在类中添加字段，或者方法，不会影响到后期的还原。可以说serialVersionUID是序列化和反序列化之间彼此认识的唯一信物。</p><p>显式地定义serialVersionUID有两种用途：</p><p>1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p><p>2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、序列化&quot;&gt;&lt;a href=&quot;#1、序列化&quot; class=&quot;headerlink&quot; title=&quot;1、序列化&quot;&gt;&lt;/a&gt;1、序列化&lt;/h4&gt;&lt;p&gt;把对象转换为字节序列的过程。&lt;/p&gt;
&lt;h4 id=&quot;2、反序列化&quot;&gt;&lt;a href=&quot;#2、反序列化&quot; class
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java异常处理原则/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java的异常处理原则</strong></p><p>Java异常处理中的“反例”：</p><ol><li>丢弃异常</li></ol><p>捕获了异常却不作任何处理，可以算得上Java编程中的杀手。调用一下printStackTrace算不上“处理异常”。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。</p><ol><li>不指定具体的异常</li></ol><p>用一个catch语句捕获所有的异常。最常见的情形就是使用catch（Exception ex）语句。在catch语句中尽可能指定具体的异常类型，必要时使用多个catch.不要试图处理所有可能出现的异常。 </p><ol><li>占用资源不释放</li></ol><p>如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。Java提供了一个简化这类操作的关键词finally。 保证所有资源都被正确释放。充分运用finally关键词。 </p><ol><li>不说明异常的详细信息</li></ol><p>在出现异常时，最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。 </p><ol><li>过于庞大的try块</li></ol><p>一些新手常常把大量的代码放入单个try块，然后再在catch语句中声明Exception，而不是分离各个可能出现异常的段落并分别捕获其异常。这种做法为分析程序抛出异常的原因带来了困难，因为一大段代码中有太多的地方可能抛出Exception。应尽量减小try块的体积。 </p><ol><li>输出数据不完整</li></ol><p>不完整的数据是Java程序的隐形杀手。出现异常导致输出数据不完整，应该加入提示说明。全面考虑可能出现的异常以及这些异常对执行流程的影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Java的异常处理原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java异常处理中的“反例”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丢弃异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;捕获了异常却不作任何处理，可以算得上Java编程中的杀手。调用一下printStackTrace算不上“处
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/13/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2022/12/13/开发笔记/java/Java构造函数细节/</id>
    <published>2022-12-13T04:34:58.261Z</published>
    <updated>2022-12-13T04:34:58.261Z</updated>
    
    <content type="html"><![CDATA[<p>（1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。</p><p>注意: 有时候无参构造函数是必须的，比如用 @RequestBody 接收参数对象，如果没有无参数构造函数，无法正确接收参数，报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON parse error: Can not construct instance of xxx: no suitable constructor found, can not deserialize from Object value</span><br></pre></td></tr></table></figure><p>（2）. 在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的。因为构造函数的名称都相同。</p><p>构造函数与普通函数的区别：</p><ol><li>一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。</li><li>构造函数是在对象建立时由 jvm 调用, 给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。</li><li>普通函数可以使用对象多次调用，构造函数就在创建对象时调用。</li><li>构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。</li><li>构造函数没有返回值类型。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。&lt;/p&gt;
&lt;p&gt;注意: 有时候无参构造函数是必须的，比如用 @RequestBody 接收参数对象，如果没有无参数
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
</feed>

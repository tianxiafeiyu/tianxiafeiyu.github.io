<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dalin blog</title>
  
  
  <link href="https://tianxiafeiyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://tianxiafeiyu.github.io/"/>
  <updated>2023-06-16T08:44:56.413Z</updated>
  <id>https://tianxiafeiyu.github.io/</id>
  
  <author>
    <name>Dalin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的新冠经历</title>
    <link href="https://tianxiafeiyu.github.io/2023/06/16/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/%E6%88%91%E7%9A%84%E6%96%B0%E5%86%A0%E7%BB%8F%E5%8E%86/"/>
    <id>https://tianxiafeiyu.github.io/2023/06/16/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/%E6%88%91%E7%9A%84%E6%96%B0%E5%86%A0%E7%BB%8F%E5%8E%86/</id>
    <published>2023-06-16T08:44:56.413Z</published>
    <updated>2023-06-16T08:44:56.413Z</updated>
    
    <content type="html"><![CDATA[<p>从彻底放开两周以后，身边的同事陆陆续续都有了症状，工位上的人一个个消失。。。</p><p>12.21 日，早上起来我便感觉有一点点不舒服，头有点晕，嗓子也有点不舒服，不过症状很小，我还安慰是自己吓自己，再加上认为新冠也就那样，所以不是很在意。<br>这一天正常上班，一整天下来，确实有点无力的感觉，喉咙的异物感越来越重，我便知道这次是真的来了。这天晚上很难入睡，翻来覆去睡不着。</p><p>22号早上醒来，我便感觉头昏脑胀，喉咙已经哑了，我赶紧跟领导请了假，拿出温度计量体温，不到37度，还没有开始烧。不过我整个人已经像火炉一样了，冒着热气。这一天整个人是无精打采的，<br>很明显的感冒症状，但是有感觉哪里不同。</p><p>23号开始高烧了，一度烧到39度多，一整夜没睡，躺床上仿佛过了一个世纪，但是一看表，才凌晨两点钟，夜还长着，一夜无眠。临近早上，才昏昏沉沉睡过去，醒来时已经快11点了。<br>这期间身体发烧，但是身体又发冷，又热又冷，冰火两重天。喉咙倒是没有进一步恶化，不是熟悉的扁桃体炎。</p><p>周末这两天，我几乎都是躺在床上，发烧还没退，身体冻得直哆嗦。不过，烧页渐渐的退了下来，趋于平缓，我开始洗热水澡。</p><p>26号周一，烧退的差不多了，开始远程上班，但是整个人都没有精神，工作不下去。</p><p>27号依然如此，咳嗽还一直再，有浓痰，身体完全虚了，多运动几下就喘得不行，也许是我呆久了吧。</p><p>今天28号，已经过去一周了，现在烧已经完全退了下来，我倒是不再担心复烧了，只是还是很没有精神，感觉哪里出了问题。</p><p>这个新冠没有想的那么简单，确实有一定的严重性，不同于普通的感冒发烧。很难想象，之前刚爆发时，是怎么过来的。虽然我全程没有吃药，全靠身体免疫力撑了过来，但是感觉已经元气大伤，不知道要过好久才能恢复呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从彻底放开两周以后，身边的同事陆陆续续都有了症状，工位上的人一个个消失。。。&lt;/p&gt;
&lt;p&gt;12.21 日，早上起来我便感觉有一点点不舒服，头有点晕，嗓子也有点不舒服，不过症状很小，我还安慰是自己吓自己，再加上认为新冠也就那样，所以不是很在意。&lt;br&gt;这一天正常上班，一整天</summary>
      
    
    
    
    <category term="生活点滴" scheme="https://tianxiafeiyu.github.io/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://tianxiafeiyu.github.io/2023/06/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E4%B8%AD%E7%9A%84NULL%E5%80%BC%E8%A7%A3%E6%9E%90/"/>
    <id>https://tianxiafeiyu.github.io/2023/06/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/mysql%E4%B8%AD%E7%9A%84NULL%E5%80%BC%E8%A7%A3%E6%9E%90/</id>
    <published>2023-06-16T08:44:56.401Z</published>
    <updated>2023-06-16T08:44:56.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql中的NULL"><a href="#mysql中的NULL" class="headerlink" title="mysql中的NULL"></a>mysql中的NULL</h3><p>NULL在MySQL中是一个非常特殊的值，官方表述为“一个未知的值”，NULL不与任何值相等（包括其本身）。</p><h3 id="NULL的长度"><a href="#NULL的长度" class="headerlink" title="NULL的长度"></a>NULL的长度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select length(NULL), length(&#x27;&#x27;), length(0), length(FALSE);</span><br><span class="line">+--------------+------------+-----------+---------------+</span><br><span class="line">| length(NULL) | length(&#x27;&#x27;) | length(0) | length(FALSE) |</span><br><span class="line">+--------------+------------+-----------+---------------+</span><br><span class="line">|         NULL |          0 |         1 |             1 |</span><br><span class="line">+--------------+------------+-----------+---------------+</span><br></pre></td></tr></table></figure><p>可以看出空值’’的长度是0，是不占用空间的；而的NULL长度是NULL，是需要占用额外空间的，所以在一些开发规范中，建议将数据库字段设置为Not NULL,并且设置默认值’’或0。</p><p>NULL值占用字节空间，具体是多少呢，好像找不到权威的相关资料，部分资料说InnoDB中是1字节</p><h3 id="NULL对查询的影响"><a href="#NULL对查询的影响" class="headerlink" title="NULL对查询的影响"></a>NULL对查询的影响</h3><p>NULL对数学比较运算符（&gt;, &#x3D;, &lt;&#x3D;, &lt;&gt;）运算出的结果都是FALSE</p><p>NULL只支持IS NULL、IS NOT NULL、IFNULL()操作</p><p>MIN()、SUM()、COUNT()在运算时会忽略NULL值，但是COUNT(*)不会忽略；</p><p>DISTINCT、GROUP BY、ORDER BY中认为所有的NULL值都是相等的；ORDER BY认为NULL是最小的值</p><h3 id="NULL对索引的影响"><a href="#NULL对索引的影响" class="headerlink" title="NULL对索引的影响"></a>NULL对索引的影响</h3><p>MySQL中某一列数据含有NULL，并不一定会造成索引失效。</p><p>MySQL可以在含有NULL的列上使用索引</p><p>在有NULL值得字段上使用常用的索引，如普通索引、复合索引、全文索引等不会使索引失效。但是在使用空间索引的情况下，该列就必须为 NOT NULL。</p><h3 id="NULL对数据的影响"><a href="#NULL对数据的影响" class="headerlink" title="NULL对数据的影响"></a>NULL对数据的影响</h3><p>TIMESTAMP类型的字段被插入NULL时，实际写入到表中的是当前时间；</p><p>AUTO_INCREMENT属性的字段被插入NULL时，实际写入到表中的是顺序的下一个自增值</p><p>想要禁止某个字段被设置为NULL，则对此字段设置NOT NULL属性；</p><p>与oracle不同，mysql的唯一索引中允许有NULL字段，但是可能会出现意料之外的数据<br>比如，uniq_index(a, b, c), insert(1, 2, NULL)；insert(1, 2, NULL)都会成功</p><p>因为对于联合索引 a-b-c，1-2-NULL和1-2-NULL的比较结果总会返回false</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;mysql中的NULL&quot;&gt;&lt;a href=&quot;#mysql中的NULL&quot; class=&quot;headerlink&quot; title=&quot;mysql中的NULL&quot;&gt;&lt;/a&gt;mysql中的NULL&lt;/h3&gt;&lt;p&gt;NULL在MySQL中是一个非常特殊的值，官方表述为“一个未知的值”</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="database" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/"/>
    
    
  </entry>
  
  <entry>
    <title>每日游戏报告（2023-06-15）</title>
    <link href="https://tianxiafeiyu.github.io/2023/06/15/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/2023-06-15-game_report/"/>
    <id>https://tianxiafeiyu.github.io/2023/06/15/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/2023-06-15-game_report/</id>
    <published>2023-06-15T12:43:17.000Z</published>
    <updated>2023-06-15T12:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日游戏报告（2023-06-15）"><a href="#每日游戏报告（2023-06-15）" class="headerlink" title="每日游戏报告（2023-06-15）"></a>每日游戏报告（2023-06-15）</h1><h2 id="1-龙之信条：黑暗觉者"><a href="#1-龙之信条：黑暗觉者" class="headerlink" title="1. 龙之信条：黑暗觉者"></a>1. 龙之信条：黑暗觉者</h2><p>英文名：Dragon’s Dogma: Dark Arisen<br>标签：动作，冒险，角色扮演<br>原价：192¥<br>折扣率：84% 史低<br>好评率：89%好评率<br>国区价格：30.72¥<br>阿区价格：51.68ARS$ (1.52¥)<br>价格差：20.21倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/367500/header.jpg?t=1644282366" width="20%" height="20%" /> <h2 id="2-丧尸围城4"><a href="#2-丧尸围城4" class="headerlink" title="2. 丧尸围城4"></a>2. 丧尸围城4</h2><p>英文名：Dead Rising 4<br>标签：动作<br>原价：162¥<br>折扣率：75% 非史低<br>好评率：58%好评率<br>国区价格：40.5¥<br>阿区价格：80.58ARS$ (2.37¥)<br>价格差：17.09倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/543460/header.jpg?t=1644282464" width="20%" height="20%" /> <h2 id="3-生化危机启示录2"><a href="#3-生化危机启示录2" class="headerlink" title="3. 生化危机启示录2"></a>3. 生化危机启示录2</h2><p>英文名：Resident Evil Revelations 2<br>标签：动作，冒险<br>原价：38.08¥<br>折扣率：87% 非史低<br>好评率：78%好评率<br>国区价格：4.95¥<br>阿区价格：9.86ARS$ (0.29¥)<br>价格差：17.07倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/287290/header.jpg?t=1650867489" width="20%" height="20%" /> <h2 id="4-恶果"><a href="#4-恶果" class="headerlink" title="4. 恶果"></a>4. 恶果</h2><p>英文名：The Deed<br>标签：冒险，角色扮演<br>原价：6¥<br>折扣率：71% 史低<br>好评率：91%好评率<br>国区价格：1.74¥<br>阿区价格：3.74ARS$ (0.11¥)<br>价格差：15.82倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/420740/header.jpg?t=1680432083" width="20%" height="20%" /> <h2 id="5-Gun-Done"><a href="#5-Gun-Done" class="headerlink" title="5. Gun Done"></a>5. Gun Done</h2><p>英文名：Gun Done<br>标签：休闲，独立<br>原价：6¥<br>折扣率：50% 史低<br>好评率：89%好评率<br>国区价格：3¥<br>阿区价格：6.800000000000001ARS$ (0.2¥)<br>价格差：15.0倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/488280/header.jpg?t=1579358948" width="20%" height="20%" /> <h2 id="6-愤怒对抗：僵尸"><a href="#6-愤怒对抗：僵尸" class="headerlink" title="6. 愤怒对抗：僵尸"></a>6. 愤怒对抗：僵尸</h2><p>英文名：Rage Against The Zombies<br>标签：休闲，动作<br>原价：28¥<br>折扣率：80% 非史低<br>好评率：64%好评率<br>国区价格：5.6¥<br>阿区价格：13.26ARS$ (0.39¥)<br>价格差：14.36倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/556990/header.jpg?t=1593002766" width="20%" height="20%" /> <h2 id="7-Alien-Attack"><a href="#7-Alien-Attack" class="headerlink" title="7. Alien Attack"></a>7. Alien Attack</h2><p>英文名：Alien Attack<br>标签：休闲，动作，独立，冒险，模拟<br>原价：11¥<br>折扣率：70% 非史低<br>好评率：82%好评率<br>国区价格：3.3¥<br>阿区价格：7.82ARS$ (0.23¥)<br>价格差：14.35倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/391310/header.jpg?t=1575806208" width="20%" height="20%" /> <h2 id="8-纸境奇缘"><a href="#8-纸境奇缘" class="headerlink" title="8. 纸境奇缘"></a>8. 纸境奇缘</h2><p>英文名：Epistory - Typing Chronicles<br>标签：动作，独立，冒险<br>原价：74¥<br>折扣率：60% 非史低<br>好评率：94%好评率<br>国区价格：29.6¥<br>阿区价格：70.38ARS$ (2.07¥)<br>价格差：14.3倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/398850/header_schinese.jpg?t=1676570841" width="20%" height="20%" /> <h2 id="9-勿忘我"><a href="#9-勿忘我" class="headerlink" title="9. 勿忘我"></a>9. 勿忘我</h2><p>英文名：Remember Me<br>标签：动作，冒险<br>原价：135¥<br>折扣率：80% 史低<br>好评率：83%好评率<br>国区价格：27¥<br>阿区价格：64.6ARS$ (1.9¥)<br>价格差：14.21倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/228300/header.jpg?t=1644283394" width="20%" height="20%" /> <h2 id="10-旭丽玛诸神"><a href="#10-旭丽玛诸神" class="headerlink" title="10. 旭丽玛诸神"></a>10. 旭丽玛诸神</h2><p>英文名：Lords of Xulima<br>标签：角色扮演<br>原价：89¥<br>折扣率：30% 非史低<br>好评率：79%好评率<br>国区价格：62.3¥<br>阿区价格：154.36ARS$ (4.54¥)<br>价格差：13.72倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/296570/header.jpg?t=1572342414" width="20%" height="20%" /> <h2 id="11-热血格斗：大激战SP"><a href="#11-热血格斗：大激战SP" class="headerlink" title="11. 热血格斗：大激战SP"></a>11. 热血格斗：大激战SP</h2><p>英文名：River City Melee : Battle Royal Special<br>标签：体育，动作，冒险<br>原价：88¥<br>折扣率：85% 非史低<br>好评率：56%好评率<br>国区价格：13.2¥<br>阿区价格：32.98ARS$ (0.97¥)<br>价格差：13.61倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/544630/header.jpg?t=1667798091" width="20%" height="20%" /> <h2 id="12-迷你小偷"><a href="#12-迷你小偷" class="headerlink" title="12. 迷你小偷"></a>12. 迷你小偷</h2><p>英文名：Mini Thief<br>标签：休闲，独立，策略<br>原价：10¥<br>折扣率：77% 史低<br>好评率：71%好评率<br>国区价格：2.3¥<br>阿区价格：5.78ARS$ (0.17¥)<br>价格差：13.53倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/481870/header.jpg?t=1680430669" width="20%" height="20%" /> <h2 id="13-幽浮2"><a href="#13-幽浮2" class="headerlink" title="13. 幽浮2"></a>13. 幽浮2</h2><p>英文名：XCOM® 2<br>标签：策略<br>原价：190¥<br>折扣率：90% 非史低<br>好评率：84%好评率<br>国区价格：19¥<br>阿区价格：49.3ARS$ (1.45¥)<br>价格差：13.1倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/268500/header.jpg?t=1646157374" width="20%" height="20%" /> <h2 id="14-Save-the-Dodos"><a href="#14-Save-the-Dodos" class="headerlink" title="14. Save the Dodos"></a>14. Save the Dodos</h2><p>英文名：Save the Dodos<br>标签：休闲，独立<br>原价：15¥<br>折扣率：80% 史低<br>好评率：90%好评率<br>国区价格：3¥<br>阿区价格：7.82ARS$ (0.23¥)<br>价格差：13.04倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/428830/header.jpg?t=1564497673" width="20%" height="20%" /> <h2 id="15-Annie-Amber"><a href="#15-Annie-Amber" class="headerlink" title="15. Annie Amber"></a>15. Annie Amber</h2><p>英文名：Annie Amber<br>标签：休闲，独立，冒险<br>原价：15¥<br>折扣率：60% 非史低<br>好评率：56%好评率<br>国区价格：6¥<br>阿区价格：15.64ARS$ (0.46¥)<br>价格差：13.04倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/464440/header.jpg?t=1570537961" width="20%" height="20%" /> <h2 id="16-口袋王国"><a href="#16-口袋王国" class="headerlink" title="16. 口袋王国"></a>16. 口袋王国</h2><p>英文名：Pocket Kingdom<br>标签：独立，冒险<br>原价：34¥<br>折扣率：80% 史低<br>好评率：94%好评率<br>国区价格：6.8¥<br>阿区价格：18.36ARS$ (0.54¥)<br>价格差：12.59倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/462620/header.jpg?t=1593002311" width="20%" height="20%" /> <h2 id="17-丧尸围城3：天启版"><a href="#17-丧尸围城3：天启版" class="headerlink" title="17. 丧尸围城3：天启版"></a>17. 丧尸围城3：天启版</h2><p>英文名：Dead Rising 3 Apocalypse Edition<br>标签：动作<br>原价：115¥<br>折扣率：70% 非史低<br>好评率：75%好评率<br>国区价格：34.5¥<br>阿区价格：96.9ARS$ (2.85¥)<br>价格差：12.11倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/265550/header.jpg?t=1644282429" width="20%" height="20%" /> <h2 id="18-主机守护者"><a href="#18-主机守护者" class="headerlink" title="18. 主机守护者"></a>18. 主机守护者</h2><p>英文名：Mainframe Defenders<br>标签：独立，策略<br>原价：26¥<br>折扣率：90% 史低<br>好评率：89%好评率<br>国区价格：2.6¥<br>阿区价格：7.48ARS$ (0.22¥)<br>价格差：11.82倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/1184810/header_schinese.jpg?t=1677499497" width="20%" height="20%" /> <h2 id="19-生化危机：保护伞小队"><a href="#19-生化危机：保护伞小队" class="headerlink" title="19. 生化危机：保护伞小队"></a>19. 生化危机：保护伞小队</h2><p>英文名：Umbrella Corps<br>标签：动作<br>原价：112¥<br>折扣率：75% 史低<br>好评率：36%好评率<br>国区价格：28¥<br>阿区价格：80.58ARS$ (2.37¥)<br>价格差：11.81倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/390340/header_schinese.jpg?t=1650861592" width="20%" height="20%" /> <h2 id="20-月球6180"><a href="#20-月球6180" class="headerlink" title="20. 月球6180"></a>20. 月球6180</h2><p>英文名：6180 the moon<br>标签：休闲，动作，独立<br>原价：18¥<br>折扣率：61% 非史低<br>好评率：92%好评率<br>国区价格：7.02¥<br>阿区价格：20.4ARS$ (0.6¥)<br>价格差：11.7倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/299660/header.jpg?t=1590417855" width="20%" height="20%" /> <h2 id="21-轩辕剑外传-穹之扉"><a href="#21-轩辕剑外传-穹之扉" class="headerlink" title="21. 轩辕剑外传 穹之扉"></a>21. 轩辕剑外传 穹之扉</h2><p>英文名：Xuan-Yuan Sword: The Gate of Firmament<br>标签：角色扮演<br>原价：60¥<br>折扣率：70% 史低<br>好评率：72%好评率<br>国区价格：18¥<br>阿区价格：52.7ARS$ (1.55¥)<br>价格差：11.61倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/427030/header_schinese.jpg?t=1681968783" width="20%" height="20%" /> <h2 id="22-Space-Ribbon-Slipstream-to-the-Extreme"><a href="#22-Space-Ribbon-Slipstream-to-the-Extreme" class="headerlink" title="22. Space Ribbon - Slipstream to the Extreme"></a>22. Space Ribbon - Slipstream to the Extreme</h2><p>英文名：Space Ribbon - Slipstream to the Extreme<br>标签：休闲，体育，动作，独立，模拟，竞速<br>原价：18¥<br>折扣率：60% 非史低<br>好评率：60%好评率<br>国区价格：7.2¥<br>阿区价格：21.08ARS$ (0.62¥)<br>价格差：11.61倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/501220/header.jpg?t=1643280895" width="20%" height="20%" /> <h2 id="23-OctaFight"><a href="#23-OctaFight" class="headerlink" title="23. OctaFight"></a>23. OctaFight</h2><p>英文名：OctaFight<br>标签：休闲，动作，独立<br>原价：26¥<br>折扣率：70% 史低<br>好评率：None<br>国区价格：7.8¥<br>阿区价格：23.12ARS$ (0.68¥)<br>价格差：11.47倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/1196690/header.jpg?t=1667926949" width="20%" height="20%" /> <h2 id="24-Halloween-Mysteries"><a href="#24-Halloween-Mysteries" class="headerlink" title="24. Halloween Mysteries"></a>24. Halloween Mysteries</h2><p>英文名：Halloween Mysteries<br>标签：动作，独立，冒险<br>原价：22¥<br>折扣率：45% 非史低<br>好评率：54%好评率<br>国区价格：12.1¥<br>阿区价格：36.38ARS$ (1.07¥)<br>价格差：11.31倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/547090/header.jpg?t=1505062389" width="20%" height="20%" /> <h2 id="25-无尽魔塔"><a href="#25-无尽魔塔" class="headerlink" title="25. 无尽魔塔"></a>25. 无尽魔塔</h2><p>英文名：DungeonUp<br>标签：独立，冒险，策略<br>原价：22¥<br>折扣率：80% 非史低<br>好评率：84%好评率<br>国区价格：4.4¥<br>阿区价格：13.26ARS$ (0.39¥)<br>价格差：11.28倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/388620/header.jpg?t=1614781984" width="20%" height="20%" /> <h2 id="26-1000天逃生"><a href="#26-1000天逃生" class="headerlink" title="26. 1000天逃生"></a>26. 1000天逃生</h2><p>英文名：1000 days to escape<br>标签：休闲，独立<br>原价：22¥<br>折扣率：50% 非史低<br>好评率：82%好评率<br>国区价格：11¥<br>阿区价格：33.32ARS$ (0.98¥)<br>价格差：11.22倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/1103100/header.jpg?t=1592683941" width="20%" height="20%" /> <h2 id="27-梦游逃生"><a href="#27-梦游逃生" class="headerlink" title="27. 梦游逃生"></a>27. 梦游逃生</h2><p>英文名：Back to Bed<br>标签：休闲，动作，独立<br>原价：25¥<br>折扣率：80% 非史低<br>好评率：78%好评率<br>国区价格：5¥<br>阿区价格：15.3ARS$ (0.45¥)<br>价格差：11.11倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/308040/header.jpg?t=1683191893" width="20%" height="20%" /> <h2 id="28-DARQ"><a href="#28-DARQ" class="headerlink" title="28. DARQ"></a>28. DARQ</h2><p>英文名：DARQ: Complete Edition<br>标签：动作，独立，冒险<br>原价：70¥<br>折扣率：66% 非史低<br>好评率：93%好评率<br>国区价格：23.8¥<br>阿区价格：74.80000000000001ARS$ (2.2¥)<br>价格差：10.82倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/433550/header.jpg?t=1676922911" width="20%" height="20%" /> <h2 id="29-北方之魂"><a href="#29-北方之魂" class="headerlink" title="29. 北方之魂"></a>29. 北方之魂</h2><p>英文名：Spirit of the North<br>标签：休闲，独立，冒险<br>原价：70¥<br>折扣率：66% 非史低<br>好评率：87%好评率<br>国区价格：23.8¥<br>阿区价格：74.80000000000001ARS$ (2.2¥)<br>价格差：10.82倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/1213700/header.jpg?t=1653298628" width="20%" height="20%" /> <h2 id="30-火焰审判"><a href="#30-火焰审判" class="headerlink" title="30. 火焰审判"></a>30. 火焰审判</h2><p>英文名：Trials of Fire<br>标签：独立，策略，角色扮演<br>原价：70¥<br>折扣率：50% 非史低<br>好评率：87%好评率<br>国区价格：35¥<br>阿区价格：110.16000000000001ARS$ (3.24¥)<br>价格差：10.8倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/1038370/header_schinese.jpg?t=1680257206" width="20%" height="20%" /> <h2 id="31-极速大乱斗"><a href="#31-极速大乱斗" class="headerlink" title="31. 极速大乱斗"></a>31. 极速大乱斗</h2><p>英文名：Speed Brawl<br>标签：动作，独立，冒险<br>原价：70¥<br>折扣率：50% 非史低<br>好评率：80%好评率<br>国区价格：35¥<br>阿区价格：110.16000000000001ARS$ (3.24¥)<br>价格差：10.8倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/468670/header.jpg?t=1676303028" width="20%" height="20%" /> <h2 id="32-火星地平线"><a href="#32-火星地平线" class="headerlink" title="32. 火星地平线"></a>32. 火星地平线</h2><p>英文名：Mars Horizon<br>标签：独立，策略，模拟<br>原价：70¥<br>折扣率：50% 非史低<br>好评率：84%好评率<br>国区价格：35¥<br>阿区价格：110.16000000000001ARS$ (3.24¥)<br>价格差：10.8倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/765810/header.jpg?t=1668079709" width="20%" height="20%" /> <h2 id="33-魔境奇缘：文字大冒险"><a href="#33-魔境奇缘：文字大冒险" class="headerlink" title="33. 魔境奇缘：文字大冒险"></a>33. 魔境奇缘：文字大冒险</h2><p>英文名：Nanotale - Typing Chronicles<br>标签：冒险，角色扮演<br>原价：70¥<br>折扣率：30% 非史低<br>好评率：80%好评率<br>国区价格：49¥<br>阿区价格：154.36ARS$ (4.54¥)<br>价格差：10.79倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/944920/header.jpg?t=1646316362" width="20%" height="20%" /> <h2 id="34-复仇女神：神秘之旅3"><a href="#34-复仇女神：神秘之旅3" class="headerlink" title="34. 复仇女神：神秘之旅3"></a>34. 复仇女神：神秘之旅3</h2><p>英文名：Nemezis: Mysterious Journey III<br>标签：休闲，动作，独立，冒险，模拟<br>原价：70¥<br>折扣率：55% 史低<br>好评率：61%好评率<br>国区价格：31.5¥<br>阿区价格：99.28ARS$ (2.92¥)<br>价格差：10.79倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/986350/header.jpg?t=1686660880" width="20%" height="20%" /> <h2 id="35-永恒之柱2：死亡之火"><a href="#35-永恒之柱2：死亡之火" class="headerlink" title="35. 永恒之柱2：死亡之火"></a>35. 永恒之柱2：死亡之火</h2><p>英文名：Pillars of Eternity II: Deadfire<br>标签：角色扮演<br>原价：138¥<br>折扣率：75% 史低<br>好评率：87%好评率<br>国区价格：34.5¥<br>阿区价格：110.16000000000001ARS$ (3.24¥)<br>价格差：10.65倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/560130/header.jpg?t=1651025588" width="20%" height="20%" /> <h2 id="36-Exile-to-Death"><a href="#36-Exile-to-Death" class="headerlink" title="36. Exile to Death"></a>36. Exile to Death</h2><p>英文名：Exile to Death<br>标签：动作，独立，冒险，大型多人在线，角色扮演<br>原价：68¥<br>折扣率：90% 史低<br>好评率：5%好评率<br>国区价格：6.8¥<br>阿区价格：21.76ARS$ (0.64¥)<br>价格差：10.62倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/489240/header.jpg?t=1527865804" width="20%" height="20%" /> <h2 id="37-虚构"><a href="#37-虚构" class="headerlink" title="37. 虚构"></a>37. 虚构</h2><p>英文名：Figment<br>标签：休闲，动作，独立，冒险<br>原价：68¥<br>折扣率：80% 非史低<br>好评率：87%好评率<br>国区价格：13.6¥<br>阿区价格：43.86ARS$ (1.29¥)<br>价格差：10.54倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/493540/header_schinese.jpg?t=1683192068" width="20%" height="20%" /> <h2 id="38-逻辑机器人"><a href="#38-逻辑机器人" class="headerlink" title="38. 逻辑机器人"></a>38. 逻辑机器人</h2><p>英文名：LogicBots<br>标签：独立，模拟<br>原价：68¥<br>折扣率：80% 非史低<br>好评率：78%好评率<br>国区价格：13.6¥<br>阿区价格：43.86ARS$ (1.29¥)<br>价格差：10.54倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/290020/header.jpg?t=1667200292" width="20%" height="20%" /> <h2 id="39-苍翼默示录：连续变换-扩展版"><a href="#39-苍翼默示录：连续变换-扩展版" class="headerlink" title="39. 苍翼默示录：连续变换-扩展版"></a>39. 苍翼默示录：连续变换-扩展版</h2><p>英文名：BlazBlue: Continuum Shift Extend<br>标签：动作<br>原价：68¥<br>折扣率：85% 非史低<br>好评率：91%好评率<br>国区价格：10.2¥<br>阿区价格：32.98ARS$ (0.97¥)<br>价格差：10.52倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/294810/header.jpg?t=1667791718" width="20%" height="20%" /> <h2 id="40-旗帜的传说3"><a href="#40-旗帜的传说3" class="headerlink" title="40. 旗帜的传说3"></a>40. 旗帜的传说3</h2><p>英文名：The Banner Saga 3<br>标签：独立，策略，角色扮演<br>原价：85.01¥<br>折扣率：80% 史低<br>好评率：81%好评率<br>国区价格：17¥<br>阿区价格：55.080000000000005ARS$ (1.62¥)<br>价格差：10.49倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/485460/header.jpg?t=1642181012" width="20%" height="20%" /> <h2 id="41-旗帜的传说"><a href="#41-旗帜的传说" class="headerlink" title="41. 旗帜的传说"></a>41. 旗帜的传说</h2><p>英文名：The Banner Saga<br>标签：独立，策略，角色扮演<br>原价：85¥<br>折扣率：80% 非史低<br>好评率：88%好评率<br>国区价格：17¥<br>阿区价格：55.080000000000005ARS$ (1.62¥)<br>价格差：10.49倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/237990/header.jpg?t=1650912084" width="20%" height="20%" /> <h2 id="42-旗帜的传说2"><a href="#42-旗帜的传说2" class="headerlink" title="42. 旗帜的传说2"></a>42. 旗帜的传说2</h2><p>英文名：The Banner Saga 2<br>标签：独立，策略，角色扮演<br>原价：85¥<br>折扣率：80% 非史低<br>好评率：90%好评率<br>国区价格：17¥<br>阿区价格：55.080000000000005ARS$ (1.62¥)<br>价格差：10.49倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/281640/header.jpg?t=1642180902" width="20%" height="20%" /> <h2 id="43-镜中的我"><a href="#43-镜中的我" class="headerlink" title="43. 镜中的我"></a>43. 镜中的我</h2><p>英文名：Reflection of Mine<br>标签：独立，冒险<br>原价：31¥<br>折扣率：90% 史低<br>好评率：77%好评率<br>国区价格：3.1¥<br>阿区价格：10.2ARS$ (0.3¥)<br>价格差：10.33倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/476020/header.jpg?t=1675099653" width="20%" height="20%" /> <h2 id="44-龙之怒"><a href="#44-龙之怒" class="headerlink" title="44. 龙之怒"></a>44. 龙之怒</h2><p>英文名：Dragon Rage<br>标签：休闲，动作，独立<br>原价：28¥<br>折扣率：30% 非史低<br>好评率：74%好评率<br>国区价格：19.6¥<br>阿区价格：64.94ARS$ (1.91¥)<br>价格差：10.26倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/498190/header.jpg?t=1667127760" width="20%" height="20%" /> <h2 id="45-七人杀阵"><a href="#45-七人杀阵" class="headerlink" title="45. 七人杀阵"></a>45. 七人杀阵</h2><p>英文名：七人杀阵 - Seven Sacrifices<br>标签：休闲，独立，冒险<br>原价：28¥<br>折扣率：70% 史低<br>好评率：81%好评率<br>国区价格：8.4¥<br>阿区价格：27.88ARS$ (0.82¥)<br>价格差：10.24倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/885140/header.jpg?t=1676347022" width="20%" height="20%" /> <h2 id="46-野生动物园大亨2"><a href="#46-野生动物园大亨2" class="headerlink" title="46. 野生动物园大亨2"></a>46. 野生动物园大亨2</h2><p>英文名：Wildlife Park 2<br>标签：休闲，独立，策略，模拟<br>原价：28¥<br>折扣率：25% 非史低<br>好评率：70%好评率<br>国区价格：21¥<br>阿区价格：69.69999999999999ARS$ (2.05¥)<br>价格差：10.24倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/304350/header.jpg?t=1549964279" width="20%" height="20%" /> <h2 id="47-宝藏猎人模拟器"><a href="#47-宝藏猎人模拟器" class="headerlink" title="47. 宝藏猎人模拟器"></a>47. 宝藏猎人模拟器</h2><p>英文名：Treasure Hunter Simulator<br>标签：独立，模拟<br>原价：57¥<br>折扣率：90% 非史低<br>好评率：63%好评率<br>国区价格：5.7¥<br>阿区价格：19.38ARS$ (0.57¥)<br>价格差：10.0倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/748300/header.jpg?t=1686660546" width="20%" height="20%" /> <h2 id="48-Boiling-Bolt"><a href="#48-Boiling-Bolt" class="headerlink" title="48. Boiling Bolt"></a>48. Boiling Bolt</h2><p>英文名：Boiling Bolt<br>标签：动作，独立<br>原价：43¥<br>折扣率：80% 非史低<br>好评率：None<br>国区价格：8.6¥<br>阿区价格：29.24ARS$ (0.86¥)<br>价格差：10.0倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/462250/header.jpg?t=1656581705" width="20%" height="20%" /> <h2 id="49-亿万僵尸"><a href="#49-亿万僵尸" class="headerlink" title="49. 亿万僵尸"></a>49. 亿万僵尸</h2><p>英文名：They Are Billions<br>标签：策略<br>原价：95¥<br>折扣率：10% 非史低<br>好评率：85%好评率<br>国区价格：85.5¥<br>阿区价格：291.04ARS$ (8.56¥)<br>价格差：9.99倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/644930/header.jpg?t=1595631876" width="20%" height="20%" /> <h2 id="50-突变元年：伊甸园之路"><a href="#50-突变元年：伊甸园之路" class="headerlink" title="50. 突变元年：伊甸园之路"></a>50. 突变元年：伊甸园之路</h2><p>英文名：Mutant Year Zero: Road to Eden<br>标签：策略，角色扮演<br>原价：115¥<br>折扣率：60% 非史低<br>好评率：90%好评率<br>国区价格：46¥<br>阿区价格：156.74ARS$ (4.61¥)<br>价格差：9.98倍  </p><img src="https://media.st.dl.eccdnx.com/steam/apps/760060/header.jpg?t=1685714121" width="20%" height="20%" /> ]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;每日游戏报告（2023-06-15）&quot;&gt;&lt;a href=&quot;#每日游戏报告（2023-06-15）&quot; class=&quot;headerlink&quot; title=&quot;每日游戏报告（2023-06-15）&quot;&gt;&lt;/a&gt;每日游戏报告（2023-06-15）&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="生活点滴" scheme="https://tianxiafeiyu.github.io/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"/>
    
    
    <category term="每日游戏报告（2023-06-15）" scheme="https://tianxiafeiyu.github.io/tags/%E6%AF%8F%E6%97%A5%E6%B8%B8%E6%88%8F%E6%8A%A5%E5%91%8A%EF%BC%882023-06-15%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>使用Fillder抓包安卓APP</title>
    <link href="https://tianxiafeiyu.github.io/2023/06/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Fiddler%E6%8A%93%E5%8C%85%E5%AE%89%E5%8D%93APP/"/>
    <id>https://tianxiafeiyu.github.io/2023/06/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Fiddler%E6%8A%93%E5%8C%85%E5%AE%89%E5%8D%93APP/</id>
    <published>2023-06-15T12:00:00.000Z</published>
    <updated>2023-06-15T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fiddler-简介"><a href="#fiddler-简介" class="headerlink" title="fiddler 简介"></a>fiddler 简介</h2><p>Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指cookie,html,js,css等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。</p><h2 id="windows-端-fiddler-配置"><a href="#windows-端-fiddler-配置" class="headerlink" title="windows 端 fiddler 配置"></a>windows 端 fiddler 配置</h2><ol><li>允许https和远程连接</li><li>设置代理端口</li><li>获取本机ip地址</li></ol><h2 id="手机端-设置"><a href="#手机端-设置" class="headerlink" title="手机端 设置"></a>手机端 设置</h2><ol><li>wifi设置代理服务器，填写上面获取到的ip和设置的端口</li><li>浏览器访问 <a href="http://ip:port">http://ip:port</a></li><li>下载证书</li><li>设置里安装证书</li></ol><p>到此，fiddler 就可以抓手机上的请求了</p><h2 id="fiddler-使用"><a href="#fiddler-使用" class="headerlink" title="fiddler 使用"></a>fiddler 使用</h2><ol><li>请求过滤</li><li>格式化请求</li><li>获取响应体</li></ol><h2 id="实战，jump游戏资讯抓包"><a href="#实战，jump游戏资讯抓包" class="headerlink" title="实战，jump游戏资讯抓包"></a>实战，jump游戏资讯抓包</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;fiddler-简介&quot;&gt;&lt;a href=&quot;#fiddler-简介&quot; class=&quot;headerlink&quot; title=&quot;fiddler 简介&quot;&gt;&lt;/a&gt;fiddler 简介&lt;/h2&gt;&lt;p&gt;Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="使用Fillder抓包安卓APP" scheme="https://tianxiafeiyu.github.io/tags/%E4%BD%BF%E7%94%A8Fillder%E6%8A%93%E5%8C%85%E5%AE%89%E5%8D%93APP/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出设计模式</title>
    <link href="https://tianxiafeiyu.github.io/2023/02/28/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://tianxiafeiyu.github.io/2023/02/28/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-02-28T23:39:31.000Z</published>
    <updated>2023-02-28T23:39:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><strong>如果你也曾有这样的疑惑——怎样更优雅地实现需求？</strong></p><p>那么设计模式便是打开这扇门的钥匙。程序界无数的前辈们花费无数心血，将程序设计的几种方式归纳总结，整理出 23 种常用的设计模式，涵盖了对象创建、行为交互、结构梳理等方方面面。无论是在框架的学习中，抑或是代码实战中，设计模式都扮演着不可或缺的角色。</p><p><strong>你将：</strong></p><ul><li>系统归纳 3 大类设计模式，了解设计模式的 6 大原则</li><li>从生活中的例子出发，学习 23 种设计模式</li><li>在实战环节学习设计模式的应用</li></ul><p><strong>你可以这样学：</strong></p><ul><li>通过知识讲解与代码示例结合的方式深入理解各类设计模式</li><li>通过配套习题巩固学习内容</li><li>通过场景实战逐步掌握设计模式的应用</li><li>在评论区中与小伙伴一起沟通交流学习经验</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概述-Introduction"><a href="#概述-Introduction" class="headerlink" title="概述 Introduction"></a>概述 Introduction</h3><p>设计模式在面试中的考点通常是介绍其原理并说出优缺点。或者对比几个比较相似的模式的异同点。在笔试中可能会出现画出某个设计模式的 UML 图这样的题。虽说面试中占的比重不大，但并不代表它不重要。恰恰相反，设计模式于程序员而言相当重要，它是我们写出优秀程序的保障。设计模式与程序员的架构能力与阅读源码的能力息息相关，非常值得我们深入学习。</p><p>面向对象的特点是 可维护、可复用、可扩展、灵活性好，它最强大的地方在于：随着业务变得越来越复杂，面向对象依然能够使得程序结构良好，而面向过程却会导致程序越来越臃肿。</p><p>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。设计模式对于程序员而言并不陌生，每个程序员在编程时都会或多或少的接触到设计模式。无论是在大型程序的架构中，亦或是在源码的学习中，设计模式都扮演着非常重要的角色。</p><p>今天我们就一起来探索设计模式的世界！</p><h3 id="设计模式的六大原则-Six-principles"><a href="#设计模式的六大原则-Six-principles" class="headerlink" title="设计模式的六大原则 Six principles"></a>设计模式的六大原则 Six principles</h3><p>设计模式的世界丰富多彩，比如生产一个个“产品”的工厂模式，衔接两个不相关接口的适配器模式，用不同的方式做同一件事的策略模式，构建步骤稳定、根据构建过程的不同配置构建出不同对象的建造者模式等等。</p><p>无论何种设计模式，都是基于六大设计原则：</p><p>开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。<br>单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因。<br>里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。<br>依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。<br>迪米特法则：又名“最少知道原则”，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话。<br>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</p><h2 id="第一章：构建型模式-Creational-Patterns"><a href="#第一章：构建型模式-Creational-Patterns" class="headerlink" title="第一章：构建型模式 Creational Patterns"></a>第一章：构建型模式 Creational Patterns</h2><h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 Factory"></a>工厂模式 Factory</h3><p>在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。</p><p>水果工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;梨子&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;暂时没有这种水果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FruitFactory</span> <span class="variable">fruitFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> fruitFactory.create(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">pear</span> <span class="operator">=</span> fruitFactory.create(<span class="string">&quot;梨子&quot;</span>);</span><br><span class="line">        apple.eat();</span><br><span class="line">        pear.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。比如，如果生产一个苹果需要苹果种子、阳光、水分，将工厂修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;苹果&quot;</span>:</span><br><span class="line">                <span class="type">AppleSeed</span> <span class="variable">appleSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleSeed</span>();</span><br><span class="line">                <span class="type">Sunlight</span> <span class="variable">sunlight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sunlight</span>();</span><br><span class="line">                <span class="type">Water</span> <span class="variable">water</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Water</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(appleSeed, sunlight, water);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;梨子&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;暂时没有这种水果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者的代码则完全不需要变化，而且调用者不需要在每次需要苹果时，自己去构建苹果种子、阳光、水分以获得苹果。苹果的生产过程再复杂，也只是工厂的事。这就是封装的好处，假如某天科学家发明了让苹果更香甜的肥料，要加入苹果的生产过程中的话，也只需要在工厂中修改，调用者完全不用关心。</p><p>不知不觉中，我们就写出了简单工厂模式的代码。工厂模式一共有三种：</p><ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><p>注：在 GoF 所著的《设计模式》一书中，简单工厂模式被划分为工厂方法模式的一种特例，没有单独被列出来。</p><p>总而言之，简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见：</p><p>一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。<br>二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，代码如下：</p><p>苹果工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梨子工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PearFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">AppleFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> appleFactory.create();</span><br><span class="line">        <span class="type">PearFactory</span> <span class="variable">pearFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">pear</span> <span class="operator">=</span> pearFactory.create();</span><br><span class="line">        apple.eat();</span><br><span class="line">        pear.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有读者可能会开喷了，这样和直接 new 出苹果和梨子有什么区别？上文说工厂是为了减少类与类之间的耦合，让调用者尽可能少的和其他类打交道。用简单工厂模式，我们只需要知道 FruitFactory，无需知道 Apple 、Pear 类，很容易看出耦合度降低了。但用工厂方法模式，调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！</p><p>这位读者请先放下手中的大刀，仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">AppleSeed</span> <span class="variable">appleSeed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleSeed</span>();</span><br><span class="line">        <span class="type">Sunlight</span> <span class="variable">sunlight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sunlight</span>();</span><br><span class="line">        <span class="type">Water</span> <span class="variable">water</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Water</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(appleSeed, sunlight, water);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。</p><p>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。<br>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</p><h3 id="抽象工厂模式-Abstract-factory"><a href="#抽象工厂模式-Abstract-factory" class="headerlink" title="抽象工厂模式 Abstract factory"></a>抽象工厂模式 Abstract factory</h3><p>上一节中的工厂方法模式可以进一步优化，提取出公共的工厂接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    Fruit <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后苹果工厂和梨子工厂都实现此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">IFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">create</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，调用者可以将 AppleFactory 和 PearFactory 统一作为 IFactory 对象使用，调用者代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> appleFactory.create();</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">pearFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">pear</span> <span class="operator">=</span> pearFactory.create();</span><br><span class="line">        apple.eat();</span><br><span class="line">        pear.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p><p>由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> factory.create();</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要替换为吃梨子，只需要更改一行代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearFactory</span>();</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> factory.create();</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IFactory 中只有一个抽象方法时，或许还看不出抽象工厂模式的威力。实际上抽象工厂模式主要用于替换一系列方法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使用抽象方法模式的话，只需在 IFactory 接口中定义好增删改查四个方法，让 SQLFactory 和 AccessFactory 实现此接口，调用时直接使用 IFactory 中的抽象方法即可，调用者无需知道使用的什么数据库，我们就可以非常方便的整个替换程序的数据库，并且让客户端毫不知情。</p><p>抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p><h4 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h4><p>单例模式非常常见，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见：</p><p>它能够避免对象重复创建，节约空间并提升效率<br>避免由于操作不同实例导致的逻辑错误<br>单例模式有两种实现方式：饿汉式和懒汉式。</p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>饿汉式：变量在声明时便初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将构造方法定义为 private，这就保证了其他类无法实例化此类，必须通过 getInstance 方法才能获取到唯一的 instance 实例，非常直观。但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。就好比一个电工在修理灯泡时，先把所有工具拿出来，不管是不是所有的工具都用得上。就像一个饥不择食的饿汉，所以称之为饿汉式。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式：先声明一个空变量，需要用时才初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先声明了一个初始值为 null 的 instance 变量，当需要使用时判断此变量是否已被初始化，没有初始化的话才 new 一个实例出来。就好比电工在修理灯泡时，开始比较偷懒，什么工具都不拿，当发现需要使用螺丝刀时，才把螺丝刀拿出来。当需要用钳子时，再把钳子拿出来。就像一个不到万不得已不会行动的懒汉，所以称之为懒汉式。</p><p>懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。</p><p>上述代码的懒汉式单例乍一看没什么问题，但其实它不是线程安全的。如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能保证多个线程调用 getInstance 时，一次最多只有一个线程能够执行判空并 new 出实例的操作，所以 instance 只会实例化一次。但这样的写法仍然有问题，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步化方法，这样会严重影响程序的执行效率。所以更好的做法是在同步化之前，再加上一层检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样增加一种检查方式后，如果 instance 已经被实例化，则不会执行同步化操作，大大提升了程序效率。上面这种写法也就是我们平时较常用的双检锁方式实现的线程安全的单例模式。</p><p>但这样的懒汉式单例仍然有一个问题，JVM 底层为了优化程序运行效率，可能会对我们的代码进行指令重排序，在一些特殊情况下会导致出现空指针，为了防止这个问题，更进一步的优化是给 instance 变量加上 volatile 关键字。</p><p>有读者可能会有疑问，我们在外面检查了 instance &#x3D;&#x3D; null, 那么锁里面的空检查是否可以去掉呢？</p><p>答案是不可以。如果里面不做空检查，可能会有两个线程同时通过了外面的空检查，然后在一个线程 new 出实例后，第二个线程进入锁中又 new 出一个实例，导致创建多个实例。</p><p>除了双检锁方式外，还有一种比较常见的静态内部类方式保证懒汉式单例的线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们经常使用这种静态内部类的懒加载方式，但其中的原理不一定每个人都清楚。接下来我们便来分析其原理，搞清楚两个问题：</p><ul><li>静态内部类方式是怎么实现懒加载的</li><li>静态内部类方式是怎么保证线程安全的</li></ul><p>Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit &#x3D; class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。</p><p>另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。</p><p>第二个问题的答案是 Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p><p>懒加载方式在平时非常常见，比如打开我们常用的美团、饿了么、支付宝 app，应用首页会立刻刷新出来，但其他标签页在我们点击到时才会刷新。这样就减少了流量消耗，并缩短了程序启动时间。再比如游戏中的某些模块，当我们点击到时才会去下载资源，而不是事先将所有资源都先下载下来，这也属于懒加载方式，避免了内存浪费。</p><p>但懒汉式的缺点就是将程序加载时间从启动时延后到了运行时，虽然启动时间缩短了，但我们浏览页面时就会看到数据的 loading 过程。如果用饿汉式将页面提前加载好，我们浏览时就会特别的顺畅，也不失为一个好的用户体验。比如我们常用的 QQ、微信 app，作为即时通讯的工具软件，它们会在启动时立即刷新所有的数据，保证用户看到最新最全的内容。著名的软件大师 Martin 在《代码整洁之道》一书中也说到：不提倡使用懒加载方式，因为程序应该将构建与使用分离，达到解耦。饿汉式在声明时直接初始化变量的方式也更直观易懂。所以在使用饿汉式还是懒汉式时，需要权衡利弊。</p><p>一般的建议是：对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。</p><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 Builder"></a>建造者模式 Builder</h3><p>建造者模式用于创建过程稳定，但配置多变的对象。在《设计模式》一书中的定义是：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>经典的“建造者-指挥者”模式现在已经不太常用了，现在建造者模式主要用来通过链式调用生成不同的配置。比如我们要制作一杯珍珠奶茶。它的制作过程是稳定的，除了必须要知道奶茶的种类和规格外，是否加珍珠和是否加冰是可选的。使用建造者模式表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> pearl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> ice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">MilkTea</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MilkTea</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = builder.type;</span><br><span class="line">        <span class="built_in">this</span>.size = builder.size;</span><br><span class="line">        <span class="built_in">this</span>.pearl = builder.pearl;</span><br><span class="line">        <span class="built_in">this</span>.ice = builder.ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPearl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pearl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">size</span> <span class="operator">=</span> <span class="string">&quot;中杯&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">pearl</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">ice</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String type)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">size</span><span class="params">(String size)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = size;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">pearl</span><span class="params">(<span class="type">boolean</span> pearl)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.pearl = pearl;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">ice</span><span class="params">(<span class="type">boolean</span> cold)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ice = cold;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> MilkTea <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们将 MilkTea 的构造方法设置为私有的，所以外部不能通过 new 构建出 MilkTea 实例，只能通过 Builder 构建。对于必须配置的属性，通过 Builder 的构造方法传入，可选的属性通过 Builder 的链式调用方法传入，如果不配置，将使用默认配置，也就是中杯、加珍珠、不加冰。根据不同的配置可以制作出不同的奶茶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buyMilkTea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">milkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>.Builder(<span class="string">&quot;原味&quot;</span>).build();</span><br><span class="line">        show(milkTea);</span><br><span class="line"></span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">chocolate</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">MilkTea</span>.Builder(<span class="string">&quot;巧克力味&quot;</span>)</span><br><span class="line">                .ice(<span class="literal">false</span>)</span><br><span class="line">                .build();</span><br><span class="line">        show(chocolate);</span><br><span class="line">        </span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">strawberry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>.Builder(<span class="string">&quot;草莓味&quot;</span>)</span><br><span class="line">                .size(<span class="string">&quot;大杯&quot;</span>)</span><br><span class="line">                .pearl(<span class="literal">false</span>)</span><br><span class="line">                .ice(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        show(strawberry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(MilkTea milkTea)</span> &#123;</span><br><span class="line">        String pearl;</span><br><span class="line">        <span class="keyword">if</span> (milkTea.isPearl())</span><br><span class="line">            pearl = <span class="string">&quot;加珍珠&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pearl = <span class="string">&quot;不加珍珠&quot;</span>;</span><br><span class="line">        String ice;</span><br><span class="line">        <span class="keyword">if</span> (milkTea.isIce()) &#123;</span><br><span class="line">            ice = <span class="string">&quot;加冰&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ice = <span class="string">&quot;不加冰&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;一份&quot;</span> + milkTea.getSize() + <span class="string">&quot;、&quot;</span></span><br><span class="line">                + pearl + <span class="string">&quot;、&quot;</span></span><br><span class="line">                + ice + <span class="string">&quot;的&quot;</span></span><br><span class="line">                + milkTea.getType() + <span class="string">&quot;奶茶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>一份中杯、加珍珠、不加冰的原味奶茶一份中杯、加珍珠、不加冰的巧克力味奶茶一份大杯、不加珍珠、加冰的草莓味奶茶</code></pre><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h3><p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p>定义看起来有点绕口，实际上在 Java 中，Object 的 clone() 方法就属于原型模式，不妨简单的理解为：原型模式就是用来克隆对象的。</p><p>举个例子，比如有一天，周杰伦到奶茶店点了一份不加冰的原味奶茶，你说我是周杰伦的忠实粉，我也要一份跟周杰伦一样的。用程序表示如下：</p><p>奶茶类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTea</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> ice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">milkTeaOfJay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    milkTeaOfJay.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    milkTeaOfJay.ice = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">yourMilkTea</span> <span class="operator">=</span> milkTeaOfJay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像没什么问题，将周杰伦的奶茶直接赋值到你的奶茶上就行了，看起来我们并不需要 clone 方法。但是这样真的是复制了一份奶茶吗？</p><p>当然不是，Java 对非基本类型对象的赋值只是传递地址。这样赋值之后，yourMilkTea 仍然指向的周杰伦的奶茶，并不会多一份一样的奶茶。</p><p>那么我们要怎么做才能点一份一样的奶茶呢？将程序修改如下就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">milkTeaOfJay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    milkTeaOfJay.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    milkTeaOfJay.ice = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">yourMilkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    yourMilkTea.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    yourMilkTea.ice = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有这样，yourMilkTea 才是 new 出来的一份全新的奶茶。我们设想一下，如果有一千个粉丝都需要点和周杰伦一样的奶茶的话，按照现在的写法就需要 new 一千次，并为每一个新的对象赋值一千次，造成大量的重复。</p><p>更糟糕的是，如果周杰伦临时决定加个冰，那么粉丝们的奶茶配置也要跟着修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">milkTeaOfJay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    milkTeaOfJay.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    milkTeaOfJay.ice = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">yourMilkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    yourMilkTea.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    yourMilkTea.ice = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将一千个粉丝的 ice 都修改为 true</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大批量的修改无疑是非常丑陋的做法，这就是我们需要 clone 方法的理由！</p><p>运用原型模式，在 MilkTea 中新增 clone 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTea</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MilkTea <span class="title function_">clone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MilkTea</span> <span class="variable">milkTea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">        milkTea.type = <span class="built_in">this</span>.type;</span><br><span class="line">        milkTea.ice = <span class="built_in">this</span>.ice;</span><br><span class="line">        <span class="keyword">return</span> milkTea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">milkTeaOfJay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MilkTea</span>();</span><br><span class="line">    milkTeaOfJay.type = <span class="string">&quot;原味&quot;</span>;</span><br><span class="line">    milkTeaOfJay.ice = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">MilkTea</span> <span class="variable">yourMilkTea</span> <span class="operator">=</span> milkTeaOfJay.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一千位粉丝都调用 milkTeaOfJay 的 clone 方法即可</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是原型模式，Java 中有一个语法糖，让我们并不需要手写 clone 方法。这个语法糖就是 Cloneable 接口，我们只要让需要拷贝的类实现此接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MilkTea</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> ice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> MilkTea <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (MilkTea) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，Java 自带的 clone 方法是浅拷贝的。也就是说调用此对象的 clone 方法，只有基本类型的参数会被拷贝一份，非基本类型的对象不会被拷贝一份，而是继续使用传递引用的方式。如果需要实现深拷贝，必须要自己手动修改 clone 方法才行。</p><h3 id="小结-Summary"><a href="#小结-Summary" class="headerlink" title="小结 Summary"></a>小结 Summary</h3><p>构建型模式</p><ul><li>工厂方法模式：为每一类对象建立工厂，将对象交由工厂创建，客户端只和工厂打交道。</li><li>抽象工厂模式：为每一类工厂提取出抽象接口，使得新增工厂、替换工厂变得非常容易。</li><li>单例模式：全局使用同一个对象，分为饿汉式和懒汉式。懒汉式有双检锁和内部类两种实现方式。</li><li>建造者模式：用于创建构造过程稳定的对象，不同的 Builder 可以定义不同的配置。</li><li>原型模式：为一个类定义 clone 方法，使得创建相同的对象更方便。</li></ul><h2 id="第二章：结构型模式-Structural-Patterns"><a href="#第二章：结构型模式-Structural-Patterns" class="headerlink" title="第二章：结构型模式 Structural Patterns"></a>第二章：结构型模式 Structural Patterns</h2><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式 Adapter"></a>适配器模式 Adapter</h3><p>说到适配器，我们最熟悉的莫过于电源适配器了，也就是手机的充电头。它就是适配器模式的一个应用。</p><p>试想一下，你有一条连接电脑和手机的 USB 数据线，连接电脑的一端从电脑接口处接收 5V 的电压，连接手机的一端向手机输出 5V 的电压，并且他们工作良好。</p><p>中国的家用电压都是 220V，所以 USB 数据线不能直接拿来给手机充电，这时候我们有两种方案：</p><p>单独制作手机充电器，接收 220V 家用电压，输出 5V 电压。<br>添加一个适配器，将 220V 家庭电压转化为类似电脑接口的 5V 电压，再连接数据线给手机充电。<br>如果你使用过早期的手机，就会知道以前的手机厂商采用的就是第一种方案：早期的手机充电器都是单独制作的，充电头和充电线是连在一起的。现在的手机都采用了电源适配器加数据线的方案。这是生活中应用适配器模式的一个进步。</p><p>适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配的意思是适应、匹配。通俗地讲，适配器模式适用于有相关性但不兼容的结构，源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p><p>家用电源和 USB 数据线有相关性：家用电源输出电压，USB 数据线输入电压。但两个接口无法兼容，因为一个输出 220V，一个输入 5V，通过适配器将输出 220V 转换成输出 5V 之后才可以一起工作。</p><p>让我们用程序来模拟一下这个过程。</p><p>首先，家庭电源提供 220V 的电压：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeBattery</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">supply</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 家用电源提供一个 220V 的输出电压</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">USB 数据线只接收 5V 的充电电压：</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">USBLine</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">(<span class="type">int</span> volt)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果电压不是 5V，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (volt != <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;只能接收 5V 电压&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果电压是 5V，正常充电</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看适配之前，用户如果直接用家庭电源给手机充电：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chargeForPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HomeBattery</span> <span class="variable">homeBattery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeBattery</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">homeVolt</span> <span class="operator">=</span> homeBattery.supply();</span><br><span class="line">        System.out.println(<span class="string">&quot;家庭电源提供的电压是 &quot;</span> + homeVolt + <span class="string">&quot;V&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">USBLine</span> <span class="variable">usbLine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBLine</span>();</span><br><span class="line">        usbLine.charge(homeVolt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">家庭电源提供的电压是 220V</span><br><span class="line"></span><br><span class="line">java.lang.IllegalArgumentException: 只能接收 5V 电压</span><br></pre></td></tr></table></figure><p>这时，我们加入电源适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> homeVolt)</span> &#123;</span><br><span class="line">        <span class="comment">// 适配过程：使用电阻、电容等器件将其降低为输出 5V</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chargeVolt</span> <span class="operator">=</span> homeVolt - <span class="number">215</span>;</span><br><span class="line">        <span class="keyword">return</span> chargeVolt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，用户再使用适配器将家庭电源提供的电压转换为充电电压：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chargeForPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HomeBattery</span> <span class="variable">homeBattery</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HomeBattery</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">homeVolt</span> <span class="operator">=</span> homeBattery.supply();</span><br><span class="line">        System.out.println(<span class="string">&quot;家庭电源提供的电压是 &quot;</span> + homeVolt + <span class="string">&quot;V&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Adapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">chargeVolt</span> <span class="operator">=</span> adapter.convert(homeVolt);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用适配器将家庭电压转换成了 &quot;</span> + chargeVolt + <span class="string">&quot;V&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">USBLine</span> <span class="variable">usbLine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USBLine</span>();</span><br><span class="line">        usbLine.charge(chargeVolt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">家庭电源提供的电压是 220V</span><br><span class="line">使用适配器将家庭电压转换成了 5V</span><br><span class="line">正常充电</span><br><span class="line">这就是适配器模式。在我们日常的开发中经常会使用到各种各样的 Adapter，都属于适配器模式的应用。</span><br></pre></td></tr></table></figure><p>但适配器模式并不推荐多用。因为未雨绸缪好过亡羊补牢，如果事先能预防接口不同的问题，不匹配问题就不会发生，只有遇到源接口无法改变时，才应该考虑使用适配器。比如现代的电源插口中很多已经增加了专门的 USB 充电接口，让我们不需要再使用适配器转换接口，这又是社会的一个进步。</p><p>补充：</p><p>收到不少读者的反馈，认为文中的这个例子举得过于简单。但实际上这个例子已经反映出了适配器模式的基本概念了。</p><p>在本例中，适配前的 A 表示 220V，适配后的 B 表示 5V，C 就是适配过程，本例中的适配过程是使用电阻、电容等器件将其降低为输出 5V。适配器的核心思想就是使用适配器包装适配过程，这个适配器通常被命名为 Adapter 或者 Wrapper。</p><p>只不过通常我们见到的适配器模式是基于接口的适配。那么我们不妨看一个接口适配的例子。</p><p>设想我们已经有了一个 Task 类，实现了 Callable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m called.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们需要这个 Task 类在一个子线程中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="comment">// 这一行无法编译通过</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(callable);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 等待 1s 保证 thread 执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们会发现，Thread thread &#x3D; new Thread(callable); 这一行是无法编译通过的，因为 Thread 中需要接收的参数类型是 Runnable。</p><p>在业务上来说，Runnable 的 run 方法和 Callable 的 call 方法意义是一样的，这里的问题是接口不一致。所以我们可以通过接口适配器将接口转换成一致的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RunnableAdapter</span><span class="params">(Callable&lt;?&gt; callable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 RunnableAdapter 中，我们包装了原始的 Callable 接口，并实现了新的 Runnable 接口。在 Runnable 接口的 run 方法中，调用 Callable 接口的 call 方法。实现同样的业务功能。</p><p>在客户端中使用 RunnableAdapter 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>(callable));</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 等待 1s 保证 thread 执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>I&#39;m called.</code></pre><p>可以看到，通过添加适配器，使得原本不兼容的两个接口能够正常工作了。适配器在其中的职责是包装了原有的接口，这样的适配器称为接口适配器。类似地，包装一个对象的适配器被称之为对象适配器。</p><p>适配器模式的核心思想是添加一个中间件，包装原有的接口或对象，将其转换为另一个接口或对象，以适应新的业务场景。适配器模式和后文介绍的装饰者模式、代理模式同属于包装模式。与其他两种包装模式不同的是，适配器模式重在转换，不改变原有的功能。而装饰者模式会在包装的基础上增强或添加功能，代理模式用于加强对原有类的控制。</p><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 Bridge"></a>桥接模式 Bridge</h3><p>考虑这样一个需求：绘制矩形、圆形、三角形这三种图案。按照面向对象的理念，我们至少需要三个具体类，对应三种不同的图形。</p><p>抽象接口 IShape：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个具体形状类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Round</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们有了新的需求，每种形状都需要有四种不同的颜色：红、蓝、黄、绿。</p><p>这时我们很容易想到两种设计方案：</p><ol><li>为了复用形状类，将每种形状定义为父类，每种不同颜色的图形继承自其形状父类。此时一共有 12 个类。</li><li>为了复用颜色类，将每种颜色定义为父类，每种不同颜色的图形继承自其颜色父类。此时一共有 12 个类。</li></ol><p>乍一看没什么问题，我们使用了面向对象的继承特性，复用了父类的代码并扩展了新的功能。</p><p>但仔细想一想，如果以后要增加一种颜色，比如黑色，那么我们就需要增加三个类；如果再要增加一种形状，我们又需要增加五个类，对应 5 种颜色。</p><p>更不用说遇到增加 20 个形状，20 种颜色的需求，不同的排列组合将会使工作量变得无比的庞大。看来我们不得不重新思考设计方案。</p><p>形状和颜色，都是图形的两个属性。他们两者的关系是平等的，所以不属于继承关系。更好的的实现方式是：将形状和颜色分离，根据需要对形状和颜色进行组合，这就是桥接模式的思想。</p><blockquote><p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p></blockquote><p>官方定义非常精准、简练，但却有点不易理解。通俗地说，如果一个对象有两种或者多种分类方式，并且两种分类方式都容易变化，比如本例中的形状和颜色。这时使用继承很容易造成子类越来越多，所以更好的做法是把这种分类方式分离出来，让他们独立变化，使用时将不同的分类进行组合即可。</p><p>说到这里，不得不提一个设计原则：合成 &#x2F; 聚合复用原则。虽然它没有被划分到六大设计原则中，但它在面向对象的设计中也非常的重要。</p><blockquote><p>合成 &#x2F; 聚合复用原则：优先使用合成 &#x2F; 聚合，而不是类继承。</p></blockquote><p>继承虽然是面向对象的三大特性之一，但继承会导致子类与父类有非常紧密的依赖关系，它会限制子类的灵活性和子类的复用性。而使用合成 &#x2F; 聚合，也就是使用接口实现的方式，就不存在依赖问题，一个类可以实现多个接口，可以很方便地拓展功能。</p><p>让我们一起来看一下本例使用桥接模式的程序实现：</p><p>新建接口类 IColor，仅包含一个获取颜色的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IColor</span> &#123;</span><br><span class="line">    String <span class="title function_">getColor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种颜色都实现此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">IColor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;红&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">IColor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;蓝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Yellow</span> <span class="keyword">implements</span> <span class="title class_">IColor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;黄&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Green</span> <span class="keyword">implements</span> <span class="title class_">IColor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;绿&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每个形状类中，桥接 IColor 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(IColor color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制&quot;</span> + color.getColor() + <span class="string">&quot;矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Round</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(IColor color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制&quot;</span> + color.getColor() + <span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">implements</span> <span class="title class_">IShape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IColor color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(IColor color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制&quot;</span> + color.getColor() + <span class="string">&quot;三角形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Rectangle</span> <span class="variable">rectangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    rectangle.setColor(<span class="keyword">new</span> <span class="title class_">Red</span>());</span><br><span class="line">    rectangle.draw();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Round</span> <span class="variable">round</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Round</span>();</span><br><span class="line">    round.setColor(<span class="keyword">new</span> <span class="title class_">Blue</span>());</span><br><span class="line">    round.draw();</span><br><span class="line">    </span><br><span class="line">    <span class="type">Triangle</span> <span class="variable">triangle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>();</span><br><span class="line">    triangle.setColor(<span class="keyword">new</span> <span class="title class_">Yellow</span>());</span><br><span class="line">    triangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>绘制红矩形绘制蓝圆形绘制黄三角形</code></pre><p>这时我们再来回顾一下官方定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。抽象部分指的是父类，对应本例中的形状类，实现部分指的是不同子类的区别之处。将子类的区别方式 —— 也就是本例中的颜色 —— 分离成接口，通过组合的方式桥接颜色和形状，这就是桥接模式，它主要用于两个或多个同等级的接口。</p><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 Composite"></a>组合模式 Composite</h3><p>上文说到，桥接模式用于将同等级的接口互相组合，那么组合模式和桥接模式有什么共同点吗？</p><p>事实上组合模式和桥接模式的组合完全不一样。组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。例如：</p><ul><li>文件夹和子文件夹的关系：文件夹中可以存放文件，也可以新建文件夹，子文件夹也一样。</li><li>总公司子公司的关系：总公司可以设立部门，也可以设立分公司，子公司也一样。</li><li>树枝和分树枝的关系：树枝可以长出叶子，也可以长出树枝，分树枝也一样。</li></ul><p>在这些关系中，虽然整体包含了部分，但无论整体或部分，都具有一致的行为。</p><blockquote><p>组合模式：又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构</p></blockquote><p>考虑这样一个实际应用：设计一个公司的人员分布结。人员结构中有两种结构，一是管理者，如老板，PM，CFO，CTO，二是职员。其中有的管理者不仅仅要管理职员，还会管理其他的管理者。这就是一个典型的整体与部分的结构。</p><h4 id="不使用组合模式的设计方案"><a href="#不使用组合模式的设计方案" class="headerlink" title="不使用组合模式的设计方案"></a>不使用组合模式的设计方案</h4><p>要描述这样的结构，我们很容易想到以下设计方案：</p><p>新建管理者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">    <span class="comment">// 职位</span></span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="comment">// 工作内容</span></span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="comment">// 管理的管理者</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Manager&gt; managers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 管理的职员</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employees = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addManager</span><span class="params">(Manager manager)</span> &#123;</span><br><span class="line">        managers.add(manager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeManager</span><span class="params">(Manager manager)</span> &#123;</span><br><span class="line">        managers.remove(manager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        employees.add(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEmployee</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        employees.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做自己的本职工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是&quot;</span> + position + <span class="string">&quot;，我正在&quot;</span> + job);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查下属</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">            employee.work();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Manager manager : managers) &#123;</span><br><span class="line">            manager.check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建职员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">// 职位</span></span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="comment">// 工作内容</span></span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做自己的本职工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是&quot;</span> + position + <span class="string">&quot;，我正在&quot;</span> + job);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端建立人员结构关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;老板&quot;</span>, <span class="string">&quot;唱怒放的生命&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">HR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;人力资源&quot;</span>, <span class="string">&quot;聊微信&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">PM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;产品经理&quot;</span>, <span class="string">&quot;不知道干啥&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">CFO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;财务主管&quot;</span>, <span class="string">&quot;看剧&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">CTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;技术主管&quot;</span>, <span class="string">&quot;划水&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">UI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;设计师&quot;</span>, <span class="string">&quot;画画&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">operator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;运营人员&quot;</span>, <span class="string">&quot;兼职客服&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">webProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;程序员&quot;</span>, <span class="string">&quot;学习设计模式&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">backgroundProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;后台程序员&quot;</span>, <span class="string">&quot;CRUD&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">accountant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;会计&quot;</span>, <span class="string">&quot;背九九乘法表&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;文员&quot;</span>, <span class="string">&quot;给老板递麦克风&quot;</span>);</span><br><span class="line">        boss.addEmployee(HR);</span><br><span class="line">        boss.addManager(PM);</span><br><span class="line">        boss.addManager(CFO);</span><br><span class="line">        PM.addEmployee(UI);</span><br><span class="line">        PM.addManager(CTO);</span><br><span class="line">        PM.addEmployee(operator);</span><br><span class="line">        CTO.addEmployee(webProgrammer);</span><br><span class="line">        CTO.addEmployee(backgroundProgrammer);</span><br><span class="line">        CFO.addEmployee(accountant);</span><br><span class="line">        CFO.addEmployee(clerk);</span><br><span class="line"></span><br><span class="line">        boss.check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，输出如下（为方便查看，笔者添加了缩进）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是老板，我正在唱怒放的生命</span><br><span class="line">我是人力资源，我正在聊微信</span><br><span class="line">我是产品经理，我正在不知道干啥</span><br><span class="line">我是设计师，我正在画画</span><br><span class="line">我是运营人员，我正在兼职客服</span><br><span class="line">我是技术主管，我正在划水</span><br><span class="line">我是程序员，我正在学习设计模式</span><br><span class="line">我是后台程序员，我正在CRUD</span><br><span class="line">我是财务主管，我正在看剧</span><br><span class="line">我是会计，我正在背九九乘法表</span><br><span class="line">我是文员，我正在给老板递麦克风</span><br></pre></td></tr></table></figure><p>这样我们就设计出了公司的结构，但是这样的设计有两个弊端：</p><ul><li>name 字段，job 字段，work 方法重复了。</li><li>管理者对其管理的管理者和职员需要区别对待。</li></ul><p>关于第一个弊端，虽然这里为了讲解，只有两个字段和一个方法重复，实际工作中这样的整体部分结构会有相当多的重复。比如此例中还可能有工号、年龄等字段，领取工资、上下班打卡、开各种无聊的会等方法。</p><p>大量的重复显然是很丑陋的代码，分析一下可以发现， Manager 类只比 Employee 类多一个管理人员的列表字段，多几个增加 &#x2F; 移除人员的方法，其他的字段和方法全都是一样的。</p><p>有读者应该会想到：我们可以将重复的字段和方法提取到一个工具类中，让 Employee 和 Manager 都去调用此工具类，就可以消除重复了。</p><p>这样固然可行，但属于 Employee 和 Manager 类自己的东西却要通过其他类调用，并不利于程序的高内聚。</p><p>关于第二个弊端，此方案无法解决，此方案中 Employee 和 Manager 类完全是两个不同的对象，两者的相似性被忽略了。</p><p>所以我们有更好的设计方案，那就是组合模式！</p><h4 id="使用组合模式的设计方案"><a href="#使用组合模式的设计方案" class="headerlink" title="使用组合模式的设计方案"></a>使用组合模式的设计方案</h4><p>组合模式最主要的功能就是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件，所以我们先新建一个抽象的组件类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">// 职位</span></span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="comment">// 工作内容</span></span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做自己的本职工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是&quot;</span> + position + <span class="string">&quot;，我正在&quot;</span> + job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理者继承自此抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">// 管理的组件</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(position, job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        components.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查下属</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">        <span class="keyword">for</span> (Component component : components) &#123;</span><br><span class="line">            component.check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>职员同样继承自此抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(position, job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;职员没有管理权限&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;职员没有管理权限&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改客户端如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Component</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;老板&quot;</span>, <span class="string">&quot;唱怒放的生命&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">HR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;人力资源&quot;</span>, <span class="string">&quot;聊微信&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">PM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;产品经理&quot;</span>, <span class="string">&quot;不知道干啥&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">CFO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;财务主管&quot;</span>, <span class="string">&quot;看剧&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">CTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;技术主管&quot;</span>, <span class="string">&quot;划水&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">UI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;设计师&quot;</span>, <span class="string">&quot;画画&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">operator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;运营人员&quot;</span>, <span class="string">&quot;兼职客服&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">webProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;程序员&quot;</span>, <span class="string">&quot;学习设计模式&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">backgroundProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;后台程序员&quot;</span>, <span class="string">&quot;CRUD&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">accountant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;会计&quot;</span>, <span class="string">&quot;背九九乘法表&quot;</span>);</span><br><span class="line">        <span class="type">Component</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;文员&quot;</span>, <span class="string">&quot;给老板递麦克风&quot;</span>);</span><br><span class="line">        boss.addComponent(HR);</span><br><span class="line">        boss.addComponent(PM);</span><br><span class="line">        boss.addComponent(CFO);</span><br><span class="line">        PM.addComponent(UI);</span><br><span class="line">        PM.addComponent(CTO);</span><br><span class="line">        PM.addComponent(operator);</span><br><span class="line">        CTO.addComponent(webProgrammer);</span><br><span class="line">        CTO.addComponent(backgroundProgrammer);</span><br><span class="line">        CFO.addComponent(accountant);</span><br><span class="line">        CFO.addComponent(clerk);</span><br><span class="line"></span><br><span class="line">        boss.check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，输出结果与之前的结果一模一样。</p><p>可以看到，使用组合模式后，我们解决了之前的两个弊端。一是将共有的字段与方法移到了父类中，消除了重复，并且在客户端中，可以一致对待 Manager 和 Employee 类：</p><ul><li>Manager 类和 Employee 类统一声明为 Component 对象</li><li>统一调用 Component 对象的 addComponent 方法添加子对象即可。</li></ul><h4 id="组合模式中的安全方式与透明方式"><a href="#组合模式中的安全方式与透明方式" class="headerlink" title="组合模式中的安全方式与透明方式"></a>组合模式中的安全方式与透明方式</h4><p>读者可能已经注意到了，Employee 类虽然继承了父类的 addComponent 和 removeComponent 方法，但是仅仅提供了一个空实现，因为 Employee 类是不支持添加和移除组件的。这样是否违背了接口隔离原则呢？</p><blockquote><p>接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。</p></blockquote><p>答案是肯定的，这样确实违背了接口隔离原则。这种方式在组合模式中被称作透明方式.</p><blockquote><p>透明方式：在 Component 中声明所有管理子对象的方法，包括 add 、remove 等，这样继承自 Component 的子类都具备了 add、remove 方法。对于外界来说叶节点和枝节点是透明的，它们具备完全一致的接口。</p></blockquote><p>这种方式有它的优点：让 Manager 类和 Employee 类具备完全一致的行为接口，调用者可以一致对待它们。</p><p>但它的缺点也显而易见：Employee 类并不支持管理子对象，不仅违背了接口隔离原则，而且客户端可以用 Employee 类调用 addComponent 和 removeComponent 方法，导致程序出错，所以这种方式是不安全的。</p><p>那么我们可不可以将 addComponent 和 removeComponent 方法移到 Manager 子类中去单独实现，让 Employee 不再实现这两个方法呢？我们来尝试一下。</p><p>将抽象类修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">// 职位</span></span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="comment">// 工作内容</span></span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做自己的本职工作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是&quot;</span> + position + <span class="string">&quot;，我正在&quot;</span> + job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在父类中去掉了 addComponent 和 removeComponent 这两个抽象方法。</p><p>Manager 类修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">// 管理的组件</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(position, job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        components.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查下属</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">        <span class="keyword">for</span> (Component component : components) &#123;</span><br><span class="line">            component.check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Manager 类单独实现了 addComponent 和 removeComponent 这两个方法，去掉了 @Override 注解。</p><p>Employee 类修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String position, String job)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(position, job);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端建立人员结构关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;老板&quot;</span>, <span class="string">&quot;唱怒放的生命&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">HR</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;人力资源&quot;</span>, <span class="string">&quot;聊微信&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">PM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;产品经理&quot;</span>, <span class="string">&quot;不知道干啥&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">CFO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;财务主管&quot;</span>, <span class="string">&quot;看剧&quot;</span>);</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">CTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;技术主管&quot;</span>, <span class="string">&quot;划水&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">UI</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;设计师&quot;</span>, <span class="string">&quot;画画&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">operator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;运营人员&quot;</span>, <span class="string">&quot;兼职客服&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">webProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;程序员&quot;</span>, <span class="string">&quot;学习设计模式&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">backgroundProgrammer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;后台程序员&quot;</span>, <span class="string">&quot;CRUD&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">accountant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;会计&quot;</span>, <span class="string">&quot;背九九乘法表&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;文员&quot;</span>, <span class="string">&quot;给老板递麦克风&quot;</span>);</span><br><span class="line">        boss.addComponent(HR);</span><br><span class="line">        boss.addComponent(PM);</span><br><span class="line">        boss.addComponent(CFO);</span><br><span class="line">        PM.addComponent(UI);</span><br><span class="line">        PM.addComponent(CTO);</span><br><span class="line">        PM.addComponent(operator);</span><br><span class="line">        CTO.addComponent(webProgrammer);</span><br><span class="line">        CTO.addComponent(backgroundProgrammer);</span><br><span class="line">        CFO.addComponent(accountant);</span><br><span class="line">        CFO.addComponent(clerk);</span><br><span class="line"></span><br><span class="line">        boss.check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出结果与之前一模一样。</p><p>这种方式在组合模式中称之为安全方式。</p><blockquote><p>安全方式：在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p></blockquote><p>安全方式遵循了接口隔离原则，但由于不够透明，Manager 和 Employee 类不具有相同的接口，在客户端中，我们无法将 Manager 和 Employee 统一声明为 Component 类了，必须要区别对待，带来了使用上的不方便。</p><p>安全方式和透明方式各有好处，在使用组合模式时，需要根据实际情况决定。但大多数使用组合模式的场景都是采用的透明方式，虽然它有点不安全，但是客户端无需做任何判断来区分是叶子结点还是枝节点，用起来是真香。</p><h3 id="装饰模式-Decorator"><a href="#装饰模式-Decorator" class="headerlink" title="装饰模式 Decorator"></a>装饰模式 Decorator</h3><p>提到装饰，我们先来想一下生活中有哪些装饰：</p><ul><li>女生的首饰：戒指、耳环、项链等装饰品</li><li>家居装饰品：粘钩、镜子、壁画、盆栽等等</li></ul><p>我们为什么需要这些装饰品呢？我们很容易想到是为了美，戒指、耳环、项链、壁画、盆栽都是为了提高颜值或增加美观度。但粘钩、镜子不一样，它们是为了方便我们挂东西、洗漱。所以我们可以总结出装饰品共有两种功能：</p><ul><li>增强原有的特性：我们本身就是有一定颜值的，添加装饰品提高了我们的颜值。同样地，房屋本身就有一定的美观度，家居装饰提高了房屋的美观度。</li><li>添加新的特性：在墙上挂上粘钩，让墙壁有了挂东西的功能。在洗漱台装上镜子，让洗漱台有了照镜子的功能。</li></ul><p>并且我们发现，装饰品并不会改变物品本身，只是起到一个锦上添花的作用。装饰模式也一样，它的主要作用就是：</p><ul><li>增强一个类原有的功能</li><li>为一个类添加新的功能</li></ul><p>并且装饰模式也不会改变原有的类。</p><blockquote><p>装饰模式：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p></blockquote><h4 id="用于增强功能的装饰模式"><a href="#用于增强功能的装饰模式" class="headerlink" title="用于增强功能的装饰模式"></a>用于增强功能的装饰模式</h4><p>我们用程序来模拟一下戴上装饰品提高我们颜值的过程：</p><p>新建颜值接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBeauty</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBeautyValue</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">新建 Me 类，实现颜值接口：</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Me</span> <span class="keyword">implements</span> <span class="title class_">IBeauty</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeautyValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>戒指装饰类，将 Me 包装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RingDecorator</span> <span class="keyword">implements</span> <span class="title class_">IBeauty</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RingDecorator</span><span class="params">(IBeauty me)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeautyValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Me</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());</span><br><span class="line"></span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">meWithRing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RingDecorator</span>(me);</span><br><span class="line">        System.out.println(<span class="string">&quot;戴上了戒指后，我的颜值：&quot;</span> + meWithRing.getBeautyValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>我原本的颜值：100戴上了戒指后，我的颜值：120</code></pre><p>这就是最简单的增强功能的装饰模式。以后我们可以添加更多的装饰类，比如：</p><p>耳环装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EarringDecorator</span> <span class="keyword">implements</span> <span class="title class_">IBeauty</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EarringDecorator</span><span class="params">(IBeauty me)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeautyValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项链装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NecklaceDecorator</span> <span class="keyword">implements</span> <span class="title class_">IBeauty</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBeauty me;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NecklaceDecorator</span><span class="params">(IBeauty me)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.me = me;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBeautyValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> me.getBeautyValue() + <span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Me</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;我原本的颜值：&quot;</span> + me.getBeautyValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随意挑选装饰</span></span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">meWithNecklace</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NecklaceDecorator</span>(me);</span><br><span class="line">        System.out.println(<span class="string">&quot;戴上了项链后，我的颜值：&quot;</span> + meWithNecklace.getBeautyValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多次装饰</span></span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">meWithManyDecorators</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NecklaceDecorator</span>(<span class="keyword">new</span> <span class="title class_">RingDecorator</span>(<span class="keyword">new</span> <span class="title class_">EarringDecorator</span>(me)));</span><br><span class="line">        System.out.println(<span class="string">&quot;戴上耳环、戒指、项链后，我的颜值：&quot;</span> + meWithManyDecorators.getBeautyValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任意搭配装饰</span></span><br><span class="line">        <span class="type">IBeauty</span> <span class="variable">meWithNecklaceAndRing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NecklaceDecorator</span>(<span class="keyword">new</span> <span class="title class_">RingDecorator</span>(me));</span><br><span class="line">        System.out.println(<span class="string">&quot;戴上戒指、项链后，我的颜值：&quot;</span> + meWithNecklaceAndRing.getBeautyValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>我原本的颜值：100戴上了项链后，我的颜值：180戴上耳环、戒指、项链后，我的颜值：250戴上戒指、项链后，我的颜值：200</code></pre><p>可以看到，装饰器也实现了 IBeauty 接口，并且没有添加新的方法，也就是说这里的装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为透明装饰模式，由于没有改变接口，也没有新增方法，所以透明装饰模式可以无限装饰。</p><p>装饰模式是继承的一种替代方案。本例如果不使用装饰模式，而是改用继承实现的话，戴着戒指的 Me 需要派生一个子类、戴着项链的 Me 需要派生一个子类、戴着耳环的 Me 需要派生一个子类、戴着戒指 + 项链的需要派生一个子类…各种各样的排列组合会造成类爆炸。而采用了装饰模式就只需要为每个装饰品生成一个装饰类即可，所以说就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p><h4 id="用于添加功能的装饰模式"><a href="#用于添加功能的装饰模式" class="headerlink" title="用于添加功能的装饰模式"></a>用于添加功能的装饰模式</h4><p>我们用程序来模拟一下房屋装饰粘钩后，新增了挂东西功能的过程：</p><p>新建房屋接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">live</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>房屋类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> <span class="keyword">implements</span> <span class="title class_">IHouse</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">live</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋原有的功能：居住功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建粘钩装饰器接口，继承自房屋接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStickyHookHouse</span> <span class="keyword">extends</span> <span class="title class_">IHouse</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hangThings</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粘钩装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StickyHookDecorator</span> <span class="keyword">implements</span> <span class="title class_">IStickyHookHouse</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHouse house;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StickyHookDecorator</span><span class="params">(IHouse house)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">live</span><span class="params">()</span> &#123;</span><br><span class="line">        house.live();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hangThings</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有了粘钩后，新增了挂东西功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        house.live();</span><br><span class="line"></span><br><span class="line">        <span class="type">IStickyHookHouse</span> <span class="variable">stickyHookHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StickyHookDecorator</span>(house);</span><br><span class="line">        stickyHookHouse.live();</span><br><span class="line">        stickyHookHouse.hangThings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，显示如下：</p><pre><code>房屋原有的功能：居住功能房屋原有的功能：居住功能有了粘钩后，新增了挂东西功能</code></pre><p>这就是用于新增功能的装饰模式。我们在接口中新增了方法：hangThings，然后在装饰器中将 House 类包装起来，之前 House 中的方法仍然调用 house 去执行，也就是说我们并没有修改原有的功能，只是扩展了新的功能，这种模式在装饰模式中称之为半透明装饰模式。</p><p>为什么叫半透明呢？由于新的接口 IStickyHookHouse 拥有之前 IHouse 不具有的方法，所以我们如果要使用装饰器中添加的功能，就不得不区别对待装饰前的对象和装饰后的对象。也就是说客户端要使用新方法，必须知道具体的装饰类 StickyHookDecorator，所以这个装饰类对客户端来说是可见的、不透明的。而被装饰者不一定要是 House，它可以是实现了 IHouse 接口的任意对象，所以被装饰者对客户端是不可见的、透明的。由于一半透明，一半不透明，所以称之为半透明装饰模式。</p><p>我们可以添加更多的装饰器：</p><p>新建镜子装饰器的接口，继承自房屋接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMirrorHouse</span> <span class="keyword">extends</span> <span class="title class_">IHouse</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lookMirror</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>镜子装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MirrorDecorator</span> <span class="keyword">implements</span> <span class="title class_">IMirrorHouse</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IHouse house;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MirrorDecorator</span><span class="params">(IHouse house)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">live</span><span class="params">()</span> &#123;</span><br><span class="line">        house.live();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookMirror</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有了镜子后，新增了照镜子功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        house.live();</span><br><span class="line"></span><br><span class="line">        <span class="type">IMirrorHouse</span> <span class="variable">mirrorHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MirrorDecorator</span>(house);</span><br><span class="line">        mirrorHouse.live();</span><br><span class="line">        mirrorHouse.lookMirror();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>房屋原有的功能：居住功能房屋原有的功能：居住功能有了镜子后，新增了照镜子功能</code></pre><p>现在我们仿照透明装饰模式的写法，同时添加粘钩和镜子装饰试一试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IHouse</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line">        house.live();</span><br><span class="line"></span><br><span class="line">        <span class="type">IStickyHookHouse</span> <span class="variable">stickyHookHouse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StickyHookDecorator</span>(house);</span><br><span class="line">        <span class="type">IMirrorHouse</span> <span class="variable">houseWithStickyHookMirror</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MirrorDecorator</span>(stickyHookHouse);</span><br><span class="line">        houseWithStickyHookMirror.live();</span><br><span class="line">        houseWithStickyHookMirror.hangThings(); <span class="comment">// 这里会报错，找不到 hangThings 方法</span></span><br><span class="line">        houseWithStickyHookMirror.lookMirror();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，第二次装饰时，无法获得上一次装饰添加的方法。原因很明显，当我们用 IMirrorHouse 装饰器后，接口变为了 IMirrorHouse，这个接口中并没有 hangThings 方法。</p><p>那么我们能否让 IMirrorHouse 继承自 IStickyHookHouse，以实现新增两个功能呢？可以，但那样做的话两个装饰类之间有了依赖关系，那就不是装饰模式了。装饰类不应该存在依赖关系，而应该在原本的类上进行装饰。这就意味着，半透明装饰模式中，我们无法多次装饰。</p><p>有的同学会问了，既增强了功能，又添加了新功能的装饰模式叫什么呢？</p><p>—— 举一反三，肯定是叫全不透明装饰模式！</p><p>—— 并不是！只要添加了新功能的装饰模式都称之为半透明装饰模式，他们都具有不可以多次装饰的特点。仔细理解上文半透明名称的由来就知道了，“透明”指的是我们无需知道被装饰者具体的类，既增强了功能，又添加了新功能的装饰模式仍然具有半透明特性。</p><p>Java中的InputStream系列接口就是典型的装饰者模式</p><h3 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式 Facade"></a>外观模式 Facade</h3><p>外观模式非常简单，体现的就是 Java 中封装的思想。将多个子系统封装起来，提供一个更简洁的接口供外部调用。</p><blockquote><p>外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。</p></blockquote><p>举个例子，比如我们每天打开电脑时，都需要做三件事：</p><ul><li>打开浏览器</li><li>打开 IDE</li><li>打开微信</li></ul><p>每天下班时，关机前需要做三件事：</p><ul><li>关闭浏览器</li><li>关闭 IDE</li><li>关闭微信</li></ul><p>用程序模拟如下：</p><p>新建浏览器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Browser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开浏览器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭浏览器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 IDE 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IDE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开 IDE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭 IDE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建微信类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wechat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开微信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭微信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上班:&quot;</span>);</span><br><span class="line">        Browser.open();</span><br><span class="line">        IDE.open();</span><br><span class="line">        Wechat.open();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下班:&quot;</span>);</span><br><span class="line">        Browser.close();</span><br><span class="line">        IDE.close();</span><br><span class="line">        Wechat.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>上班:打开浏览器打开 IDE打开微信下班:关闭浏览器关闭 IDE关闭微信</code></pre><p>由于我们每天都要做这几件事，所以我们可以使用外观模式，将这几个子系统封装起来，提供更简洁的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        Browser.open();</span><br><span class="line">        IDE.open();</span><br><span class="line">        Wechat.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        Browser.close();</span><br><span class="line">        IDE.close();</span><br><span class="line">        Wechat.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端就可以简化代码，只和这个外观类打交道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;上班:&quot;</span>);</span><br><span class="line">        facade.open();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下班:&quot;</span>);</span><br><span class="line">        facade.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出与之前一样。</p><p>外观模式就是这么简单，它使得两种不同的类不用直接交互，而是通过一个中间件——也就是外观类——间接交互。外观类中只需要暴露简洁的接口，隐藏内部的细节，所以说白了就是封装的思想。</p><p>外观模式非常常用，（当然了！写代码哪有不封装的！）尤其是在第三方库的设计中，我们应该提供尽量简洁的接口供别人调用。另外，在 MVC 架构中，C 层（Controller）就可以看作是外观类，Model 和 View 层通过 Controller 交互，减少了耦合。</p><h3 id="享元模式-Flyweight"><a href="#享元模式-Flyweight" class="headerlink" title="享元模式 Flyweight"></a>享元模式 Flyweight</h3><p>享元模式体现的是程序可复用的特点，为了节约宝贵的内存，程序应该尽可能地复用，就像《极限编程》作者 Kent 在书里说到的那样：Don’t repeat yourself. 简单来说享元模式就是共享对象，提高复用性，官方的定义倒是显得文绉绉的：</p><blockquote><p>享元模式：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p></blockquote><p>有个细节值得注意：有些对象本身不一样，但通过一点点变化后就可以复用，我们编程时可能稍不注意就会忘记复用这些对象。比如说伟大的超级玛丽，谁能想到草和云更改一下颜色就可以实现复用呢？还有里面的三种乌龟，换一个颜色、加一个装饰就变成了不同的怪。</p><p>在超级玛丽中，这样的细节还有很多，正是这些精湛的复用使得这一款红遍全球的游戏仅有 40KB 大小。正是印证了那句名言：神在细节之中。</p><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h3><p>现在我们有一个人类，他整天就只负责吃饭、睡觉。</p><p>人类的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.eat();</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>我在吃饭我在睡觉</code></pre><p>我们可以把这个类包装到另一个类中，实现完全一样的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Person person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonProxy</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        person.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将客户端修改为调用这个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">PersonProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonProxy</span>(person);</span><br><span class="line">        proxy.eat();</span><br><span class="line">        proxy.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>我在吃饭我在睡觉</code></pre><p>这就是代理模式。</p><p>笔者力图用最简洁的代码讲解此模式，只要理解了上述这个简单的例子，你就知道代理模式是怎么一回事了。我们在客户端和 Person 类之间新增了一个中间件 PersonProxy，这个类就叫做代理类，他实现了和 Person 类一模一样的行为。</p><blockquote><p>代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p></blockquote><p>现在这个代理类还看不出任何意义，我们来模拟一下工作中的需求。在实际工作中，我们可能会遇到这样的需求：在网络请求前后，分别打印将要发送的数据和接收到数据作为日志信息。此时我们就可以新建一个网络请求的代理类，让它代为处理网络请求，并在代理类中打印这些日志信息。</p><p>新建网络请求接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IHttp</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sendData)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String receivedData)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 Http 请求工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpUtil</span> <span class="keyword">implements</span> <span class="title class_">IHttp</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sendData)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;网络请求中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String receivedData)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;网络请求完成。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 Http 代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpProxy</span> <span class="keyword">implements</span> <span class="title class_">IHttp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sendData)</span> &#123;</span><br><span class="line">        httpUtil.request(sendData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String receivedData)</span> &#123;</span><br><span class="line">        httpUtil.onSuccess(receivedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，和我们上述吃饭睡觉的代码是一模一样的，现在我们在 HttpProxy 中新增打印日志信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpProxy</span> <span class="keyword">implements</span> <span class="title class_">IHttp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sendData)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送数据:&quot;</span> + sendData);</span><br><span class="line">        httpUtil.request(sendData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String receivedData)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到数据:&quot;</span> + receivedData);</span><br><span class="line">        httpUtil.onSuccess(receivedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HttpUtil</span> <span class="variable">httpUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpUtil</span>();</span><br><span class="line">        <span class="type">HttpProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpProxy</span>(httpUtil);</span><br><span class="line">        proxy.request(<span class="string">&quot;request data&quot;</span>);</span><br><span class="line">        proxy.onSuccess(<span class="string">&quot;received result&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><pre><code>发送数据:request data网络请求中...收到数据:received result网络请求完成。</code></pre><p>这就是代理模式的一个应用，除了打印日志，它还可以用来做权限管理。读者看到这里可能已经发现了，这个代理类看起来和装饰模式的 FilterInputStream 一模一样，但两者的目的不同，装饰模式是为了增强功能或添加功能，代理模式主要是为了加以控制。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>上例中的代理被称之为静态代理，动态代理与静态代理的原理一模一样，只是换了一种写法。使用动态代理，需要把一个类传入，然后根据它正在调用的方法名判断是否需要加以控制。用伪代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpProxy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpUtil httpUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpProxy</span><span class="params">(HttpUtil httpUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpUtil = httpUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设调用 httpUtil 的任意方法时，都要通过这个方法间接调用, methodName 表示方法名，args 表示方法中传入的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">visit</span><span class="params">(String methodName, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 request，打印日志，并调用 request 方法，args 的第一个值就是传入的参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发送数据:&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">            httpUtil.request(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">&quot;onSuccess&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法，args 的第一个值就是传入的参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;收到数据:&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">            httpUtil.onSuccess(args[<span class="number">0</span>].toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪代码看起来还是很简单的，实现起来唯一的难点就是怎么让 httpUtil 调用任意方法时，都通过一个方法间接调用。这里需要用到反射技术，不了解反射技术也没有关系，不妨把它记做固定的写法。实际的动态代理类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HttpUtil httpUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IHttp <span class="title function_">getInstance</span><span class="params">(HttpUtil httpUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.httpUtil = httpUtil;</span><br><span class="line">        <span class="keyword">return</span> (IHttp) Proxy.newProxyInstance(httpUtil.getClass().getClassLoader(), httpUtil.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 httpUtil 的任意方法时，都要通过这个方法调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 request，打印日志，并调用 request 方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;发送数据:&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">            result = method.invoke(httpUtil, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;onSuccess&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果方法名是 onSuccess，打印日志，并调用 onSuccess 方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;收到数据:&quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">            result = method.invoke(httpUtil, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看 getInstance 方法，Proxy.newProxyInstance 方法是 Java 系统提供的方法，专门用于动态代理。其中传入的第一个参数是被代理的类的 ClassLoader，第二个参数是被代理类的 Interfaces，这两个参数都是 Object 中的，每个类都有，这里就是固定写法。我们只要知道系统需要这两个参数才能让我们实现我们的目的：调用被代理类的任意方法时，都通过一个方法间接调用。现在我们给系统提供了这两个参数，系统就会在第三个参数中帮我们实现这个目的。</p><p>第三个参数是 InvocationHandler 接口，这个接口中只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure><p>那么不用猜就知道，现在我们调用被代理类 httpUtil 的任意方法时，都会通过这个 invoke 方法调用了。invoke 方法中，第一个参数我们暂时用不上，第二个参数 method 就是调用的方法，使用 method.getName() 可以获取到方法名，第三个参数是调用 method 方法需要传入的参数。本例中无论 request 还是 onSuccess 都只有一个 String 类型的参数，对应到这里就是 args[0]。返回的 Object 是 method 方法的返回值，本例中都是无返回值的。</p><p>我们在 invoke 方法中判断了当前调用方法的方法名，如果现在调用的方法是 request，那么打印请求参数，并使用这一行代码继续执行当前方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = method.invoke(httpUtil, args);</span><br></pre></td></tr></table></figure><p>这就是反射调用函数的写法，如果不了解可以记做固定写法，想要了解的同学可以看之前的这篇文章：详解Java 反射。虽然这个函数没有返回值，但我们还是将 result 返回，这是标准做法。</p><p>如果现在调用的方法是 onSuccess，那么打印接收到的数据，并反射继续执行当前方法。</p><p>修改客户端验证一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HttpUtil</span> <span class="variable">httpUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpUtil</span>();</span><br><span class="line">        <span class="type">IHttp</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpProxy</span>().getInstance(httpUtil);</span><br><span class="line">        proxy.request(<span class="string">&quot;request data&quot;</span>);</span><br><span class="line">        proxy.onSuccess(<span class="string">&quot;received result&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出与之前一样：</p><pre><code>发送数据:request data网络请求中...收到数据:received result网络请求完成。</code></pre><p>动态代理本质上与静态代理没有区别，它的好处是节省代码量。比如被代理类有 20 个方法，而我们只需要控制其中的两个方法，就可以用动态代理通过方法名对被代理类进行动态的控制，而如果用静态方法，我们就需要将另外的 18 个方法也写出来，非常繁琐。这就是动态代理的优势所在。</p><h3 id="小结-Summary-1"><a href="#小结-Summary-1" class="headerlink" title="小结 Summary"></a>小结 Summary</h3><ul><li>适配器模式：用于有相关性但不兼容的接口</li><li>桥接模式：用于同等级的接口互相组合</li><li>组合模式：用于整体与部分的结构</li><li>装饰模式: 用于功能增强和添加新功能</li><li>外观模式：体现封装的思想</li><li>享元模式：体现面向对象的可复用性</li><li>代理模式：主要用于对某个对象加以控制</li></ul><h2 id="第三章：行为型模式-Behavioral-Patterns"><a href="#第三章：行为型模式-Behavioral-Patterns" class="headerlink" title="第三章：行为型模式 Behavioral Patterns"></a>第三章：行为型模式 Behavioral Patterns</h2><h3 id="责任链模式-Chain-of-responsibility"><a href="#责任链模式-Chain-of-responsibility" class="headerlink" title="责任链模式 Chain of responsibility"></a>责任链模式 Chain of responsibility</h3><p>我们每个人在工作中都承担着一定的责任，比如程序员承担着开发新功能、修改 bug 的责任，运营人员承担着宣传的责任、HR 承担着招聘新人的责任。我们每个人的责任与这个责任链有什么关系吗？</p><p>——答案是并没有太大关系。</p><p>但也不是完全没有关系，主要是因为每个人在不同岗位上的责任是分散的，分散的责任组合在一起更像是一张网，无法组成一条链。</p><p>同一个岗位上的责任，就可以组成一条链。</p><p>举个切身的例子，比如：普通的程序员可以解决中等难度的 bug，优秀程序员可以解决困难的 bug，而菜鸟程序员只能解决简单的 bug。为了将其量化，我们用一个数字来表示 bug 的难度，(0, 20] 表示简单，(20,50] 表示中等， (50,100] 表示困难，我们来模拟一个 bug 解决的流程。</p><h4 id="“解决-bug”-程序-1-0"><a href="#“解决-bug”-程序-1-0" class="headerlink" title="“解决 bug” 程序 1.0"></a>“解决 bug” 程序 1.0</h4><p>新建一个 bug 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bug</span> &#123;</span><br><span class="line">    <span class="comment">// bug 的难度值</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bug</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个程序员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line">    <span class="comment">// 程序员类型：菜鸟、普通、优秀</span></span><br><span class="line">    <span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Programmer</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;程序员解决了一个难度为 &quot;</span> + bug.value + <span class="string">&quot; 的 bug&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">newbie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;菜鸟&quot;</span>);</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">normal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;普通&quot;</span>);</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">good</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Bug</span> <span class="variable">easy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">hard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次尝试解决 bug</span></span><br><span class="line">        handleBug(newbie, easy);</span><br><span class="line">        handleBug(normal, easy);</span><br><span class="line">        handleBug(good, easy);</span><br><span class="line"></span><br><span class="line">        handleBug(newbie, middle);</span><br><span class="line">        handleBug(normal, middle);</span><br><span class="line">        handleBug(good, middle);</span><br><span class="line"></span><br><span class="line">        handleBug(newbie, hard);</span><br><span class="line">        handleBug(normal, hard);</span><br><span class="line">        handleBug(good, hard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleBug</span><span class="params">(Programmer programmer, Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;菜鸟&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">0</span> &amp;&amp; bug.value &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;普通&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">20</span> &amp;&amp; bug.value &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;优秀&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">50</span> &amp;&amp; bug.value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑很简单，我们让三种类型的程序员依次尝试解决 bug，如果 bug 难度在自己能解决的范围内，则自己处理此 bug。</p><p>运行程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">菜鸟程序员解决了一个难度为 <span class="number">20</span> 的 bug</span><br><span class="line">普通程序员解决了一个难度为 <span class="number">50</span> 的 bug</span><br><span class="line">优秀程序员解决了一个难度为 <span class="number">100</span> 的 bug</span><br></pre></td></tr></table></figure><p>输出没有问题，说明功能完美实现了，但在这个程序中，我们让每个程序员都尝试处理了每一个 bug，这也就相当于大家围着讨论每个 bug 该由谁解决，这无疑是非常低效的做法。那么我们要怎么才能优化呢？</p><h4 id="“解决-bug”-程序-2-0"><a href="#“解决-bug”-程序-2-0" class="headerlink" title="“解决 bug” 程序 2.0"></a>“解决 bug” 程序 2.0</h4><p>实际上，许多公司会选择让项目经理来分派任务，项目经理会根据 bug 的难度指派给不同的人解决。</p><p>引入 ProjectManager 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectManager</span> &#123;</span><br><span class="line">    <span class="type">Programmer</span> <span class="variable">newbie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;菜鸟&quot;</span>);</span><br><span class="line">    <span class="type">Programmer</span> <span class="variable">normal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;普通&quot;</span>);</span><br><span class="line">    <span class="type">Programmer</span> <span class="variable">good</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">assignBug</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bug.value &gt; <span class="number">0</span> &amp;&amp; bug.value &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;项目经理将这个简单的 bug 分配给了菜鸟程序员&quot;</span>);</span><br><span class="line">            newbie.solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bug.value &gt; <span class="number">20</span> &amp;&amp; bug.value &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;项目经理将这个中等的 bug 分配给了普通程序员&quot;</span>);</span><br><span class="line">            normal.solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bug.value &gt; <span class="number">50</span> &amp;&amp; bug.value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;项目经理将这个困难的 bug 分配给了优秀程序员&quot;</span>);</span><br><span class="line">            good.solve(bug);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们让项目经理管理所有的程序员，并且根据 bug 的难度指派任务。这样一来，所有的 bug 只需传给项目经理分配即可，修改客户端如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProjectManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProjectManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Bug</span> <span class="variable">easy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">hard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        manager.assignBug(easy);</span><br><span class="line">        manager.assignBug(middle);</span><br><span class="line">        manager.assignBug(hard);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">项目经理将这个简单的 bug 分配给了菜鸟程序员</span><br><span class="line">菜鸟程序员解决了一个难度为 <span class="number">20</span> 的 bug</span><br><span class="line">项目经理将这个中等的 bug 分配给了普通程序员</span><br><span class="line">普通程序员解决了一个难度为 <span class="number">50</span> 的 bug</span><br><span class="line">项目经理将这个困难的 bug 分配给了优秀程序员</span><br><span class="line">优秀程序员解决了一个难度为 <span class="number">100</span> 的 bug</span><br></pre></td></tr></table></figure><p>看起来很美好，除了项目经理在骂骂咧咧地反驳这个方案。</p><p>在这个经过修改的程序中，项目经理一个人承担了分配所有 bug 这个体力活。程序没有变得简洁，只是把复杂的逻辑从客户端转移到了项目经理类中。</p><p>而且项目经理类承担了过多的职责，如果以后新增一类程序员，必须改动项目经理类，将其处理 bug 的职责插入分支判断语句中，违反了单一职责原则和开闭原则。</p><p>所以，我们需要更优的解决方案，那就是——责任链模式！</p><h4 id="“解决-bug”-程序-3-0"><a href="#“解决-bug”-程序-3-0" class="headerlink" title="“解决 bug” 程序 3.0"></a>“解决 bug” 程序 3.0</h4><blockquote><p>责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>在本例的场景中，每个程序员的责任都是“解决这个 bug”，当测试提出一个 bug 时，可以走这样一条责任链：</p><p>先交由菜鸟程序员之手，如果是简单的 bug，菜鸟程序员自己处理掉。如果这个 bug 对于菜鸟程序员来说太难了，交给普通程序员<br>如果是中等难度的 bug，普通程序员处理掉。如果他也解决不了，交给优秀程序员<br>优秀程序员处理掉困难的 bug<br>有的读者会提出疑问，如果优秀程序员也无法处理这个 bug 呢？</p><p>——那当然是处理掉这个假冒优秀程序员。</p><p>修改客户端如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">newbie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;菜鸟&quot;</span>);</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">normal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;普通&quot;</span>);</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">good</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Programmer</span>(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Bug</span> <span class="variable">easy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">hard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式传递责任</span></span><br><span class="line">        <span class="keyword">if</span> (!handleBug(newbie, easy)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handleBug(normal, easy)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!handleBug(good, easy)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Kill the fake good programmer!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handleBug(newbie, middle)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handleBug(normal, middle)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!handleBug(good, middle)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Kill the fake good programmer!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handleBug(newbie, hard)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!handleBug(normal, hard)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!handleBug(good, hard)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Kill the fake good programmer!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleBug</span><span class="params">(Programmer programmer, Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;菜鸟&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">0</span> &amp;&amp; bug.value &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;普通&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">20</span> &amp;&amp; bug.value &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (programmer.type.equals(<span class="string">&quot;优秀&quot;</span>) &amp;&amp; bug.value &gt; <span class="number">50</span> &amp;&amp; bug.value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            programmer.solve(bug);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个嵌套的 if 条件句就组成了一条 菜鸟-&gt; 普通 -&gt; 优秀 的责任链。我们使 handleBug 方法返回一个 boolean 值，如果此 bug 被处理了，返回 true；否则返回 false，使得责任沿着 菜鸟-&gt; 普通 -&gt; 优秀这条链继续传递，这就是责任链模式的思路。</p><p>运行程序，输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">菜鸟程序员解决了一个难度为 <span class="number">20</span> 的 bug</span><br><span class="line">普通程序员解决了一个难度为 <span class="number">50</span> 的 bug</span><br><span class="line">优秀程序员解决了一个难度为 <span class="number">100</span> 的 bug</span><br></pre></td></tr></table></figure><p>熟悉责任链模式的同学应该可以看出，这个责任链模式和我们平时使用的不太一样。事实上，这段代码已经很好地体现了责任链模式的基本思想。我们平时使用的责任链模式只是在面向对象的基础上，将这段代码封装了一下。那么接下来我们就来对这段代码进行封装，将它变成规范的责任链模式的写法。</p><h4 id="“解决-bug”-程序-4-0"><a href="#“解决-bug”-程序-4-0" class="headerlink" title="“解决 bug” 程序 4.0"></a>“解决 bug” 程序 4.0</h4><p>新建一个程序员抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Programmer next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Programmer next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Bug bug)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个抽象类中：</p><ul><li>next 对象表示如果自己解决不了，需要将责任传递给的下一个人；</li><li>handle 方法表示自己处理此 bug 的逻辑，在这里判断是自己解决或者继续传递。</li></ul><p>新建菜鸟程序员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewbieProgrammer</span> <span class="keyword">extends</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bug.value &gt; <span class="number">0</span> &amp;&amp; bug.value &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            next.handle(bug);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;菜鸟程序员解决了一个难度为 &quot;</span> + bug.value + <span class="string">&quot; 的 bug&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建普通程序员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalProgrammer</span> <span class="keyword">extends</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bug.value &gt; <span class="number">20</span> &amp;&amp; bug.value &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">            solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            next.handle(bug);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通程序员解决了一个难度为 &quot;</span> + bug.value + <span class="string">&quot; 的 bug&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建优秀程序员类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoodProgrammer</span> <span class="keyword">extends</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bug.value &gt; <span class="number">50</span> &amp;&amp; bug.value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            solve(bug);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            next.handle(bug);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(Bug bug)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀程序员解决了一个难度为 &quot;</span> + bug.value + <span class="string">&quot; 的 bug&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client4</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NewbieProgrammer</span> <span class="variable">newbie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewbieProgrammer</span>();</span><br><span class="line">        <span class="type">NormalProgrammer</span> <span class="variable">normal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NormalProgrammer</span>();</span><br><span class="line">        <span class="type">GoodProgrammer</span> <span class="variable">good</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoodProgrammer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Bug</span> <span class="variable">easy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">50</span>);</span><br><span class="line">        <span class="type">Bug</span> <span class="variable">hard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bug</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组成责任链</span></span><br><span class="line">        newbie.setNext(normal);</span><br><span class="line">        normal.setNext(good);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从菜鸟程序员开始，沿着责任链传递</span></span><br><span class="line">        newbie.handle(easy);</span><br><span class="line">        newbie.handle(middle);</span><br><span class="line">        newbie.handle(hard);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端中，我们通过 setNext() 方法将三个程序员组成了一条责任链，由菜鸟程序员接收所有的 bug，发现自己不能处理的 bug，就传递给普通程序员，普通程序员收到 bug 后，如果发现自己不能解决，则传递给优秀程序员，这就是规范的责任链模式的写法了。</p><p>责任链思想在生活中有很多应用，比如假期审批、加薪申请等，在员工提出申请后，从经理开始，由你的经理决定自己处理或是交由更上一层的经理处理。</p><p>再比如处理客户投诉时，从基层的客服人员开始，决定自己回应或是上报给领导，领导再判断是否继续上报。</p><p>理清了责任链模式，笔者突然回想起，公司的测试组每次提出 bug 后，总是先指派给我！一瞬间仿佛明白了什么了不得的道理，不禁陷入了沉思。</p><h4 id="责任链模式小结"><a href="#责任链模式小结" class="headerlink" title="责任链模式小结"></a>责任链模式小结</h4><p>通过这个例子，我们已经了解到，责任链主要用于处理 职责相同，程度不同的类。</p><p>其主要优点有：</p><ul><li>降低了对象之间的耦合度。在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</li><li>扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。</li><li>灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。</li><li>简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的条件判断语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。不再需要 “项目经理” 来处理所有的责任分配任务。</li></ul><p>但我们在使用中也发现了它的一个明显缺点，如果这个 bug 没人处理，可能导致 “程序员祭天” 异常。其主要缺点有：</p><ul><li>不能保证每个请求一定被处理，该请求可能一直传到链的末端都得不到处理。</li><li>如果责任链过长，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链拼接次序错误而导致系统出错，比如可能出现循环调用。</li></ul><h3 id="命令模式-Command"><a href="#命令模式-Command" class="headerlink" title="命令模式 Command"></a>命令模式 Command</h3><p>近年来，智能家居越来越流行。躺在家中，只需要打开对应的 app，就可以随手控制家电开关。但随之而来一个问题，手机里的 app 实在是太多了，每一个家具公司都想要提供一个 app 给用户，以求增加用户粘性，推广他们的其他产品等。</p><p>站在用户的角度来看，有时我们只想打开一下电灯，却要先看到恼人的 “新式电灯上新” 的弹窗通知，让人烦不胜烦。如果能有一个万能遥控器将所有的智能家居开关综合起来，统一控制，一定会方便许多。</p><p>说干就干，笔者立马打开 PS，设计了一张草图：</p><img src="https://pic.leetcode-cn.com/1648035559-joCafB-image.png" width="300" height="500" div align=left /><p>“咳咳，我对这个 app 的设计理念呢，是基于 “简洁就是美” 的原则。一个好的设计，首先，最重要的一点就是 ‘接地气’。当然，我也可以用一些华丽的素材拼接出一个花里胡哨的设计，但，那是一个最低级的设计师才会做的事情…”</p><blockquote><p>翻译：He has no UI design skills.</p></blockquote><p>总之 UI 设计完成啦，我们再来看下四个智能家居类的结构。</p><p>大门类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Door</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">openDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;门打开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDoor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;门关闭了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电灯类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lightOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lightOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电灯&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电视类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tv</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TurnOnTv</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电视打开了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TurnOffTv</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电视关闭了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音乐类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Music</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始播放音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;停止播放音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是不同公司的产品，所以接口有所不同，接下来就一起来实现我们的万能遥控器！</p><h4 id="万能遥控器-1-0"><a href="#万能遥控器-1-0" class="headerlink" title="万能遥控器 1.0"></a>万能遥控器 1.0</h4><p>不一会儿，我们就写出了下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化开关</span></span><br><span class="line"><span class="type">Switch</span> <span class="variable">switchDoor</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"><span class="type">Switch</span> <span class="variable">switchLight</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"><span class="type">Switch</span> <span class="variable">switchTv</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"><span class="type">Switch</span> <span class="variable">switchMusic</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化智能家居</span></span><br><span class="line"><span class="type">Door</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Door</span>();</span><br><span class="line"><span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line"><span class="type">Tv</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tv</span>();</span><br><span class="line"><span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Music</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大门开关遥控</span></span><br><span class="line">switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        door.openDoor();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        door.closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 电灯开关遥控</span></span><br><span class="line">switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 电视开关遥控</span></span><br><span class="line">switchTv.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        tv.TurnOnTv();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tv.TurnOffTv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 音乐开关遥控</span></span><br><span class="line">switchMusic.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        music.play();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        music.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这份代码很直观，在每个开关状态改变时，调用对应家居的 API 实现打开或关闭。</p><p>只有这样的功能实在是太单一了，接下来我们再为它添加一个有趣的功能。</p><h4 id="万能遥控器-2-0"><a href="#万能遥控器-2-0" class="headerlink" title="万能遥控器 2.0"></a>万能遥控器 2.0</h4><p>一般来说，电视遥控器上都有一个回退按钮，用来回到上一个频道。相当于文本编辑器中的 “撤销” 功能，既然别的小朋友都有，那我们也要！</p><p>设计狮本狮马不停蹄地设计了 UI 2.0：</p><p><img src="https://pic.leetcode-cn.com/1648035618-nsBQun-image.png" alt="image"></p><p>UI 设计倒是简单，底部添加一个按钮即可。代码设计就比较复杂了，我们需要保存上一步操作，并且将其回退。</p><p>一个很容易想到的想法是：设计一个枚举类 Operation，代表每一步的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    DOOR_OPEN,</span><br><span class="line">    DOOR_CLOSE,</span><br><span class="line">    LIGHT_ON,</span><br><span class="line">    LIGHT_OFF,</span><br><span class="line">    TV_TURN_ON,</span><br><span class="line">    TV_TURN_OFF,</span><br><span class="line">    MUSIC_PLAY,</span><br><span class="line">    MUSIC_STOP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在客户端定义一个 Operation 变量，变量名字叫 lastOperation，在每一步操作后，更新此变量。然后在撤销按钮的点击事件中，根据上一步的操作实现回退：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一步的操作</span></span><br><span class="line">    Operation lastOperation;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化开关和撤销按钮</span></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchDoor</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchLight</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchTv</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchMusic</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnUndo</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化智能家居</span></span><br><span class="line">        <span class="type">Door</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Door</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="type">Tv</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tv</span>();</span><br><span class="line">        <span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Music</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大门开关遥控</span></span><br><span class="line">        switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">                lastOperation = Operation.DOOR_OPEN;</span><br><span class="line">                door.openDoor();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastOperation = Operation.DOOR_CLOSE;</span><br><span class="line">                door.closeDoor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 电灯开关遥控</span></span><br><span class="line">        switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">                lastOperation = Operation.LIGHT_ON;</span><br><span class="line">                light.lightOn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lastOperation = Operation.LIGHT_OFF;</span><br><span class="line">                light.lightOff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ... 电视、音乐类似</span><br><span class="line"></span><br><span class="line">        btnUndo.setOnClickListener(view -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastOperation == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 撤销上一步</span></span><br><span class="line">            <span class="keyword">switch</span> (lastOperation) &#123;</span><br><span class="line">                <span class="keyword">case</span> DOOR_OPEN:</span><br><span class="line">                    door.closeDoor();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOOR_CLOSE:</span><br><span class="line">                    door.openDoor();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LIGHT_ON:</span><br><span class="line">                    light.lightOff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LIGHT_OFF:</span><br><span class="line">                    light.lightOn();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ... 电视、音乐类似</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，不过这份代码只实现了撤销一步，如果我们需要实现撤销多步怎么做呢？</p><p>思考一下，每次回退时，都是先将最后一步 Operation 撤销。对于这种后进先出的结构，我们自然就会想到——栈结构。使用栈结构实现回退多步的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的操作</span></span><br><span class="line">    Stack&lt;Operation&gt; operations = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化开关和撤销按钮</span></span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchDoor</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchLight</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchTv</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Switch</span> <span class="variable">switchMusic</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnUndo</span> <span class="operator">=</span> 省略绑定UI代码;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化智能家居</span></span><br><span class="line">        <span class="type">Door</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Door</span>();</span><br><span class="line">        <span class="type">Light</span> <span class="variable">light</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        <span class="type">Tv</span> <span class="variable">tv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tv</span>();</span><br><span class="line">        <span class="type">Music</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Music</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大门开关遥控</span></span><br><span class="line">        switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">                operations.push(Operation.DOOR_OPEN);</span><br><span class="line">                door.openDoor();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                operations.push(Operation.DOOR_CLOSE);</span><br><span class="line">                door.closeDoor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 电灯开关遥控</span></span><br><span class="line">        switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">                operations.push(Operation.LIGHT_ON);</span><br><span class="line">                light.lightOn();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                operations.push(Operation.LIGHT_OFF);</span><br><span class="line">                light.lightOff();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ...电视、音乐类似</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销按钮</span></span><br><span class="line">        btnUndo.setOnClickListener(view -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (operations.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 弹出栈顶的上一步操作</span></span><br><span class="line">            <span class="type">Operation</span> <span class="variable">lastOperation</span> <span class="operator">=</span> operations.pop();</span><br><span class="line">            <span class="comment">// 撤销上一步</span></span><br><span class="line">            <span class="keyword">switch</span> (lastOperation) &#123;</span><br><span class="line">                <span class="keyword">case</span> DOOR_OPEN:</span><br><span class="line">                    door.closeDoor();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DOOR_CLOSE:</span><br><span class="line">                    door.openDoor();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LIGHT_ON:</span><br><span class="line">                    light.lightOff();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LIGHT_OFF:</span><br><span class="line">                    light.lightOn();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...电视、音乐类似</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将每一步 Operation 记录到栈中，每次撤销时，弹出栈顶的 Operation，再使用 switch 语句判断，将其恢复。</p><p>虽然实现了功能，但代码明显已经变得越来越臃肿了，因为遥控器知道了太多的细节，它必须要知道每个家居的调用方式。以后有开关加入时，不仅要修改 Status 类，增加新的 Operation，还要修改客户端，增加新的分支判断，导致这个类变成一个庞大的类。不仅违背了单一权责原则，还违背了开闭原则，所以我们不得不思考怎么优化这份代码。</p><h4 id="万能遥控器-3-0"><a href="#万能遥控器-3-0" class="headerlink" title="万能遥控器 3.0"></a>万能遥控器 3.0</h4><p>我们期待能有一种设计，让遥控器不需要知道家居的接口。它只需要负责监听用户按下开关，再根据开关状态发出正确的命令，对应的家居在收到命令后做出响应。就可以达到将 “行为请求者” 和 ”行为实现者“ 解耦的目的。</p><p>先定义一个命令接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中只有一个 execute 方法，表示 “执行” 命令。</p><p>定义开门命令，实现此接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorOpenCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Door door;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDoor</span><span class="params">(Door door)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.door = door;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        door.openDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关门命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorCloseCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Door door;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDoor</span><span class="params">(Door door)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.door = door;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        door.closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开灯命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLight</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关灯命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLight</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电视、音乐的命令类似。</p><p>可以看到，我们将家居控制的代码转移到了命令类中，当命令执行时，调用对应家具的 API 实现开启或关闭。</p><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化命令</span></span><br><span class="line"><span class="type">DoorOpenCommand</span> <span class="variable">doorOpenCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoorOpenCommand</span>();</span><br><span class="line"><span class="type">DoorCloseCommand</span> <span class="variable">doorCloseCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoorCloseCommand</span>();</span><br><span class="line">doorOpenCommand.setDoor(door);</span><br><span class="line">doorCloseCommand.setDoor(door);</span><br><span class="line"><span class="type">LightOnCommand</span> <span class="variable">lightOnCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOnCommand</span>();</span><br><span class="line"><span class="type">LightOffCommand</span> <span class="variable">lightOffCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightOffCommand</span>();</span><br><span class="line">lightOnCommand.setLight(light);</span><br><span class="line">lightOffCommand.setLight(light);</span><br><span class="line">...电视、音乐类似</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大门开关遥控</span></span><br><span class="line">switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        doorOpenCommand.execute();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doorCloseCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 电灯开关遥控</span></span><br><span class="line">switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">        lightOnCommand.execute();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lightOffCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...电视、音乐类似</span><br></pre></td></tr></table></figure><p>现在，遥控器只知道用户控制开关后，需要执行对应的命令，遥控器并不知道这个命令会执行什么内容，它只负责调用 execute 方法，达到了隐藏技术细节的目的。</p><p>与此同时，我们还获得了一个附带的好处。由于每个命令都被抽象成了同一个接口，我们可以将开关代码统一起来。客户端优化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ...初始化</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大门开关遥控</span></span><br><span class="line">        switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, doorOpenCommand, doorCloseCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 电灯开关遥控</span></span><br><span class="line">        switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, lightOnCommand, lightOffCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 电视开关遥控</span></span><br><span class="line">        switchTv.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, turnOnTvCommand, turnOffTvCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 音乐开关遥控</span></span><br><span class="line">        switchMusic.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, musicPlayCommand, musicStopCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCommand</span><span class="params">(<span class="type">boolean</span> isChecked, ICommand openCommand, ICommand closeCommand)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">            openCommand.execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeCommand.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知不觉中，我们就写出了命令模式的代码。来看下命令模式的定义：</p><blockquote><p>命令模式：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>使用命令模式后，现在我们要实现撤销功能会非常容易。</p><p>首先，在命令接口中，新增 undo 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开门命令中新增 undo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorOpenCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Door door;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDoor</span><span class="params">(Door door)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.door = door;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        door.openDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        door.closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关门命令中新增 undo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoorCloseCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Door door;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDoor</span><span class="params">(Door door)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.door = door;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        door.closeDoor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        door.openDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开灯命令中新增 undo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLight</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关灯命令中新增 undo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line"></span><br><span class="line">    Light light;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLight</span><span class="params">(Light light)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        light.lightOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电视、音乐命令类似。</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的命令</span></span><br><span class="line">    Stack&lt;ICommand&gt; commands = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        ...初始化</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大门开关遥控</span></span><br><span class="line">        switchDoor.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, doorOpenCommand, doorCloseCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 电灯开关遥控</span></span><br><span class="line">        switchLight.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, lightOnCommand, lightOffCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 电视开关遥控</span></span><br><span class="line">        switchTv.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, turnOnTvCommand, turnOffTvCommand);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 音乐开关遥控</span></span><br><span class="line">        switchMusic.setOnCheckedChangeListener((view, isChecked) -&gt; &#123;</span><br><span class="line">            handleCommand(isChecked, musicPlayCommand, musicStopCommand);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销按钮</span></span><br><span class="line">        btnUndo.setOnClickListener(view -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (commands.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 撤销上一个命令</span></span><br><span class="line">            <span class="type">ICommand</span> <span class="variable">lastCommand</span> <span class="operator">=</span> commands.pop();</span><br><span class="line">            lastCommand.undo();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCommand</span><span class="params">(<span class="type">boolean</span> isChecked, ICommand openCommand, ICommand closeCommand)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">            commands.push(openCommand);</span><br><span class="line">            openCommand.execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            commands.push(closeCommand);</span><br><span class="line">            closeCommand.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样使用了一个栈结构，用于存储所有的命令，在每次执行命令前，将命令压入栈中。撤销时，弹出栈顶的命令，执行其 undo 方法即可。</p><p>命令模式使得客户端的职责更加简洁、清晰了，命令执行、撤销的代码都被隐藏到了命令类中。唯一的缺点是 —— 多了很多的命令类，因为我们必须针对每一个命令都设计一个命令类，容易导致类爆炸。</p><p>除了撤销方便外，命令模式还有一个优点，那就是宏命令的使用，宏命令也就是组合多个命令的 “宏大的命令”。</p><h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><p>宏命令就是 将多个命令合并起来组成的命令。</p><p>接下来我们给遥控器添加一个 “睡眠” 按钮，按下时可以一键关闭大门，关闭电灯，关闭电视、打开音乐（听着音乐睡觉，就是这么优雅）。UI 设计…就不看了吧，这时就可以使用宏命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacroCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一组命令</span></span><br><span class="line">    List&lt;ICommand&gt; commands;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MacroCommand</span><span class="params">(List&lt;ICommand&gt; commands)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.commands = commands;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 宏命令执行时，每个命令依次执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            commands.get(i).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 宏命令撤销时，每个命令依次撤销</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            commands.get(i).undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了宏命令，我们就可以任意组合多个命令，并且完全不会增加程序结构的复杂度。</p><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义睡眠宏命令</span></span><br><span class="line"><span class="type">MacroCommand</span> <span class="variable">sleepCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacroCommand</span>(Arrays.asList(doorCloseCommand, lightOffCommand, turnOffTvCommand, musicPlayCommand));</span><br><span class="line"><span class="comment">// 睡眠按钮</span></span><br><span class="line">btnSleep.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    <span class="comment">// 将执行的命令保存到栈中，以便撤销</span></span><br><span class="line">    commands.push(sleepCommand);</span><br><span class="line">    <span class="comment">// 执行睡眠命令</span></span><br><span class="line">    sleepCommand.execute();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，我们将 doorCloseCommand, lightOffCommand, turnOffTvCommand, musicPlayCommand 三个命令组合到了宏命令 sleepCommand 中，这个宏命令的使用方式和普通命令一模一样，因为它本身也是一个实现了 ICommand 接口的命令而已。</p><h4 id="请求排队"><a href="#请求排队" class="headerlink" title="请求排队"></a>请求排队</h4><p>前文的定义中讲到，命令模式还可以用于请求排队。那么怎么实现请求排队功能呢？</p><p>要实现请求排队功能，只需创建一个命令队列，将每个需要执行的命令依次传入队列中，然后工作线程不断地从命令队列中取出队列头的命令，再执行命令即可。</p><p>事实上，安卓 app 的界面就是这么实现的。源码中使用了一个阻塞式死循环 Looper，不断地从 MessageQueue 中取出消息，交给 Handler 处理，用户的每一个操作也会通过 Handler 传递到 MessageQueue 中排队执行。</p><h4 id="命令模式小结"><a href="#命令模式小结" class="headerlink" title="命令模式小结"></a>命令模式小结</h4><p>命令模式可以说将封装发挥得淋漓尽致。在我们平时的程序设计中，最常用的封装是将拥有一类职责的对象封装成类，而命令对象的唯一职责就是通过 execute 去调用一个方法，也就是说它将 “方法调用” 这个步骤封装起来了，使得我们可以对 “方法调用” 进行排队、撤销等处理。</p><p>命令模式的主要优点如下：</p><ul><li><p>降低系统的耦合度。将 “行为请求者” 和 ”行为实现者“ 解耦。</p></li><li><p>扩展性强。增加或删除命令非常方便，并且不会影响其他类。</p></li><li><p>封装 “方法调用”，方便实现 Undo 和 Redo 操作。</p></li><li><p>灵活性强，可以实现宏命令。</p></li></ul><p>它的主要缺点是：</p><ul><li>会产生大量命令类。增加了系统的复杂性。</li></ul><h3 id="解释器模式-Interpreter"><a href="#解释器模式-Interpreter" class="headerlink" title="解释器模式 Interpreter"></a>解释器模式 Interpreter</h3><p>我国 IT 界历来有一个汉语编程梦，虽然各方对于汉语编程争论不休，甚至上升到民族大义的高度，本文不讨论其对与错，但我们不妨来尝试一下，定义一个简单的中文编程语法。</p><p>在设计模式中，解释器模式就是用来自定义语法的，它的定义如下。</p><blockquote><p>解释器模式（Interpreter Pattern）：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p></blockquote><p>解释器模式较为晦涩难懂，但本文我们仍然深入浅出，通过一个简单的例子来学习解释器模式：使用中文编写出十以内的加减法公式。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入“一加一”，输出结果 2</span><br><span class="line">输入“一加一加一”，输出结果 3</span><br><span class="line">输入“二加五减三”，输出结果 4</span><br><span class="line">输入“七减五加四减一”，输出结果 5</span><br><span class="line">输入“九减五加三减一”，输出结果 6</span><br></pre></td></tr></table></figure><p>看到这个需求，我们很容易想到一种写法：将输入的字符串分割成单个字符，把数字字符通过switch-case转换为数字，再通过计算符判断是加法还是减法，对应做加、减计算，最后返回结果即可。</p><p>的确可行，但这实在太面向过程了。众所周知，面向过程编程会有耦合度高，不易扩展等缺点。接下来我们尝试按照面向对象的写法来实现这个功能。</p><p>按照面向对象的编程思想，我们应该为公式中不同种类的元素建立一个对应的对象。那么我们先分析一下公式中的成员：</p><ul><li>数字：零到九对应 0 ~ 9</li><li>计算符：加、减对应+、-</li></ul><p>公式中仅有这两种元素，其中对于数字的处理比较简单，只需要通过 switch-case 将中文名翻译成阿拉伯数字即可。</p><p>计算符怎么处理呢？计算符左右两边可能是单个数字，也可能是另一个计算公式。但无论是数字还是公式，两者都有一个共同点，那就是他们都会返回一个整数：数字返回其本身，公式返回其计算结果。</p><p>所以我们可以根据这个共同点提取出一个返回整数的接口，数字和计算符都作为该接口的实现类。在计算时，使用栈结构存储数据，将数字和计算符统一作为此接口的实现类压入栈中计算。</p><blockquote><p>talk is cheap, show me the code.</p></blockquote><p>数字和计算符公共的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文已经说到，数字和计算符都属于表达式的一部分，他们的共同点是都会返回一个整数。从表达式计算出整数的过程，我们称之为解释（interpret）。</p><p>对数字类的解释实现起来相对比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Number</span><span class="params">(<span class="type">char</span> word)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (word) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;零&#x27;</span>:</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;一&#x27;</span>:</span><br><span class="line">                number = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;二&#x27;</span>:</span><br><span class="line">                number = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;三&#x27;</span>:</span><br><span class="line">                number = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;四&#x27;</span>:</span><br><span class="line">                number = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;五&#x27;</span>:</span><br><span class="line">                number = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;六&#x27;</span>:</span><br><span class="line">                number = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;七&#x27;</span>:</span><br><span class="line">                number = <span class="number">7</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;八&#x27;</span>:</span><br><span class="line">                number = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;九&#x27;</span>:</span><br><span class="line">                number = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Number 类的构造函数中，先将传入的字符转换为对应的数字。在解释时将转换后的数字返回即可。</p><p>无论是加法还是减法，他们都是对左右两个表达式进行操作，所以我们可以将计算符提取出共同的抽象父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Operator</span> <span class="keyword">implements</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    Expression left;</span><br><span class="line">    Expression right;</span><br><span class="line"></span><br><span class="line">    Operator(Expression left, Expression right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此抽象父类中，我们存入了两个变量，表达计算符左右两边的表达式。</p><p>加法类实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    Add(Expression left, Expression right) &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() + right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减法类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    Sub(Expression left, Expression right) &#123;</span><br><span class="line">        <span class="built_in">super</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">interpret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left.interpret() - right.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加法类和减法类都继承自 Operator 类，在对他们进行解释时，将左右两边表达式解释出的值相加或相减即可。</p><p>数字类和计算符内都定义好了，这时我们只需要再编写一个计算类将他们综合起来，统一计算即可。</p><p>计算类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        Stack&lt;Expression&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">word</span> <span class="operator">=</span> expression.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (word) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;加&#x27;</span>:</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Add</span>(stack.pop(), <span class="keyword">new</span> <span class="title class_">Number</span>(expression.charAt(++i))));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;减&#x27;</span>:</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Sub</span>(stack.pop(), <span class="keyword">new</span> <span class="title class_">Number</span>(expression.charAt(++i))));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(<span class="keyword">new</span> <span class="title class_">Number</span>(word));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在计算类中，我们使用栈结构保存每一步操作。遍历 expression 公式：</p><p>遇到数字则将其压入栈中；<br>遇到计算符时，先将栈顶元素 pop 出来，再和下一个数字一起传入计算符的构造函数中，组成一个计算符公式压入栈中。</p><p>需要注意的是，入栈出栈过程并不会执行真正的计算，栈操作只是将表达式组装成一个嵌套的类对象而已。比如：</p><ul><li>“一加一”表达式，经过入栈出栈操作后，生成的对象是 <code>new Add(new Number(&#39;一&#39;), new Number(&#39;一&#39;))</code></li><li>“二加五减三”表达式，经过入栈出栈操作后，生成的对象是 <code>new Sub(new Add(new Number(&#39;二&#39;), new Number(&#39;五&#39;)), new Number(&#39;三&#39;))</code></li></ul><p>最后一步 stack.pop().interpret()，将栈顶的元素弹出，执行 interpret() ，这时才会执行真正的计算。计算时会将中文的数字和运算符分别解释成计算机能理解的指令。</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression1</span> <span class="operator">=</span> <span class="string">&quot;一加一&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression2</span> <span class="operator">=</span> <span class="string">&quot;一加一加一&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression3</span> <span class="operator">=</span> <span class="string">&quot;二加五减三&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression4</span> <span class="operator">=</span> <span class="string">&quot;七减五加四减一&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression5</span> <span class="operator">=</span> <span class="string">&quot;九减五加三减一&quot;</span>;</span><br><span class="line">        <span class="comment">// 输出： 一加一 等于 2</span></span><br><span class="line">        System.out.println(expression1 + <span class="string">&quot; 等于 &quot;</span> + calculator.calculate(expression1));</span><br><span class="line">        <span class="comment">// 输出： 一加一加一 等于 3</span></span><br><span class="line">        System.out.println(expression2 + <span class="string">&quot; 等于 &quot;</span> + calculator.calculate(expression2));</span><br><span class="line">        <span class="comment">// 输出： 二加五减三 等于 4</span></span><br><span class="line">        System.out.println(expression3 + <span class="string">&quot; 等于 &quot;</span> + calculator.calculate(expression3));</span><br><span class="line">        <span class="comment">// 输出： 七减五加四减一 等于 5</span></span><br><span class="line">        System.out.println(expression4 + <span class="string">&quot; 等于 &quot;</span> + calculator.calculate(expression4));</span><br><span class="line">        <span class="comment">// 输出： 九减五加三减一 等于 6</span></span><br><span class="line">        System.out.println(expression5 + <span class="string">&quot; 等于 &quot;</span> + calculator.calculate(expression5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是解释器模式，我们将一句中文的公式解释给计算机，然后计算机为我们运算出了正确的结果。</p><p>分析本例中公式的组成，我们可以发现几条显而易见的性质：</p><ul><li>数字类不可被拆分，属于计算中的最小单元；</li><li>加法类、减法类可以被拆分成两个数字（或两个公式）加一个计算符，他们不是计算的最小单元。</li></ul><p>在解释器模式中，我们将不可拆分的最小单元称之为终结表达式，可以被拆分的表达式称之为非终结表达式。</p><p>解释器模式具有一定的拓展性，当需要添加其他计算符时，我们可以通过添加 Operator 的子类来完成。但添加后需要按照运算优先级修改计算规则。可见一个完整的解释器模式是非常复杂的，实际开发中几乎没有需要自定义解释器的情况。</p><p>解释器模式有一个常见的应用，在我们平时匹配字符串时，用到的正则表达式就是一个解释器。</p><h4 id="解释器主要角色"><a href="#解释器主要角色" class="headerlink" title="解释器主要角色"></a>解释器主要角色</h4><ol><li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。例如本文Expression()</p></li><li><p>终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。<br>例如本文Number()</p></li><li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。例如本文Operator()</p></li><li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p></li><li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p></li></ol><h3 id="迭代器模式-Iterator"><a href="#迭代器模式-Iterator" class="headerlink" title="迭代器模式 Iterator"></a>迭代器模式 Iterator</h3><p>设想一个场景：我们有一个类中存在一个列表。这个列表需要提供给外部类访问，但我们不希望外部类修改其中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来说，将成员变量提供给外部类访问有两种方式：</p><ul><li>将此列表设置为 public 变量；</li><li>添加 getData() 方法，返回此列表。</li></ul><p>但这两种方式都有一个致命的缺点，它们无法保证外部类不修改其中的数据。外部类拿到 data 对象后，可以随意修改列表内部的元素，这会造成极大的安全隐患。</p><p>那么有什么更好的方式吗？使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性。</p><p>分析可知，我们可以通过提供两个方法实现此效果：</p><ul><li>提供一个 String next() 方法，使得外部类可以按照次序，一条一条的读取数据；</li><li>提供一个 boolean hasNext() 方法，告知外部类是否还有下一条数据。</li></ul><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据后，将 index 加 1，使得下次访问时返回下一条数据</span></span><br><span class="line">        <span class="keyword">return</span> data.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; data.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端就可以使用一个 while 循环来访问此列表了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyList</span>();</span><br><span class="line">        <span class="comment">// 输出：abc</span></span><br><span class="line">        <span class="keyword">while</span> (list.hasNext()) &#123;</span><br><span class="line">            System.out.print(list.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有给外部类暴露 data 成员变量，所以我们可以保证数据是安全的。</p><p>但这样的实现还有一个问题：当遍历完成后，hasNext() 方法就会一直返回 false，无法再一次遍历了，所以我们必须在一个合适的地方把 index 重置成 0。</p><p>在哪里重置比较合适呢？实际上，使用 next() 方法和 hasNext() 方法来遍历列表是一个完全通用的方法，我们可以为其创建一个接口，取名为 Iterator，Iterator 的意思是迭代器，迭代的意思是重复反馈，这里是指我们依次遍历列表中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 MyList 类中，每次遍历时生成一个迭代器，将 index 变量放到迭代器中。由于每个迭代器都是新生成的，所以每次遍历时的 index 自然也就被重置成 0 了。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次生成一个新的迭代器，用于遍历列表</span></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; data.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端访问此列表的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyList</span>();</span><br><span class="line">        <span class="comment">// 获取迭代器，用于遍历列表</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="comment">// 输出：abc</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是迭代器模式，《设计模式》一书中将其定义如下：</p><blockquote><p>迭代器模式（Iterator Pattern）：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</p></blockquote><p>迭代器模式的核心就在于定义出 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的。</p><p>事实上，Java 已经为我们内置了 Iterator 接口，源码中使用了泛型使得此接口更加的通用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，本例中使用的迭代器模式是仿照 ArrayList 的源码实现的，ArrayList 源码中使用迭代器模式的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">        <span class="type">int</span> cursor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时常用的 for-each 循环，也是迭代器模式的一种应用。在 Java 中，只要实现了 Iterable 接口的类，都被视为可迭代访问的。Iterable 中的核心方法只有一个，也就是刚才我们在 MyList 类中实现过的用于获取迭代器的 iterator() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我们将 MyList 类修改为继承此接口，便可以使用 for-each 来迭代访问其中的数据了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;String&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 每次生成一个新的迭代器，用于遍历列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; data.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data.get(index++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端使用 for-each 访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyList</span>();</span><br><span class="line">        <span class="comment">// 输出：abc</span></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            System.out.print(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是迭代器模式。基本上每种语言都会在语言层面为所有列表提供迭代器，我们只需要直接拿来用即可，这是一个比较简单又很常用的设计模式。</p><p>迭代器模式一个典型应用：读取文件或者数据库</p><h3 id="中介者模式-Mediator"><a href="#中介者模式-Mediator" class="headerlink" title="中介者模式 Mediator"></a>中介者模式 Mediator</h3><p>顾名思义，中介这个名字对我们来说实在太熟悉了。平时走在上班路上就会经常见到各种房产中介，他们的工作就是使得买家与卖家不需要直接打交道，只需要分别与中介打交道，就可以完成交易，用计算机术语来说就是减少了耦合度。</p><p>当类与类之间的关系呈现网状时，引入一个中介者，可以使类与类之间的关系变成星形。将每个类与多个类的耦合关系简化为每个类与中介者的耦合关系。</p><p>举个例子，在我们打麻将时，每两个人之间都可能存在输赢关系。如果每笔交易都由输家直接发给赢家，就会出现一种网状耦合关系。</p><p><img src="https://pic.leetcode-cn.com/1648087004-rWwiTq-image.png" alt="image"></p><p>我们用程序来模拟一下这个过程。</p><p>玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="comment">// 初始资金 100 元</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">win</span><span class="params">(Player player, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 输钱的人扣减相应的钱</span></span><br><span class="line">        player.money -= money;</span><br><span class="line">        <span class="comment">// 自己的余额增加</span></span><br><span class="line">        <span class="built_in">this</span>.money += money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类中有一个 money 变量，表示自己的余额。当自己赢了某位玩家的钱时，调用 win 方法修改输钱的人和自己的余额。</p><p>需要注意的是，我们不需要输钱的方法，因为在 win 方法中，已经将输钱的人对应余额扣除了。</p><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="comment">// player1 赢了 player3 5 元</span></span><br><span class="line">        player1.win(player3, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// player2 赢了 player1 10 元</span></span><br><span class="line">        player2.win(player1, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// player2 赢了 player4 10 元</span></span><br><span class="line">        player2.win(player4, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// player4 赢了 player3 7 元</span></span><br><span class="line">        player4.win(player3, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：四人剩余的钱：105,120,88,97</span></span><br><span class="line">        System.out.println(<span class="string">&quot;四人剩余的钱：&quot;</span> + player1.money + <span class="string">&quot;,&quot;</span> + player2.money + <span class="string">&quot;,&quot;</span> + player3.money + <span class="string">&quot;,&quot;</span> + player4.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端中，每两位玩家需要进行交易时，都会增加程序耦合度，相当于每位玩家都需要和其他所有玩家打交道，这是一种不好的做法。</p><p>此时，我们可以引入一个中介类 —— 微信群，只要输家将自己输的钱发到微信群里，赢家从微信群中领取对应金额即可。网状的耦合结构就变成了星形结构：</p><p><img src="https://pic.leetcode-cn.com/1648087038-ZnGMul-image.png" alt="image"></p><p>此时，微信群就充当了一个中介者的角色，由它来负责与所有人进行交易，每个玩家只需要与微信群打交道即可。</p><p>微信群类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Group</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此类中只有一个 money 变量表示群内的余额。</p><p>玩家类修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> Group group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(Group group)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.group = group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">// 输了钱将钱发到群里 或 在群里领取自己赢的钱</span></span><br><span class="line">        group.money += money;</span><br><span class="line">        <span class="comment">// 自己的余额改变</span></span><br><span class="line">        <span class="built_in">this</span>.money += money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>玩家类中新增了一个构造方法，在构造方法中将中介者传进来。每当自己有输赢时，只需要将钱发到群里或者在群里领取自己赢的钱，然后修改自己的余额即可。</p><p>客户端代码对应修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Group</span>();</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(group);</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(group);</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(group);</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(group);</span><br><span class="line">        <span class="comment">// player1 赢了 5 元</span></span><br><span class="line">        player1.change(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// player2 赢了 20 元</span></span><br><span class="line">        player2.change(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// player3 输了 12 元</span></span><br><span class="line">        player3.change(-<span class="number">12</span>);</span><br><span class="line">        <span class="comment">// player4 输了 3 元</span></span><br><span class="line">        player4.change(-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：四人剩余的钱：105,120,88,97</span></span><br><span class="line">        System.out.println(<span class="string">&quot;四人剩余的钱：&quot;</span> + player1.money + <span class="string">&quot;,&quot;</span> + player2.money + <span class="string">&quot;,&quot;</span> + player3.money + <span class="string">&quot;,&quot;</span> + player4.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，通过引入中介者，客户端的代码变得更加清晰了。大家不需要再互相打交道，所有交易通过中介者完成即可。</p><p>事实上，这段代码还存在一点不足。因为我们忽略了一个前提：微信群里的钱不可以为负数。也就是说，输家必须先将钱发到微信群内，赢家才能去微信群里领钱。这个功能可以用我们在 Java 多线程王国奇遇记 中学到的 wait&#x2F;notify 机制完成，与中介者模式无关，故这里不再给出相关代码，感兴趣的读者可以自行实现。</p><p>总而言之，中介者模式就是用于将类与类之间的多对多关系简化成多对一、一对多关系的设计模式，它的定义如下：</p><blockquote><p>中介者模式（Mediator Pattern）：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p></blockquote><p>中介者模式的缺点也很明显：由于它将所有的职责都移到了中介者类中，也就是说中介类需要处理所有类之间的协调工作，这可能会使中介者演变成一个超级类。所以使用中介者模式时需要权衡利弊。</p><h3 id="备忘录模式-Memento"><a href="#备忘录模式-Memento" class="headerlink" title="备忘录模式 Memento"></a>备忘录模式 Memento</h3><p>备忘录模式最常见的实现就是游戏中的存档、读档功能，通过存档、读档，使得我们可以随时恢复到之前的状态。</p><p>当我们在玩游戏时，打大 Boss 之前，通常会将自己的游戏进度存档保存，以保证自己打不过 Boss 的话，还能重新读档恢复状态。</p><p>玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="comment">// 生命值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">life</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 魔法值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">magic</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fightBoss</span><span class="params">()</span> &#123;</span><br><span class="line">        life -= <span class="number">100</span>;</span><br><span class="line">        magic -= <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (life &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;壮烈牺牲&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLife</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> life;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLife</span><span class="params">(<span class="type">int</span> life)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.life = life;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMagic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> magic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMagic</span><span class="params">(<span class="type">int</span> magic)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.magic = magic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为玩家定义了两个属性：生命值和魔法值。其中有一个 fightBoss() 方法，每次打 Boss 都会扣减 100 点体力、100 点魔法值。如果生命值小于等于 0，则提示用户已“壮烈牺牲”。</p><p>客户端实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedLife</span> <span class="operator">=</span> player.getLife();</span><br><span class="line">        <span class="type">int</span> <span class="variable">savedMagic</span> <span class="operator">=</span> player.getMagic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打 Boss，打不过，壮烈牺牲</span></span><br><span class="line">        player.fightBoss();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档，恢复到打 Boss 之前的状态</span></span><br><span class="line">        player.setLife(savedLife);</span><br><span class="line">        player.setMagic(savedMagic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端中，我们在 fightBoss() 之前，先去存档，把自己当前的生命值和魔法值保存起来。打完 Boss 发现自己牺牲之后，再回去读档，将自己恢复到打 Boss 之前的状态。</p><p>这就是备忘录模式……吗？不完全是，事情并没有这么简单。</p><p>还记得我们在 原型模式 中，买的那杯和周杰伦一模一样的奶茶吗？开始时，为了克隆一杯奶茶，我们将奶茶的各个属性分别赋值成和周杰伦买的那杯奶茶一样。但这样存在一个弊端：我们不可能为一千个粉丝写一千份挨个赋值操作。所以最终我们在奶茶类内部实现了 Cloneable 接口，定义了 clone() 方法，来实现一行代码拷贝所有属性。</p><p>备忘录模式也应该采取类似的做法。我们不应该采用将单个属性挨个存取的方式来进行读档、存档。更好的做法是将存档、读档交给需要存档的类内部去实现。</p><p>新建备忘录类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="type">int</span> life;</span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line"></span><br><span class="line">    Memento(<span class="type">int</span> life, <span class="type">int</span> magic) &#123;</span><br><span class="line">        <span class="built_in">this</span>.life = life;</span><br><span class="line">        <span class="built_in">this</span>.magic = magic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此类中，管理需要存档的数据。</p><p>玩家类中，通过备忘录类实现存档、读档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存档</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(life, magic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读档</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreState</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.life = memento.life;</span><br><span class="line">        <span class="built_in">this</span>.magic = memento.magic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类对应修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Player</span> <span class="variable">player</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>();</span><br><span class="line">        <span class="comment">// 存档</span></span><br><span class="line">        <span class="type">Memento</span> <span class="variable">memento</span> <span class="operator">=</span> player.saveState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打 Boss，打不过，壮烈牺牲</span></span><br><span class="line">        player.fightBoss();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读档</span></span><br><span class="line">        player.restoreState(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才是完整的备忘录模式。这个设计模式的定义如下：</p><blockquote><p>备忘录模式：在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态。</p></blockquote><p>备忘录模式的优点是：</p><ul><li>给用户提供了一种可以恢复状态的机制，使用户能够比较方便的回到某个历史的状态</li><li>实现了信息的封装，使得用户不需要关心状态的保存细节</li></ul><p>缺点是：</p><ul><li>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li></ul><p>总体而言，备忘录模式是利大于弊的，所以许多程序都为用户提供了备份方案。比如 IDE 中，用户可以将自己的设置导出成 zip，当需要恢复设置时，再将导出的 zip 文件导入即可。这个功能内部的原理就是备忘录模式。</p><h4 id="备忘录模式的主要角色"><a href="#备忘录模式的主要角色" class="headerlink" title="备忘录模式的主要角色"></a>备忘录模式的主要角色</h4><p>1.发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。<br>2.备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。<br>3.管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p><h3 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式 Observer"></a>观察者模式 Observer</h3><p>观察者模式非常常见，近年来逐渐流行的响应式编程就是观察者模式的应用之一。观察者模式的思想就是一个对象发生一个事件后，逐一通知监听着这个对象的监听者，监听者可以对这个事件马上做出响应。</p><p>生活中有很多观察者模式的例子，比如我们平时的开关灯。当我们打开灯的开关时，灯马上亮了；当我们关闭灯的开关时，灯马上熄了。这个过程中，灯就对我们控制开关的事件做出了响应，这就是一个最简单的一对一观察者模式。当力扣公众号发表一篇文章，所有关注了公众号的读者立即收到了文章，这个过程中所有关注了公众号的微信客户端就对公众号发表文章的事件做出了响应，这就是一个典型的一对多观察者模式。</p><p>再举个例子，比如警察一直观察着张三的一举一动，只要张三有什么违法行为，警察马上行动，抓捕张三。</p><p>这个过程中：</p><ul><li>警察称之为观察者（Observer）</li><li>张三称之为被观察者（Observable，可观察的）</li><li>警察观察张三的这个行为称之为订阅（subscribe），或者注册（register）</li><li>张三违法后，警察抓捕张三的行动称之为响应（update）</li></ul><p>众所周知，张三坏事做尽，是一个老法外狂徒了，所以不止一个警察会盯着张三，也就是说一个被观察者可以有多个观察者。当被观察者有事件发生时，所有观察者都能收到通知并响应。观察者模式主要处理的是一种一对多的依赖关系。它的定义如下：</p><blockquote><p>观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>我们使用程序来模拟一下这个过程。</p><p>观察者的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中只有一个 update 方法，用于对被观察者发出的事件做出响应。</p><p>被观察者的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被观察者中维护了一个观察者列表，提供了三个方法：</p><ul><li>addObserver：将 observer 对象添加到观察者列表中</li><li>removeObserver：将 observer 对象从观察者列表中移除</li><li>notifyObservers：通知所有观察者有事件发生，具体实现是调用所有观察者的 update 方法</li></ul><p>有了这两个基类，我们就可以定义出具体的罪犯与警察类。</p><p>警察属于观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PoliceObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察收到消息，罪犯在&quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>警察实现了观察者接口，当警察收到事件后，做出响应，这里的响应就是简单的打印了一条日志。</p><p>罪犯属于被观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CriminalObservable</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">crime</span><span class="params">(String event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;罪犯正在&quot;</span> + event);</span><br><span class="line">        notifyObservers(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>罪犯继承自被观察者类，当罪犯有犯罪行为时，所有的观察者都会收到通知。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CriminalObservable</span> <span class="variable">zhangSan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CriminalObservable</span>();</span><br><span class="line">        <span class="type">PoliceObserver</span> <span class="variable">police1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoliceObserver</span>();</span><br><span class="line">        <span class="type">PoliceObserver</span> <span class="variable">police2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoliceObserver</span>();</span><br><span class="line">        <span class="type">PoliceObserver</span> <span class="variable">police3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PoliceObserver</span>();</span><br><span class="line">        zhangSan.addObserver(police1);</span><br><span class="line">        zhangSan.addObserver(police2);</span><br><span class="line">        zhangSan.addObserver(police3);</span><br><span class="line">        zhangSan.crime(<span class="string">&quot;放狗咬人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端中，我们 new 了一个张三，为其添加了三个观察者：police1，police2，police3。</p><p>运行程序，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">罪犯正在放狗咬人</span><br><span class="line">警察收到消息，罪犯在放狗咬人</span><br><span class="line">警察收到消息，罪犯在放狗咬人</span><br><span class="line">警察收到消息，罪犯在放狗咬人</span><br></pre></td></tr></table></figure><p>可以看到，所有的观察者都被通知到了。当某个观察者不需要继续观察时，调用 removeObserver 即可。</p><p>这就是观察者模式，它并不复杂，由于生活中一对多的关系非常常见，所以观察者模式应用广泛。</p><h4 id="Java-源码中的观察者模式"><a href="#Java-源码中的观察者模式" class="headerlink" title="Java 源码中的观察者模式"></a>Java 源码中的观察者模式</h4><p>实际上，Java 已经为我们提供了的 Observable 类和 Observer 类，我们在用到观察者模式时，无需自己创建这两个基类，我们来看一下 Java 中提供的源码：</p><p>java.util.Observer 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer 类和我们上例中的定义基本一致，都是只有一个 update 方法用于响应 Observable 的事件。区别有两点：</p><ul><li>update 方法将 Observable 对象也提供给了 Observer</li><li>update 方法中的参数类型变成了 Object</li></ul><p>这两点区别都是为了保证此 Observer 的适用范围更广。</p><p>java.util.Observable 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Observable</span><span class="params">()</span> &#123;</span><br><span class="line">        obs = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(java.util.Observer o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(java.util.Observer o)</span> &#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasChanged())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrLocal.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            ((Observer) arrLocal[i]).update(<span class="built_in">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deleteObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">clearChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        changed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">hasChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">countObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observable 类和我们上例中的定义也是类似的，区别在于：</p><ul><li><p>用于保存观察者列表的容器不是 ArrayList，而是 Vector</p></li><li><p>添加了一个 changed 字段，以及 setChanged 和 clearChanged 方法。分析可知，当 changed 字段为 true 时，才会通知所有观察者，否则不通知观察者。所以当我们使用此类时，想要触发 notifyObservers 方法，必须先调用 setChanged 方法。这个字段相当于在被观察者和观察者之间添加了一个可控制的阀门。</p></li><li><p>提供了 countObservers 方法，用于计算观察者数量</p></li><li><p>添加了一些 synchronized 关键字保证线程安全</p></li></ul><p>这些区别仍然是为了让 Observable 的适用范围更广，核心思想与本文介绍的都是一致的。</p><h3 id="状态模式-State"><a href="#状态模式-State" class="headerlink" title="状态模式 State"></a>状态模式 State</h3><p>状态模式（State Pattern）：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p><p>通俗地说，状态模式就是一个关于多态的设计模式。</p><p>如果一个对象有多种状态，并且每种状态下的行为不同，一般的做法是在这个对象的各个行为中添加 if-else 或者 switch-case 语句。但更好的做法是为每种状态创建一个状态对象，使用状态对象替换掉这些条件判断语句，使得状态控制更加灵活，扩展性也更好。</p><p>举个例子，力扣的用户有两种状态：普通用户和 PLUS 会员。PLUS 会员有非常多的专享功能，其中“模拟面试”功能非常有特色，我们便以此为例。</p><ul><li>当普通用户点击模拟面试功能时，提示用户：模拟面试是 Plus 会员专享功能；</li><li>当 PLUS 会员点击模拟面试功能时，开始一场模拟面试。</li></ul><p>先来看看不使用状态模式的写法，看出它的缺点后，我们再用状态模式来重构代码。</p><p>首先定义一个用户状态枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    NORMAL, PLUS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NORMAL 代表普通用户状态，PLUS 代表 PLUS 会员状态。</p><p>用户的功能接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mockInterview</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中我们只定义了一个模拟面试的方法，实际开发中这里可能会有许许多多的方法。</p><p>用户状态切换接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISwitchState</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">purchasePlus</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口中定义了两个方法：purchasePlus 方法表示购买 Plus 会员，用户状态变为 PLUS 会员状态，expire 方法表示会员过期，用户状态变为普通用户状态。</p><p>力扣用户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">IUser</span>, ISwitchState &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> State.NORMAL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mockInterview</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == State.PLUS) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始模拟面试&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;模拟面试是 Plus 会员专享功能&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">purchasePlus</span><span class="params">()</span> &#123;</span><br><span class="line">        state = State.PLUS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">()</span> &#123;</span><br><span class="line">        state = State.NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户类实现了 IUser 接口，IUser 接口中的每个功能都需要判断用户是否为 Plus 会员，也就是说每个方法中都有<code>if (state == State.PLUS) &#123;&#125; else &#123;&#125;</code>语句，如果状态不止两种，还需要用上 <code>switch-case</code> 语句来判断状态，这就是不使用状态模式的弊端：</p><ul><li>判断用户状态会产生大量的分支判断语句，导致代码冗长；</li><li>当状态有增加或减少时，需要改动多个地方，违反开闭原则。</li></ul><p>在《代码整洁之道》、《重构》两本书中都提到：应使用多态取代条件表达式。接下来我们就利用多态特性重构这份代码。</p><p>为每个状态新建一个状态类，普通用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Normal</span> <span class="keyword">implements</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mockInterview</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟面试是 Plus 会员专享功能&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PLUS 会员：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plus</span> <span class="keyword">implements</span> <span class="title class_">IUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mockInterview</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始模拟面试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个状态类都实现了 IUser 接口，在接口方法中实现自己特定的行为。</p><p>用户类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">IUser</span>, ISwitchState &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">IUser</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Normal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mockInterview</span><span class="params">()</span> &#123;</span><br><span class="line">        state.mockInterview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">purchasePlus</span><span class="params">()</span> &#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">Plus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">()</span> &#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">Normal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，丑陋的状态判断语句消失了，无论 IUser 接口中有多少方法，User 类都只需要调用状态类的对应方法即可。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用户初始状态为普通用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">// 输出：模拟面试是 Plus 会员专享功能</span></span><br><span class="line">        user.mockInterview();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户购买 Plus 会员，状态改变</span></span><br><span class="line">        user.purchasePlus();</span><br><span class="line">        <span class="comment">// 输出：开始模拟面试</span></span><br><span class="line">        user.mockInterview();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Plus 会员过期，变成普通用户，状态改变</span></span><br><span class="line">        user.expire();</span><br><span class="line">        <span class="comment">// 输出：模拟面试是 Plus 会员专享功能</span></span><br><span class="line">        user.mockInterview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用户状态改变后，行为也随着改变了，这就是状态模式定义的由来。</p><p>它的优点是：将与特定状态相关的行为封装到一个状态对象中，使用多态代替 if-else 或者 switch-case 状态判断。</p><p>缺点是：必然导致类增加，这也是使用多态不可避免的缺点。</p><h3 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式 Strategy"></a>策略模式 Strategy</h3><p>策略模式用一个成语就可以概括 —— 殊途同归。当我们做同一件事有多种方法时，就可以将每种方法封装起来，在不同的场景选择不同的策略，调用不同的方法。</p><blockquote><p>策略模式（Strategy Pattern）：定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p></blockquote><p>我们以排序算法为例。排序算法有许多种，如冒泡排序、选择排序、插入排序，算法不同但目的相同，我们可以将其定义为不同的策略，让用户自由选择采用哪种策略完成排序。</p><p>首先定义排序算法接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ISort</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中只有一个 sort 方法，传入一个整型数组进行排序，所有的排序算法都实现此接口。</p><p>冒泡排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">ISort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] + arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>] - arr[j];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] - arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SelectionSort</span> <span class="keyword">implements</span> <span class="title class_">ISort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> minIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 记录最小值的下标</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小元素交换至首位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">插入排序：</span><br><span class="line">```Java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InsertSort</span> <span class="keyword">implements</span> <span class="title class_">ISort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 从第二个数开始，往前插入数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span></span><br><span class="line">            <span class="comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = currentNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三种都是基本的排序算法，就不再详细介绍了。接下来我们需要创建一个环境类，将每种算法都作为一种策略封装起来，客户端将通过此环境类选择不同的算法完成排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sort</span> <span class="keyword">implements</span> <span class="title class_">ISort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ISort sort;</span><br><span class="line"></span><br><span class="line">    Sort(ISort sort) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端通过此方法设置不同的策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSort</span><span class="params">(ISort sort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此类中，我们保存了一个 ISort 接口的实现对象，在构造方法中，将其初始值传递进来，排序时调用此对象的 sort 方法即可完成排序。</p><p>我们也可以为 ISort 对象设定一个默认值，客户端如果没有特殊需求，直接使用默认的排序策略即可。</p><p>setSort 方法就是用来选择不同的排序策略的，客户端调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(<span class="keyword">new</span> <span class="title class_">BubbleSort</span>());</span><br><span class="line">        <span class="comment">// 这里可以选择不同的策略完成排序</span></span><br><span class="line">        <span class="comment">// sort.setSort(new InsertSort());</span></span><br><span class="line">        <span class="comment">// sort.setSort(new SelectionSort());</span></span><br><span class="line">        sort.sort(arr);</span><br><span class="line">        <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是基本的策略模式，通过策略模式我们可以为同一个需求选择不同的算法，以应付不同的场景。比如我们知道冒泡排序和插入排序是稳定的，而选择排序是不稳定的，当我们需要保证排序的稳定性就可以采用冒泡排序和插入排序，不需要保证排序的稳定性时可以采用选择排序。</p><p>策略模式还可以应用在图片缓存中，当我们开发一个图片缓存框架时，可以通过提供不同的策略类，让用户根据需要选择缓存解码后的图片、缓存未经解码的数据或者不缓存任何内容。在一些开源的图片加载框架中，就采用了这种设计。</p><p>策略模式扩展性和灵活性都相当不错。当有新的策略时，只需要增加一个策略类；要修改某个策略时，只需要更改具体的策略类，其他地方的代码都无需做任何调整。</p><p>但现在这样的策略模式还有一个弊端，如本系列第一篇文章中的工厂模式所言：每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。</p><p>所以使用策略模式时，更好的做法是与工厂模式结合，将不同的策略对象封装到工厂类中，用户只需要传递不同的策略类型，然后从工厂中拿到对应的策略对象即可。接下来我们就来一起实现这种工厂模式与策略模式结合的混合模式。</p><p>创建排序策略枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    BUBBLE_SORT,</span><br><span class="line">    SELECTION_SORT,</span><br><span class="line">    INSERT_SORT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Sort 类中使用简单工厂模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sort</span> <span class="keyword">implements</span> <span class="title class_">ISort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ISort sort;</span><br><span class="line"></span><br><span class="line">    Sort(SortStrategy strategy) &#123;</span><br><span class="line">        setStrategy(strategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端通过此方法设置不同的策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">            <span class="keyword">case</span> BUBBLE_SORT:</span><br><span class="line">                sort = <span class="keyword">new</span> <span class="title class_">BubbleSort</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SELECTION_SORT:</span><br><span class="line">                sort = <span class="keyword">new</span> <span class="title class_">SelectionSort</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> INSERT_SORT:</span><br><span class="line">                sort = <span class="keyword">new</span> <span class="title class_">InsertSort</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;There&#x27;s no such strategy yet.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用简单工厂模式，我们将创建策略类的职责移到了 Sort 类中。如此一来，客户端只需要和 Sort 类打交道，通过 SortStrategy 选择不同的排序策略即可。</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">Sort</span> <span class="variable">sort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sort</span>(SortStrategy.BUBBLE_SORT);</span><br><span class="line">        <span class="comment">// 可以通过选择不同的策略完成排序</span></span><br><span class="line">        <span class="comment">// sort.setStrategy(SortStrategy.SELECTION_SORT);</span></span><br><span class="line">        <span class="comment">// sort.setStrategy(SortStrategy.INSERT_SORT);</span></span><br><span class="line">        sort.sort(arr);</span><br><span class="line">        <span class="comment">// 输出 [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过简单工厂模式与策略模式的结合，我们最大化地减轻了客户端的压力。这是我们第一次用到混合模式，但实际开发中会遇到非常多的混合模式，学习设计模式的过程只能帮助我们各个击破，真正融会贯通还需要在实际开发中多加操练。</p><p>需要注意的是，策略模式与状态模式非常类似，甚至他们的 UML 类图都是一模一样的。两者都是采用一个变量来控制程序的行为。策略模式通过不同的策略执行不同的行为，状态模式通过不同的状态值执行不同的行为。两者的代码很类似，他们的区别主要在于程序的目的不同。</p><ul><li><p>使用策略模式时，程序只需选择一种策略就可以完成某件事。也就是说每个策略类都是完整的，都能独立完成这件事情，如上文所言，强调的是殊途同归。</p></li><li><p>使用状态模式时，程序需要在不同的状态下不断切换才能完成某件事，每个状态类只能完成这件事的一部分，需要所有的状态类组合起来才能完整的完成这件事，强调的是随势而动。</p></li></ul><p>现在很多程序中的多数据库支持，也是策略模式的一种应用。</p><h3 id="模板方法模式-Template-method"><a href="#模板方法模式-Template-method" class="headerlink" title="模板方法模式 Template method"></a>模板方法模式 Template method</h3><blockquote><p>模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>通俗地说，模板方法模式就是一个关于继承的设计模式。</p><p>每一个被继承的父类都可以认为是一个模板，它的某些步骤是稳定的，某些步骤被延迟到子类中实现。</p><p>这和我们平时生活中使用的模板也是一样的。比如我们请假时，通常会给我们一份请假条模板，内容是已经写好的，只需要填写自己的姓名和日期即可。</p><blockquote><p>本人 ____ 因 ____ 需请假 ___ 天，望批准！</p></blockquote><p>这个模板用代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;本人&quot;</span>);</span><br><span class="line">        System.out.print(name());</span><br><span class="line">        System.out.print(<span class="string">&quot;因&quot;</span>);</span><br><span class="line">        System.out.print(reason());</span><br><span class="line">        System.out.print(<span class="string">&quot;需请假&quot;</span>);</span><br><span class="line">        System.out.print(duration());</span><br><span class="line">        System.out.print(<span class="string">&quot;天，望批准&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">reason</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">duration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这份模板中，所有的其他步骤（固定字符串）都是稳定的，只有姓名、请假原因、请假时长是抽象的，需要延迟到子类去实现。</p><p>继承此模板，实现具体步骤的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLeaveRequest</span> <span class="keyword">extends</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;阿笠&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">reason</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;参加力扣周赛&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">duration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0.5&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出：本人阿笠因参加力扣周赛需请假0.5天，望批准</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MyLeaveRequest</span>().request();</span><br></pre></td></tr></table></figure><p>在使用模板方法模式时，我们可以为不同的模板方法设置不同的控制权限：</p><ul><li>如果不希望子类覆写模板中的某个方法，使用 final 修饰此方法；</li><li>如果要求子类必须覆写模板中的某个方法，使用 abstract 修饰此方法；</li><li>如果没有特殊要求，可使用 protected 或 public 修饰此方法，子类可根据实际情况考虑是否覆写。</li></ul><h3 id="访问者模式-Visitor"><a href="#访问者模式-Visitor" class="headerlink" title="访问者模式 Visitor"></a>访问者模式 Visitor</h3><p>许多设计模式的书中都说访问者模式是最复杂的设计模式，实际上只要我们对它抽丝剥茧，就会发现访问者模式的核心思想并不复杂。</p><p>以我们去吃自助餐为例，每个人喜欢的食物是不一样的，比如 Aurora 喜欢吃龙虾和西瓜，Kevin 喜欢吃牛排和香蕉，餐厅不可能单独为某一位顾客专门准备食物。所以餐厅的做法是将所有的食物都准备好，顾客按照需求自由取用。此时，顾客和餐厅之间就形成了一种访问者与被访问者的关系。</p><p>准备好各种食物的餐厅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lobster</span> <span class="operator">=</span> <span class="string">&quot;lobster&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">watermelon</span> <span class="operator">=</span> <span class="string">&quot;watermelon&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">steak</span> <span class="operator">=</span> <span class="string">&quot;steak&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">banana</span> <span class="operator">=</span> <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在餐厅类中，我们提供了四种食物：龙虾、西瓜、牛排、香蕉。</p><p>为顾客提供的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseLobster</span><span class="params">(String lobster)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseWatermelon</span><span class="params">(String watermelon)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseSteak</span><span class="params">(String steak)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseBanana</span><span class="params">(String banana)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中提供了四个方法， 让顾客依次选择每种食物。</p><p>在餐厅中提供接收访问者的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">welcome</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.chooseLobster(lobster);</span><br><span class="line">        visitor.chooseWatermelon(watermelon);</span><br><span class="line">        visitor.chooseSteak(steak);</span><br><span class="line">        visitor.chooseBanana(banana);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 welcome 方法中，我们将食物依次传递给访问者对应的访问方法。这时候，顾客如果想要访问餐厅选择自己喜欢的食物，只需要实现 IVisitor 接口即可。</p><p>比如顾客 Aurora 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aurora</span> <span class="keyword">implements</span> <span class="title class_">IVisitor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseLobster</span><span class="params">(String lobster)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora gets a &quot;</span> + lobster);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseWatermelon</span><span class="params">(String watermelon)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora gets a &quot;</span> + watermelon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseSteak</span><span class="params">(String steak)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora doesn&#x27;t like &quot;</span> + steak);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseBanana</span><span class="params">(String banana)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora doesn&#x27;t like &quot;</span> + banana);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此类中，顾客根据自己的喜好依次选择每种食物。</p><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Restaurant</span> <span class="variable">restaurant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">        <span class="type">IVisitor</span> <span class="variable">Aurora</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aurora</span>();</span><br><span class="line">        restaurant.welcome(Aurora);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aurora gets a lobster</span><br><span class="line">Aurora gets a watermelon</span><br><span class="line">Aurora doesn&#x27;t like steak</span><br><span class="line">Aurora doesn&#x27;t like banana</span><br></pre></td></tr></table></figure><p>可以看到，Aurora 对每一种食物做出了自己的选择，这就是一个最简单的访问者模式，它已经体现出了访问者模式的核心思想：将数据的结构和对数据的操作分离。</p><blockquote><p>访问者模式（Visitor Pattern）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>本例中，顾客需要选择餐厅的食物，由于每个顾客对食物的选择是不一样的，如果在餐厅类中处理每位顾客的需求，必然导致餐厅类职责过多。所以我们并没有在餐厅类中处理顾客的需求，而是将所有的食物通过接口暴露出去，欢迎每位顾客来访问。顾客只要实现访问者接口就能访问到所有的食物，然后在接口方法中做出自己的选择。</p><p>相信这个例子还是非常简单直观的，看起来访问者模式也不是那么难理解。那么为什么很多书中说访问者模式是最复杂的设计模式呢？原因就在于《设计模式》一书中给访问者模式设计了一个“双重分派”的机制，而 Java 只支持单分派，用单分派语言强行模拟出双重分派才导致了访问者模式看起来比较复杂。要理解这一点，我们先来了解一下何谓单分派、何谓双重分派。</p><h4 id="单分派与双重分派"><a href="#单分派与双重分派" class="headerlink" title="单分派与双重分派"></a>单分派与双重分派</h4><p>先看一段代码：</p><p>Food 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;food&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watermelon 类，继承自 Food 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watermelon</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;watermelon&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Watermelon 类中，我们重写了 name() 方法。</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watermelon</span>();</span><br><span class="line">        System.out.println(food.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一下，在客户端中，我们 new 出了一个 Watermelon 对象，但他的声明类型是 Food，当我们调用此对象的 name 方法时，会输出 “food” 还是 “watermelon” 呢？</p><p>了解过 Java 多态特性的同学都知道，这里肯定是输出 “watermelon” ，因为 Java 调用重写方法时，会根据运行时的具体类型来确定调用哪个方法。</p><p>再来看一段测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watermelon</span>();</span><br><span class="line">        eat(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Watermelon watermelon)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat watermelon&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们仍然 new 出了一个 Watermelon 对象，他的声明类型是 Food，在客户端中有 eat(Food food) 和 eat(Watermelon watermelon) 两个重载方法，这段代码会调用哪一个方法呢？</p><p>我们运行这段代码会发现输出的是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eat food</span><br></pre></td></tr></table></figure><p>这是由于 Java 在调用重载方法时，只会根据方法签名中声明的参数类型来判断调用哪个方法，不会去判断参数运行时的具体类型是什么。</p><p>从这两个例子中，我们可以看出 Java 对重写方法和重载方法的调用方式是不同的。</p><ul><li>调用重写方法时，与对象的运行时类型有关；</li><li>调用重载方法时，只与方法签名中声明的参数类型有关，与对象运行时的具体类型无关。</li></ul><p>了解了重写方法和重载方法调用方式的区别之后，我们将其综合起来就能理解何谓双重分派了。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Watermelon</span>();</span><br><span class="line">        eat(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Food food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat food: &quot;</span> + food.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(Watermelon watermelon)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat watermelon&quot;</span> + watermelon.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段测试代码中，仍然是 new 出了一个 Watermelon 对象，它的声明类型为 Food。运行 test() 函数，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eat food: watermelon</span><br></pre></td></tr></table></figure><p>在面向对象的编程语言中，我们将方法调用称之为分派，这段测试代码运行时，经过了两次分派：</p><ul><li><p>调用重载方法：选择调用 <code>eat(Food food)</code> 还是 <code>eat(Watermelon watermelon)</code> 。虽然这里传入的这个参数实际类型是 <code>Watermelon</code>，但这里会调用 <code>eat(Food food)</code> ，这是由于调用哪个重载方法是在编译期就确定了的，也称之为静态分派。</p></li><li><p>调用重写方法：选择调用 <code>Food</code> 的 <code>name</code> 方法还是 <code>Watermelon</code> 的 <code>name</code> 方法。这里会根据参数运行时的实际类型，调用 <code>Watermelon</code> 的 <code>name</code> 方法，称之为动态分派。</p></li></ul><p>单分派、双重分派的定义如下：</p><blockquote><p>方法的接收者和方法的参数统称为方法的宗量。 根据分派基于多少个宗量，可以将分派分为单分派和多分派。单分派是指根据一个宗量就可以知道应该调用哪个方法，多分派是指需要根据多个宗量才能确定调用目标。</p></blockquote><p>这段定义可能不太好理解，通俗地讲，单分派和双重分派的区别就是：程序在选择重载方法和重写方法时，如果两种情况都是动态分派的，则称之为双重分派；如果其中一种情况是动态分派，另一种是静态分派，则称之为单分派。</p><p>说了这么多，这和我们的访问者模式有什么关系呢？首先我们要知道，架构的演进往往都是由复杂的业务驱动的，当程序需要更好的扩展性，更灵活的架构便诞生出来。</p><p>上例中的程序非常简单，但它无法处理某种食物有多个的情形。接下来我们就来修改一下程序，来应对每种食物有多个的场景。</p><h4 id="自助餐程序-2-0-版"><a href="#自助餐程序-2-0-版" class="headerlink" title="自助餐程序 2.0 版"></a>自助餐程序 2.0 版</h4><p>在上面的例子中，为了突出访问者模式的特点，我们将每种食物都简化为了 String 类型，实际开发中，每种食物都应该是一个单独的对象，统一继承自父类 Food：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承自 Food 的四种食物：</p><p>龙虾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lobster</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;lobster&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>西瓜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Watermelon</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;watermelon&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Steak</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;steak&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>香蕉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Banana</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四个子类中分别重写了 name 方法，返回自己的食物名。</p><p>IVisitor 接口对应修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Lobster lobster)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Watermelon watermelon)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Steak steak)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Banana banana)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种食物都继承自 Food，所以我们将接口中的方法名都修改为了 chooseFood。</p><p>餐厅类修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备当天的食物</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Food&gt; <span class="title function_">prepareFoods</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Food&gt; foods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 简单模拟，每种食物添加 10 份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Lobster</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Watermelon</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Steak</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Banana</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欢迎顾客来访</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">welcome</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当天的食物</span></span><br><span class="line">        List&lt;Food&gt; foods = prepareFoods();</span><br><span class="line">        <span class="comment">// 将食物依次提供给顾客选择</span></span><br><span class="line">        <span class="keyword">for</span> (Food food : foods) &#123;</span><br><span class="line">            <span class="comment">// 由于单分派机制，此处无法编译通过</span></span><br><span class="line">            visitor.chooseFood(food);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>餐厅类中新增了 prepareFoods 方法，在这个方法中，我们简单模拟了准备多个食物的过程，将每种食物添加了 10 份。在接收访问者的 welcome 方法中，遍历所有食物，分别提供给顾客。</p><p>看起来很美好，实际上，<code>visitor.chooseFood(food)</code> 这一行是无法编译通过的，原因就在于上一节中提到的单分派机制。虽然每种食物都继承自 Food 类，但由于接口中没有 chooseFood(Food food) 这个重载方法，所以这一行会报错 <code>&lt;font color=red&gt;&quot;Cannot resolve method chooseFood&quot;&lt;/font&gt;</code>。</p><p>试想，如果 Java 在调用重载方法时也采用动态分派，也就是根据参数的运行时类型选择对应的重载方法，这里遇到的问题就迎刃而解了，我们的访问者模式讲到这里也就可以结束了。</p><p>但由于 Java 是单分派语言，所以我们不得不想办法解决这个 bug，目的就是 <strong>使用单分派的 Java 语言模拟出双分派的效果，能够根据运行时的具体类型调用对应的重载方法</strong>。</p><p>我们很容易想到一种解决方式，采用 instanceOf 判断对象的具体子类型，再将父类强制转换为具体子类型，调用对应的接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 instanceOf 判断具体子类型，再强制向下转型</span></span><br><span class="line"><span class="keyword">if</span> (food <span class="keyword">instanceof</span> Lobster) visitor.chooseFood((Lobster) food);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (food <span class="keyword">instanceof</span> Watermelon) visitor.chooseFood((Watermelon) food);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (food <span class="keyword">instanceof</span> Steak) visitor.chooseFood((Steak) food);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (food <span class="keyword">instanceof</span> Banana) visitor.chooseFood((Banana) food);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported type of food.&quot;</span>);</span><br></pre></td></tr></table></figure><p>的确可行，在某些开源代码中便是这么做的，但这种强制转型的方式既冗长又不符合开闭原则，所以《设计模式》一书中给我们推荐了另一种做法。</p><p>首先在 Food 类中添加 accept(Visitor visitor) 抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Food 中添加 accept 方法，接收访问者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(IVisitor visitor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体子类中，实现此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lobster</span> <span class="keyword">extends</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;lobster&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        visitor.chooseFood(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这两步修改，餐厅类就可以将接收访问者的方法修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备当天的食物</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Food&gt; <span class="title function_">prepareFoods</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Food&gt; foods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 简单模拟，每种食物添加 10 份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Lobster</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Watermelon</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Steak</span>());</span><br><span class="line">            foods.add(<span class="keyword">new</span> <span class="title class_">Banana</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欢迎顾客来访</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">welcome</span><span class="params">(IVisitor visitor)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当天的食物</span></span><br><span class="line">        List&lt;Food&gt; foods = prepareFoods();</span><br><span class="line">        <span class="comment">// 将食物依次提供给顾客选择</span></span><br><span class="line">        <span class="keyword">for</span> (Food food : foods) &#123;</span><br><span class="line">            <span class="comment">// 由于重写方法是动态分派的，所以这里会调用具体子类的 accept 方法，</span></span><br><span class="line">            food.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这三步修改，我们将访问者来访的代码由：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitor.chooseFood(food);</span><br></pre></td></tr></table></figure><p>改成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">food.accept(visitor);</span><br></pre></td></tr></table></figure><p>这样我们就将重载方法模拟成了动态分派。这里的实现非常巧妙，由于 Java 调用重写方法时是动态分派的，所以 <code>food.accept(visitor)</code> 会调用具体子类的 accept 方法，在具体子类的 accept 方法中，调用 <code>visitor.chooseFood(this)</code>，由于这个 accept 方法是属于具体子类的，所以这里的 this 一定是指具体的子类型，不会产生歧义。</p><p>再深入分析一下：之前的代码中，调用 <code>visitor.chooseFood(food)</code> 这行代码时，由于重载方法不知道 Food 的具体子类型导致了编译失败，但实际上这时我们是可以拿到 Food 的具体子类型的。利用重写方法会动态分派的特性，我们在子类的重写方法中去调用这些重载的方法，使得重载方法使用起来也像是动态分派的一样。</p><p>顾客 Aurora 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aurora</span> <span class="keyword">implements</span> <span class="title class_">IVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Lobster lobster)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora gets a &quot;</span> + lobster.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Watermelon watermelon)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora gets a &quot;</span> + watermelon.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Steak steak)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora doesn&#x27;t like &quot;</span> + steak.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Banana banana)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Aurora doesn&#x27;t like &quot;</span> + banana.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客 Kevin 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kevin</span> <span class="keyword">implements</span> <span class="title class_">IVisitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Lobster lobster)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Kevin doesn&#x27;t like &quot;</span> + lobster.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Watermelon watermelon)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Kevin doesn&#x27;t like &quot;</span> + watermelon.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Steak steak)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Kevin gets a &quot;</span> + steak.name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chooseFood</span><span class="params">(Banana banana)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Kevin gets a &quot;</span> + banana.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Restaurant</span> <span class="variable">restaurant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Restaurant</span>();</span><br><span class="line">        <span class="type">IVisitor</span> <span class="variable">Aurora</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Aurora</span>();</span><br><span class="line">        <span class="type">IVisitor</span> <span class="variable">Kevin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kevin</span>();</span><br><span class="line">        restaurant.welcome(Aurora);</span><br><span class="line">        restaurant.welcome(Kevin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Aurora gets a lobster</span><br><span class="line">Aurora gets a watermelon</span><br><span class="line">Aurora doesn&#x27;t like steak</span><br><span class="line">Aurora doesn&#x27;t like banana</span><br><span class="line">... 输出 10 遍</span><br><span class="line">Kevin doesn&#x27;t like lobster</span><br><span class="line">Kevin doesn&#x27;t like watermelon</span><br><span class="line">Kevin gets a steak</span><br><span class="line">Kevin gets a banana</span><br><span class="line">... 输出 10 遍</span><br></pre></td></tr></table></figure><p>这就是访问者模式，它的核心思想其实非常简单，就是第一小节中体现的将数据的结构与对数据的操作分离。之所以说它复杂，主要在于大多数语言都是单分派语言，所以不得不模拟出一个双重分派，也就是 用重写方法的动态分派特性将重载方法也模拟成动态分派。</p><p>但模拟双重分派只是手段，不是目的。有的文章中说模拟双重分派是访问者模式的核心，还有的文章中说双分派语言不需要访问者模式，笔者认为这些说法都有点舍本逐末了。</p><h3 id="小结-Summary-2"><a href="#小结-Summary-2" class="headerlink" title="小结 Summary"></a>小结 Summary</h3><p>行为型模式重点关注类与类之间的交互与协作。如同在工作中，每个人的行为都可能影响到其他同事，同时每个人也会受到别人的影响。我们一边接收上级的指令，一边派发任务给下级，在这样的协作中完成一项项伟大的工作。程序在运行时，每个对象都不是孤立的，他们可以通过通信与协作完成种种复杂的功能。</p><ul><li>责任链模式：处理职责相同，程度不同的对象，使其在一条链上传递</li><li>命令模式：封装“方法调用”，将行为请求者和行为实现者解耦</li><li>解释器模式：定义自己的语法规则</li><li>迭代器模式：定义 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的</li><li>中介者模式：通过引入中介者，将网状耦合结构变成星型结构</li><li>备忘录模式：存储对象的状态，以便恢复</li><li>观察者模式：处理一对多的依赖关系，被观察的对象改变时，多个观察者都能收到通知</li><li>状态模式：关于多态的设计模式，每个状态类处理对象的一种状态</li><li>策略模式：殊途同归，用多种方法做同一件事</li><li>模板方法模式：关于继承的设计模式，父类是子类的模板</li><li>访问者模式：将数据的结构和对数据的操作分离</li></ul><h2 id="随堂小测"><a href="#随堂小测" class="headerlink" title="随堂小测"></a>随堂小测</h2><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><h4 id="1-面向对象的特点是什么？"><a href="#1-面向对象的特点是什么？" class="headerlink" title="1. 面向对象的特点是什么？"></a>1. 面向对象的特点是什么？</h4><p>可维护、可复用、可扩展、灵活性好。</p><h4 id="2-让面向对象保持结构良好的秘诀是什么？"><a href="#2-让面向对象保持结构良好的秘诀是什么？" class="headerlink" title="2. 让面向对象保持结构良好的秘诀是什么？"></a>2. 让面向对象保持结构良好的秘诀是什么？</h4><p>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。</p><h4 id="3-六大设计原则是什么？"><a href="#3-六大设计原则是什么？" class="headerlink" title="3. 六大设计原则是什么？"></a>3. 六大设计原则是什么？</h4><p>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则。</p><h4 id="4-什么是里氏替换原则？"><a href="#4-什么是里氏替换原则？" class="headerlink" title="4. 什么是里氏替换原则？"></a>4. 什么是里氏替换原则？</h4><p>子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</p><h4 id="5-工厂模式是用于达到什么目的的设计模式？"><a href="#5-工厂模式是用于达到什么目的的设计模式？" class="headerlink" title="5. 工厂模式是用于达到什么目的的设计模式？"></a>5. 工厂模式是用于达到什么目的的设计模式？</h4><p>封装对象。</p><h4 id="6-工厂模式有哪三种？"><a href="#6-工厂模式有哪三种？" class="headerlink" title="6. 工厂模式有哪三种？"></a>6. 工厂模式有哪三种？</h4><p>简单工厂模式、工厂方法模式、抽象工厂模式。</p><h4 id="7-工厂方法模式解决了简单工厂模式的哪两个弊端？"><a href="#7-工厂方法模式解决了简单工厂模式的哪两个弊端？" class="headerlink" title="7. 工厂方法模式解决了简单工厂模式的哪两个弊端？"></a>7. 工厂方法模式解决了简单工厂模式的哪两个弊端？</h4><p>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。<br>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</p><h4 id="8-抽象工厂模式是什么样的？"><a href="#8-抽象工厂模式是什么样的？" class="headerlink" title="8. 抽象工厂模式是什么样的？"></a>8. 抽象工厂模式是什么样的？</h4><p>在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p><h4 id="9-抽象工厂模式很好的发挥了哪些原则？"><a href="#9-抽象工厂模式很好的发挥了哪些原则？" class="headerlink" title="9. 抽象工厂模式很好的发挥了哪些原则？"></a>9. 抽象工厂模式很好的发挥了哪些原则？</h4><p>开闭原则、依赖倒置原则。</p><h4 id="10-抽象工厂模式的缺点是什么？"><a href="#10-抽象工厂模式的缺点是什么？" class="headerlink" title="10. 抽象工厂模式的缺点是什么？"></a>10. 抽象工厂模式的缺点是什么？</h4><p>缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。</p><h4 id="11-抽象工厂模式适用于和不适用于哪些情况？"><a href="#11-抽象工厂模式适用于和不适用于哪些情况？" class="headerlink" title="11. 抽象工厂模式适用于和不适用于哪些情况？"></a>11. 抽象工厂模式适用于和不适用于哪些情况？</h4><p>适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p><h4 id="12-什么时候可以使用单例模式？"><a href="#12-什么时候可以使用单例模式？" class="headerlink" title="12. 什么时候可以使用单例模式？"></a>12. 什么时候可以使用单例模式？</h4><p>某个对象全局只需要一个实例时即可。</p><h4 id="13-单例模式的优点是什么？"><a href="#13-单例模式的优点是什么？" class="headerlink" title="13. 单例模式的优点是什么？"></a>13. 单例模式的优点是什么？</h4><ul><li>它能够避免对象重复创建，节约空间并提升效率</li><li>避免由于操作不同实例导致的逻辑错误</li></ul><h4 id="14-单例模式有哪两种实现方式？请分别简单解释。"><a href="#14-单例模式有哪两种实现方式？请分别简单解释。" class="headerlink" title="14. 单例模式有哪两种实现方式？请分别简单解释。"></a>14. 单例模式有哪两种实现方式？请分别简单解释。</h4><p>饿汉式和懒汉式。饿汉式指变量在声明时便初始化。懒汉式指先声明一个空变量，需要用时才初始化。</p><h4 id="15-饿汉式的弊端是什么？"><a href="#15-饿汉式的弊端是什么？" class="headerlink" title="15. 饿汉式的弊端是什么？"></a>15. 饿汉式的弊端是什么？</h4><p>即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。</p><h4 id="16-静态内部类方式是怎么保证线程安全的？"><a href="#16-静态内部类方式是怎么保证线程安全的？" class="headerlink" title="16. 静态内部类方式是怎么保证线程安全的？"></a>16. 静态内部类方式是怎么保证线程安全的？</h4><p>Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p><h4 id="17-建造者模式用于什么时候？"><a href="#17-建造者模式用于什么时候？" class="headerlink" title="17. 建造者模式用于什么时候？"></a>17. 建造者模式用于什么时候？</h4><p>创建过程稳定，但配置多变的对象。</p><h4 id="18-建造者模式是什么意思？"><a href="#18-建造者模式是什么意思？" class="headerlink" title="18. 建造者模式是什么意思？"></a>18. 建造者模式是什么意思？</h4><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="19-现在建造者模式主要用来做什么？"><a href="#19-现在建造者模式主要用来做什么？" class="headerlink" title="19. 现在建造者模式主要用来做什么？"></a>19. 现在建造者模式主要用来做什么？</h4><p>通过链式调用生成不同的配置。</p><h4 id="20-使用建造者模式的好处是什么？"><a href="#20-使用建造者模式的好处是什么？" class="headerlink" title="20. 使用建造者模式的好处是什么？"></a>20. 使用建造者模式的好处是什么？</h4><p>不用担心忘了指定某个配置，保证了构建过程是稳定的。</p><h4 id="21-原型模式是什么？"><a href="#21-原型模式是什么？" class="headerlink" title="21. 原型模式是什么？"></a>21. 原型模式是什么？</h4><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h4 id="22-适配器模式适用于什么结构？"><a href="#22-适配器模式适用于什么结构？" class="headerlink" title="22. 适配器模式适用于什么结构？"></a>22. 适配器模式适用于什么结构？</h4><p>有相关性但不兼容的结构。</p><h4 id="23-什么是适配？什么是适配器？"><a href="#23-什么是适配？什么是适配器？" class="headerlink" title="23. 什么是适配？什么是适配器？"></a>23. 什么是适配？什么是适配器？</h4><p>源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p><h4 id="24-需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？"><a href="#24-需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？" class="headerlink" title="24. 需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？"></a>24. 需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？</h4><p>将形状和颜色分离，根据需要对形状和颜色进行组合。</p><h4 id="25-什么是桥接模式？"><a href="#25-什么是桥接模式？" class="headerlink" title="25. 什么是桥接模式？"></a>25. 什么是桥接模式？</h4><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p><h4 id="26-组合模式适用于什么结构？"><a href="#26-组合模式适用于什么结构？" class="headerlink" title="26. 组合模式适用于什么结构？"></a>26. 组合模式适用于什么结构？</h4><p>组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。</p><h4 id="27-组合模式最主要的功能是什么？"><a href="#27-组合模式最主要的功能是什么？" class="headerlink" title="27. 组合模式最主要的功能是什么？"></a>27. 组合模式最主要的功能是什么？</h4><p>组合模式最主要的功能是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件。</p><h4 id="28-什么是组合模式中的透明方式？"><a href="#28-什么是组合模式中的透明方式？" class="headerlink" title="28. 什么是组合模式中的透明方式？"></a>28. 什么是组合模式中的透明方式？</h4><p>违背了接口隔离原则的组合模式。</p><h4 id="29-什么是安全方式？"><a href="#29-什么是安全方式？" class="headerlink" title="29. 什么是安全方式？"></a>29. 什么是安全方式？</h4><p>在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p><h4 id="30-什么是透明装饰模式？"><a href="#30-什么是透明装饰模式？" class="headerlink" title="30. 什么是透明装饰模式？"></a>30. 什么是透明装饰模式？</h4><p>装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为透明装饰模式。</p><h4 id="31-装饰模式的缺点是什么？"><a href="#31-装饰模式的缺点是什么？" class="headerlink" title="31. 装饰模式的缺点是什么？"></a>31. 装饰模式的缺点是什么？</h4><p>容易造成程序中有大量相似的类。</p><h4 id="32-动态代理相对于静态代理的优势是什么？"><a href="#32-动态代理相对于静态代理的优势是什么？" class="headerlink" title="32. 动态代理相对于静态代理的优势是什么？"></a>32. 动态代理相对于静态代理的优势是什么？</h4><p>节省代码量。</p><h4 id="33-简述责任链模式的有优点有哪些？"><a href="#33-简述责任链模式的有优点有哪些？" class="headerlink" title="33. 简述责任链模式的有优点有哪些？"></a>33. 简述责任链模式的有优点有哪些？</h4><ul><li>降低了对象之间的耦合度。</li><li>扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。</li><li>灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。</li><li>简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用。</li></ul><h4 id="34-什么是宏命令？"><a href="#34-什么是宏命令？" class="headerlink" title="34. 什么是宏命令？"></a>34. 什么是宏命令？</h4><p>宏命令是将多个命令合并起来组成的命令。</p><h4 id="35-请写出解释器模式的一个常见应用。"><a href="#35-请写出解释器模式的一个常见应用。" class="headerlink" title="35. 请写出解释器模式的一个常见应用。"></a>35. 请写出解释器模式的一个常见应用。</h4><p>在我们平时匹配字符串时，用到的正则表达式就是一个解释器。</p><h4 id="36-怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？"><a href="#36-怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？" class="headerlink" title="36. 怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？"></a>36. 怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？</h4><ul><li>提供一个 String next() 方法，使得外部类可以按照次序，一条一条的读取数据；</li><li>提供一个 boolean hasNext() 方法，告知外部类是否还有下一条数据。</li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>原文链接：<a href="https://leetcode.cn/leetbook/read/design-patterns/nw26e3/">https://leetcode.cn/leetbook/read/design-patterns/nw26e3/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;如果你也曾有这样的疑惑——怎样更优雅地实现需求？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么设计模式便是打开这扇门的钥匙。程序界无</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="深入浅出设计模式" scheme="https://tianxiafeiyu.github.io/tags/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>cpu加压脚本</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/30/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/30/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/</id>
    <published>2022-12-30T23:10:53.000Z</published>
    <updated>2022-12-30T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      this scripts <span class="keyword">for</span> cpu usage testing</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      eg.  cpu_test.sh start  50 <span class="comment">#start testing use 50% cpu</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      eg.  cpu_test.sh stop  <span class="comment">#stop testing</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">############################################################</span></span></span><br><span class="line">op=$1</span><br><span class="line">num=$2</span><br><span class="line"></span><br><span class="line">mkcsp()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        touch ./killcpu.c</span><br><span class="line">        echo &#x27;int main()&#123;while(1);return 0;&#125;&#x27; &gt; killcpu.c</span><br><span class="line">        gcc -o out killcpu.c</span><br><span class="line">        chmod +x ./out</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">cpu_num=$(cat /proc/cpuinfo | grep &quot;physical id&quot; | wc -l)</span><br><span class="line"></span><br><span class="line">for i in `seq 1 $(expr $num \* $cpu_num / 100)`</span><br><span class="line">        do</span><br><span class="line">            ./out &amp;</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">for i in $( ps -ef | grep &#x27;./out&#x27;| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">        do</span><br><span class="line">                kill -9 $i</span><br><span class="line">        done</span><br><span class="line">rm -rf killcpu.c out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">if [ $op == &quot;start&quot; ]</span><br><span class="line">then</span><br><span class="line">        mkcsp</span><br><span class="line">fi</span><br><span class="line">        $op</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="cpu加压脚本" scheme="https://tianxiafeiyu.github.io/tags/cpu%E5%8A%A0%E5%8E%8B%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Chrome年度热门扩展程序</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Chrome%E5%B9%B4%E5%BA%A6%E7%83%AD%E9%97%A8%20%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Chrome%E5%B9%B4%E5%BA%A6%E7%83%AD%E9%97%A8%20%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-12-16T15:18:00.000Z</published>
    <updated>2023-06-16T08:44:56.401Z</updated>
    
    <content type="html"><![CDATA[<p>Google 官方统计的年度榜单，多看涨姿势~~</p><p>2022：<a href="https://www.oschina.net/news/221758/chrome-extension-favorite-2022">https://www.oschina.net/news/221758/chrome-extension-favorite-2022</a></p><p>2021：<a href="https://www.oschina.net/news/172732/chrome-extension-favorite-2021">https://www.oschina.net/news/172732/chrome-extension-favorite-2021</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Google 官方统计的年度榜单，多看涨姿势~~&lt;/p&gt;
&lt;p&gt;2022：&lt;a href=&quot;https://www.oschina.net/news/221758/chrome-extension-favorite-2022&quot;&gt;https://www.oschina.net</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
  </entry>
  
  <entry>
    <title>Prometheus监控kubernetes方案及实现</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-16T00:43:25.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promtheus监控kubernetes"><a href="#promtheus监控kubernetes" class="headerlink" title="promtheus监控kubernetes"></a>promtheus监控kubernetes</h1><h2 id="Kubernetes监控策略"><a href="#Kubernetes监控策略" class="headerlink" title="Kubernetes监控策略"></a>Kubernetes监控策略</h2><p>Kubernetes作为开源的容器编排工具，为用户提供了一个可以统一调度，统一管理的云操作系统。其解决如用户应用程序如何运行的问题。而一旦在生产环境中大量基于Kubernetes部署和管理应用程序后，作为系统管理员，还需要充分了解应用程序以及Kubernetes集群服务运行质量如何，通过对应用以及集群运行状态数据的收集和分析，持续优化和改进，从而提供一个安全可靠的生产运行环境。这一小节中我们将讨论当使用Kubernetes时的监控策略该如何设计。  </p><p>从物理结构上讲Kubernetes主要用于整合和管理底层的基础设施资源，对外提供应用容器的自动化部署和管理能力，这些基础设施可能是物理机、虚拟机、云主机等等。因此，基础资源的使用直接影响当前集群的容量和应用的状态。在这部分，我们需要关注集群中各个节点的主机负载，CPU使用率、内存使用率、存储空间以及网络吞吐等监控指标。  </p><p>从自身架构上讲，kube-apiserver是Kubernetes提供所有服务的入口，无论是外部的客户端还是集群内部的组件都直接与kube-apiserver进行通讯。因此，kube-apiserver的并发和吞吐量直接决定了集群性能的好坏。其次，对于外部用户而言，Kubernetes是否能够快速的完成pod的调度以及启动，是影响其使用体验的关键因素。而这个过程主要由kube-scheduler负责完成调度工作，而kubelet完成pod的创建和启动工作。因此在Kubernetes集群本身我们需要评价其自身的服务质量，主要关注在Kubernetes的API响应时间，以及Pod的启动时间等指标上。  </p><p>Kubernetes的最终目标还是需要为业务服务，因此我们还需要能够监控应用容器的资源使用情况。对于内置了对Prometheus支持的应用程序，也要支持从这些应用程序中采集内部的监控指标。最后，结合黑盒监控模式，对集群中部署的服务进行探测，从而当应用发生故障后，能够快速处理和恢复。  </p><p>在Kubernetes集群上也需要监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，这样可以反映出使用这些资源部署的应用状态。但通过查看api-server或者cAdvisor的指标，并没有具体的各种资源对象的状态指标，对于Prometheus来说，当然需要引入新的exporter来暴露这些指标，Kubernetes提供了名为kube-state-metrics的项目（项目地址：<a href="https://github.com/kubernetes/kube-state-metrics">https://github.com/kubernetes/kube-state-metrics</a> ）。</p><p>综上所述，我们需要综合使用白盒监控和黑盒监控模式，建立从基础设施，Kubernetes核心组件，应用容器等全面的监控体系。  </p><p>在白盒监控层面我们需要关注：</p><ul><li>基础设施层（Node）：为整个集群和应用提供运行时资源，需要通过各节点的kubelet获取节点的基本状态，同时通过在节点上部署Node Exporter获取节点的资源使用情况；</li><li>容器基础设施（Container）：为应用提供运行时环境，Kubelet内置了对cAdvisor的支持，用户可以直接通过Kubelet组件获取给节点上容器相关监控指标；</li><li>用户应用（Pod）：Pod中会包含一组容器，它们一起工作，并且对外提供一个（或者一组）功能。如果用户部署的应用程序内置了对Prometheus的支持，那么我们还应该采集这些Pod暴露的监控指标；</li><li>Kubernetes组件：获取并监控Kubernetes核心组件的运行状态，确保平台自身的稳定运行。  </li><li>Kubernetes资源对象：监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，反映出使用这些资源部署的应用状态</li></ul><p>而在黑盒监控层面，则主要需要关注以下：</p><ul><li>内部服务负载均衡（Service）：在集群内，通过Service在集群暴露应用功能，集群内应用和应用之间访问时提供内部的负载均衡。通过Balckbox Exporter探测Service的可用性，确保当Service不可用时能够快速得到告警通知；</li><li>外部访问入口（Ingress）：通过Ingress提供集群外的访问入口，从而可以使外部客户端能够访问到部署在Kubernetes集群内的服务。因此也需要通过Blackbox Exporter对Ingress的可用性进行探测，确保外部用户能够正常访问集群内的功能；</li></ul><p>下表中，梳理了监控Kubernetes集群监控的各个维度以及策略：</p><table><thead><tr><th>目标</th><th>描述</th><th>服务发现方式</th><th>监控方法</th><th>数据源</th><th>集群外监控</th></tr></thead><tbody><tr><td>api-server</td><td>获取API Server组件的访问地址，并从中获取Kubernetes集群相关的运行监控指标</td><td>endpoints</td><td>白盒监控</td><td>api server</td><td>✓</td></tr><tr><td>kube-schedule</td><td>kube-schedule的metrics接口 （Scheduler服务端口默认为10251）</td><td>-</td><td>白盒监控</td><td>kube-schedule</td><td>✓</td></tr><tr><td>control-manager</td><td>control-manager的metrics接口（ControllerManager服务端口默认为10252）</td><td>-</td><td>白盒监控</td><td>control-manager</td><td>✓</td></tr><tr><td>kubelet</td><td>从集群各节点kubelet组件中获取节点kubelet的基本运行状态的监控指标</td><td>node</td><td>白盒监控</td><td>kubelet</td><td>✓</td></tr><tr><td>kube-proxy</td><td>kube-proxy的metrics接口（ControllerManager服务端口默认为10252）</td><td>-</td><td>白盒监控</td><td>kube-proxy</td><td>✓</td></tr><tr><td>kube-dns</td><td>从集群各节点获取kube-dns的基本运行状态的监控指标</td><td>-</td><td>白盒监控</td><td>kube-dns</td><td>✓</td></tr><tr><td>cAdvisor</td><td>从集群各节点kubelet内置的cAdvisor中获取，节点中运行的容器的监控指标</td><td>node</td><td>白盒监控</td><td>kubelet</td><td>✓</td></tr><tr><td>node</td><td>从部署到各个节点的Node Exporter中采集主机资源相关的运行资源</td><td>node</td><td>白盒监控</td><td>node exporter</td><td>✓</td></tr><tr><td>pod</td><td>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标</td><td>pod</td><td>白盒监控</td><td>custom pod</td><td>✓</td></tr><tr><td>资源对象</td><td>监控Pod、DaemonSet、Deployment、Job、Cronjob等资源对象的状态，反映出使用这些资源部署的应用状态</td><td>endpoints</td><td>白盒监控</td><td>kube-state-metrics</td><td>✓</td></tr><tr><td>service</td><td>获取集群中Service的访问地址，并通过Blackbox  Exporter获取网络探测指标</td><td>service</td><td>黑盒监控</td><td>blackbox exporter</td><td>✓</td></tr><tr><td>ingress</td><td>获取集群中Ingress的访问信息，并通过Blackbox Exporter获取网络探测指标</td><td>ingress</td><td>黑盒监控</td><td>blackbox exporter</td><td>✓</td></tr></tbody></table><h2 id="kubernetes监控实现"><a href="#kubernetes监控实现" class="headerlink" title="kubernetes监控实现"></a>kubernetes监控实现</h2><p>使用prometheus监控kubernetes，基本上有两个场景： </p><ul><li>prometheus部署在k8s集群内部；</li><li>prometheus部署在k8s集群外部。</li></ul><p>两种场景大同小异，原理上都是基于kubernetes服务发现，promtheus自身已经实现了基于kubernetes的服务发现。但目前prometheus部署在k8s集群外部对于service和ingress的监控暂无合适方案</p><h3 id="prometheus部署在k8s集群外部监控实现"><a href="#prometheus部署在k8s集群外部监控实现" class="headerlink" title="prometheus部署在k8s集群外部监控实现"></a>prometheus部署在k8s集群外部监控实现</h3><h4 id="Kubernetes访问授权"><a href="#Kubernetes访问授权" class="headerlink" title="Kubernetes访问授权"></a>Kubernetes访问授权</h4><p>为了能够让Prometheus能够访问收到认证保护的Kubernetes API，我们首先需要做的是，对Prometheus进行访问授权。在Kubernetes中主要使用基于角色的访问控制模型(Role-Based Access Control)，用于管理Kubernetes下资源访问权限。首先我们需要在Kubernetes下定义角色（ClusterRole），并且为该角色赋予响应的访问权限。同时创建Prometheus所使用的账号（ServiceAccount），最后则是将该账号与角色进行绑定（ClusterRoleBinding）。这些所有的操作在Kubernetes同样被视为是一系列的资源，可以通过YAML文件进行描述并创建，这里创建prometheus-rbac-setup.yml文件，并写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - services</span><br><span class="line">  - services/proxy</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  - pods/proxy</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br></pre></td></tr></table></figure><p>通过kubectl命令创建RBAC对应的各个资源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f prometheus-rbac-setup.yml</span><br><span class="line">clusterrole &quot;prometheus&quot; created</span><br><span class="line">serviceaccount &quot;prometheus&quot; created</span><br><span class="line">clusterrolebinding &quot;prometheus&quot; created</span><br></pre></td></tr></table></figure><p>外部的prometheus需要获取Bearer Token来访问kubernetes api：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ SECRET=$(kubectl get serviceaccount prometheus -ojsonpath=&#x27;&#123;.secrets[0].name&#125;&#x27;)</span><br><span class="line">$ kubectl get secret $&#123;SECRET&#125; -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 -d &gt; /tmp/prometheus-sa-token</span><br></pre></td></tr></table></figure><h4 id="从kube-apiserver获取集群运行监控指标"><a href="#从kube-apiserver获取集群运行监控指标" class="headerlink" title="从kube-apiserver获取集群运行监控指标"></a>从kube-apiserver获取集群运行监控指标</h4><p>kube-apiserver扮演了整个Kubernetes集群管理的入口的角色，负责对外暴露Kubernetes API。kube-apiserver组件一般是独立部署在集群外的，为了能够让部署在集群内的应用（kubernetes插件或者用户应用）能够与kube-apiserver交互，Kubernetes会默认在命名空间下创建一个名为kubernetes的服务，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc kubernetes -o wide</span><br><span class="line">NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE       SELECTOR</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          166d      &lt;none&gt;</span><br></pre></td></tr></table></figure><p>而该kubernetes服务代理的后端实际地址通过endpoints进行维护，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get endpoints kubernetes</span><br><span class="line">NAME         ENDPOINTS        AGE</span><br><span class="line">kubernetes   192.168.1.4:6443   166d</span><br></pre></td></tr></table></figure><p>通过这种方式集群内的应用或者系统主机就可以通过集群内部的DNS域名kubernetes.default.svc访问到部署外部的kube-apiserver实例。 </p><p>因此，如果我们想要监控kube-apiserver相关的指标，只需要通过endpoints资源找到kubernetes对应的所有后端地址即可。  </p><p>如下所示，创建监控任务kubernetes-apiservers，这里指定了服务发现模式为endpoints。Promtheus会查找当前集群中所有的endpoints配置，并通过relabel进行判断是否为apiserver对应的访问地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-apiservers&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: default;kubernetes;https</span><br></pre></td></tr></table></figure><p>在relabel_configs配置中用于判断当前endpoints是否为kube-apiserver对用的地址。重新加载配置文件，重建Promthues实例，得到以下结果。</p><h4 id="监控kube-schedule、kube-control-manager、kube-proxy"><a href="#监控kube-schedule、kube-control-manager、kube-proxy" class="headerlink" title="监控kube-schedule、kube-control-manager、kube-proxy"></a>监控kube-schedule、kube-control-manager、kube-proxy</h4><p>在prometheus里手动添加kubernetes-schedule、kubernetes-control-manager组件的连接配置，非证书连接！以下组件的配置，还不需要使用证书连接，直接ip+port就可以，默认路径就是&#x2F;metrics<br>确保以下四个组件的metrcis数据可以通过下面方式正常获取。  </p><p>schedule的metrics接口 （Scheduler服务端口默认为10251）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-schedule&#x27;          #任务名</span><br><span class="line">  scrape_interval: 5s                   #本任务的抓取间隔，覆盖全局配置</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10251&#x27;]</span><br></pre></td></tr></table></figure><p>control-manager的metrics接口（ControllerManager服务端口默认为10252）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-control-manager&#x27;</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10252&#x27;]</span><br></pre></td></tr></table></figure><p>kube-proxy的metrics接口(kube-proxy服务端口默认为10249）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-proxy&#x27;</span><br><span class="line">  scrape_interval: 5s</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.1.4:10249&#x27;, &#x27;192.168.1.5：10249&#x27;, &#x27;192.168.1.6:10249&#x27; ]</span><br></pre></td></tr></table></figure><p>当然，还可用服务发现的方式监控，具体如下：<br>创建service：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-scheduler-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-scheduler</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    component: kube-scheduler</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10251</span><br><span class="line">    targetPort: 10251</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-controller-manager-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-controller-manager</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    component: kube-controller-manager</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10252</span><br><span class="line">    targetPort: 10252</span><br><span class="line">    protocol: TCP</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  name: kube-proxy-prometheus-discovery</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kube-proxy</span><br><span class="line">  annotations:</span><br><span class="line">    prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kube-proxy</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 10249</span><br><span class="line">    targetPort: 10249</span><br><span class="line">    nodePort: 30025</span><br><span class="line">    protocol: TCP</span><br></pre></td></tr></table></figure><p>创建监控任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kube-scheduler-prometheus-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-scheduler-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line">- job_name: &#x27;kube-controller-manager-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-controller-manager-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line">- job_name: &#x27;kube-proxy-prometheus-discovery&#x27;</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: true;kube-system;kube-proxy-prometheus-discovery</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从Kubelet获取节点运行状态"><a href="#从Kubelet获取节点运行状态" class="headerlink" title="从Kubelet获取节点运行状态"></a>从Kubelet获取节点运行状态</h4><p>Kubelet组件运行在Kubernetes集群的各个节点中，其负责维护和管理节点上Pod的运行状态。kubelet组件的正常运行直接关系到该节点是否能够正常的被Kubernetes集群正常使用。</p><p>基于Node模式，Prometheus会自动发现Kubernetes中所有Node节点的信息并作为监控的目标Target。 而这些Target的访问地址实际上就是Kubelet的访问地址，并且Kubelet实际上直接内置了对Promtheus的支持。</p><p>实际探索过程中，直接从kuberlet获取数据有报错。这里采用第二种方式：不直接通过kubelet的metrics服务采集监控数据，而通过Kubernetes的api-server提供的代理API访问各个节点中kubelet的metrics服务，如下所示：</p><p>修改prometheus.yml配置文件，并添加以下采集任务配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">    regex: (.+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics</span><br></pre></td></tr></table></figure><p>通过relabeling，将从Kubernetes获取到的默认地址__address__替换为192.168.1.4:6443。同时将__metrics_path__替换为api-server的代理地址&#x2F;api&#x2F;v1&#x2F;nodes&#x2F;${1}&#x2F;proxy&#x2F;metrics。</p><h4 id="监控kube-dns"><a href="#监控kube-dns" class="headerlink" title="监控kube-dns"></a>监控kube-dns</h4><p>kube-dns会在9153端口暴露采集指标，通过服务发现可以实现对kube-dns的监控</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kube-dns-discovery&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_endpoint_port_name]</span><br><span class="line">    separator: ;</span><br><span class="line">    regex: metrics</span><br><span class="line">    replacement: $1</span><br><span class="line">    action: keep</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/$&#123;2&#125;:$&#123;3&#125;/proxy/metrics</span><br><span class="line">      # 选择哪些label</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        # 上述选择的label的值需要与下述对应</span><br><span class="line">    regex: kube-system;kube-dns</span><br><span class="line">        # 含有符合regex的source_label的endpoints进行保留</span><br><span class="line">    action: keep</span><br></pre></td></tr></table></figure><h4 id="从cadvisor获取容器的监控数据"><a href="#从cadvisor获取容器的监控数据" class="headerlink" title="从cadvisor获取容器的监控数据"></a>从cadvisor获取容器的监控数据</h4><p>cAdvisor可以对节点机器上的资源及容器进行实时监控和性能数据采集，包括CPU使用情况、内存使用情况、网络吞吐量及文件系统使用情况。Kubernetes内置对cAdvisor支持。外部的Prometheus可以通过Api Server的代理访问到cAdvisor：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">  scheme: https</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: node</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">    regex: (.+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_node_label_(.+)</span><br></pre></td></tr></table></figure><h4 id="使用NodeExporter监控集群资源使用情况"><a href="#使用NodeExporter监控集群资源使用情况" class="headerlink" title="使用NodeExporter监控集群资源使用情况"></a>使用NodeExporter监控集群资源使用情况</h4><p>为了能够采集集群中各个节点的资源使用情况，我们需要在各节点中部署一个Node Exporter实例。在本章的“部署Prometheus”小节，我们使用了Kubernetes内置的控制器之一Deployment。Deployment能够确保Prometheus的Pod能够按照预期的状态在集群中运行，而Pod实例可能随机运行在任意节点上。而与Prometheus的部署不同的是，对于Node Exporter而言每个节点只需要运行一个唯一的实例，此时，就需要使用Kubernetes的另外一种控制器Daemonset。顾名思义，Daemonset的管理方式类似于操作系统中的守护进程。Daemonset会确保在集群中所有（也可以指定）节点上运行一个唯一的Pod实例。</p><p>创建node-exporter-daemonset.yml文件，并写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: node-exporter</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: node-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        prometheus.io/scrape: &#x27;true&#x27;</span><br><span class="line">        prometheus.io/port: &#x27;9100&#x27;</span><br><span class="line">        prometheus.io/path: &#x27;metrics&#x27;</span><br><span class="line">      labels:</span><br><span class="line">        app: node-exporter</span><br><span class="line">      name: node-exporter</span><br><span class="line">    spec:</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: &quot;node-role.kubernetes.io/master&quot;</span><br><span class="line">        operator: &quot;Equal&quot;</span><br><span class="line">        effect: &quot;NoSchedule&quot;</span><br><span class="line">      containers:</span><br><span class="line">      - image: prom/node-exporter</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: node-exporter</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9100</span><br><span class="line">          hostPort: 9100</span><br><span class="line">          name: scrape</span><br><span class="line">      hostNetwork: true</span><br><span class="line">      hostPID: true</span><br></pre></td></tr></table></figure><p>由于Node Exporter需要能够访问宿主机，因此这里指定了hostNetwork和hostPID，让Pod实例能够以主机网络以及系统进程的形式运行。同时YAML文件中也创建了NodeExporter相应的Service。这样通过Service就可以访问到对应的NodeExporter实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f node-exporter-daemonset.yml</span><br><span class="line">service &quot;node-exporter&quot; created</span><br><span class="line">daemonset &quot;node-exporter&quot; created</span><br></pre></td></tr></table></figure><p>目前为止，通过Daemonset的形式将Node Exporter部署到了集群中的各个节点中。接下来，我们只需要通过Prometheus的pod服务发现模式，找到当前集群中部署的Node Exporter实例即可。 需要注意的是，由于Kubernetes中并非所有的Pod都提供了对Prometheus的支持，有些可能只是一些简单的用户应用，为了区分哪些Pod实例是可以供Prometheus进行采集的，这里我们为Node Exporter添加了注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/scrape: &#x27;true&#x27;</span><br></pre></td></tr></table></figure><p>由于Kubernetes中Pod可能会包含多个容器，还需要用户通过注解指定用户提供监控指标的采集端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/port: &#x27;9100&#x27;</span><br></pre></td></tr></table></figure><p>而有些情况下，Pod中的容器可能并没有使用默认的&#x2F;metrics作为监控采集路径，因此还需要支持用户指定采集路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prometheus.io/path: &#x27;metrics&#x27;</span><br></pre></td></tr></table></figure><p>为Prometheus创建监控采集任务kubernetes-nodes，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-nodes&#x27;</span><br><span class="line">   kubernetes_sd_configs:</span><br><span class="line">   - role: pod</span><br><span class="line">     api_server: https://192.168.1.4:6443</span><br><span class="line">     bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">     tls_config:</span><br><span class="line">       insecure_skip_verify: true</span><br><span class="line">   relabel_configs:</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">     action: keep</span><br><span class="line">     regex: true</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: __metrics_path__</span><br><span class="line">     regex: (.+)</span><br><span class="line">   - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">     action: replace</span><br><span class="line">     regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">     replacement: $1:$2</span><br><span class="line">     target_label: __address__</span><br><span class="line">   - action: labelmap</span><br><span class="line">     regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">   - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: kubernetes_namespace</span><br><span class="line">   - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">     action: replace</span><br><span class="line">     target_label: kubernetes_pod_name</span><br><span class="line">   - source_labels:  [&quot;__mkubernetes_pod_node_name&quot;]</span><br><span class="line">     target_label: &quot;node_name&quot;</span><br></pre></td></tr></table></figure><h4 id="使用kube-state-metrics监控资源对象"><a href="#使用kube-state-metrics监控资源对象" class="headerlink" title="使用kube-state-metrics监控资源对象"></a>使用kube-state-metrics监控资源对象</h4><p>通过kube-state-metrics可以获取以下指标</p><ul><li>CronJob Metrics</li><li>DaemonSet Metrics</li><li>Deployment Metrics</li><li>Job Metrics</li><li>LimitRange Metrics</li><li>Node Metrics</li><li>PersistentVolume Metrics</li><li>PersistentVolumeClaim Metrics</li><li>Pod Metrics</li><li>ReplicaSet Metrics</li><li>ReplicationController Metrics</li><li>ResourceQuota Metrics</li><li>Service Metrics</li><li>StatefulSet Metrics</li><li>Namespace Metrics</li><li>Horizontal Pod Autoscaler Metrics</li><li>Endpoint Metrics</li></ul><h5 id="Kubernetes版本支持"><a href="#Kubernetes版本支持" class="headerlink" title="Kubernetes版本支持"></a>Kubernetes版本支持</h5><p>kube-state-metrics用于client-go与Kubernetes集群通信。支持的Kubernetes集群版本由决定client-go。可以在此处找到client-go和Kubernetes集群的兼容性矩阵 。</p><table><thead><tr><th>kube-state-metrics</th><th><strong>Kubernetes 1.12</strong></th><th><strong>Kubernetes 1.13</strong></th><th><strong>Kubernetes 1.14</strong></th><th><strong>Kubernetes 1.15</strong></th><th><strong>Kubernetes 1.16</strong></th><th><strong>Kubernetes 1.17</strong></th></tr></thead><tbody><tr><td><strong>v1.5.0</strong></td><td>✓</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.6.0</strong></td><td>✓</td><td>✓</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.7.2</strong></td><td>✓</td><td>✓</td><td>✓</td><td>-</td><td>-</td><td>-</td></tr><tr><td><strong>v1.8.0</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>-</td><td>-</td></tr><tr><td><strong>v1.9.4</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>-</td></tr><tr><td><strong>master</strong></td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr></tbody></table><h5 id="部署kube-state-metrics"><a href="#部署kube-state-metrics" class="headerlink" title="部署kube-state-metrics"></a>部署kube-state-metrics</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - &quot;&quot;</span><br><span class="line">  resources:</span><br><span class="line">  - configmaps</span><br><span class="line">  - secrets</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - pods</span><br><span class="line">  - pods/proxy</span><br><span class="line">  - services/proxy</span><br><span class="line">  - services</span><br><span class="line">  - resourcequotas</span><br><span class="line">  - replicationcontrollers</span><br><span class="line">  - limitranges</span><br><span class="line">  - persistentvolumeclaims</span><br><span class="line">  - persistentvolumes</span><br><span class="line">  - namespaces</span><br><span class="line">  - endpoints</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">  - get</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - daemonsets</span><br><span class="line">  - deployments</span><br><span class="line">  - replicasets</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - apps</span><br><span class="line">  resources:</span><br><span class="line">  - statefulsets</span><br><span class="line">  - daemonsets</span><br><span class="line">  - deployments</span><br><span class="line">  - replicasets</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - batch</span><br><span class="line">  resources:</span><br><span class="line">  - cronjobs</span><br><span class="line">  - jobs</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - autoscaling</span><br><span class="line">  resources:</span><br><span class="line">  - horizontalpodautoscalers</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - authentication.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - tokenreviews</span><br><span class="line">  verbs:</span><br><span class="line">  - create</span><br><span class="line">- apiGroups:</span><br><span class="line">  - authorization.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - subjectaccessreviews</span><br><span class="line">  verbs:</span><br><span class="line">  - create</span><br><span class="line">- apiGroups:</span><br><span class="line">  - policy</span><br><span class="line">  resources:</span><br><span class="line">  - poddisruptionbudgets</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - certificates.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - certificatesigningrequests</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - storage.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - storageclasses</span><br><span class="line">  - volumeattachments</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - admissionregistration.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - mutatingwebhookconfigurations</span><br><span class="line">  - validatingwebhookconfigurations</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line">- apiGroups:</span><br><span class="line">  - networking.k8s.io</span><br><span class="line">  resources:</span><br><span class="line">  - networkpolicies</span><br><span class="line">  verbs:</span><br><span class="line">  - list</span><br><span class="line">  - watch</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">        app.kubernetes.io/version: v1.9.4</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: quay.io/coreos/kube-state-metrics:v1.9.4</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthz</span><br><span class="line">            port: 8080</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        name: kube-state-metrics</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line">          name: http-metrics</span><br><span class="line">        - containerPort: 8081</span><br><span class="line">          name: telemetry</span><br><span class="line">        readinessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /</span><br><span class="line">            port: 8081</span><br><span class="line">          initialDelaySeconds: 5</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">      nodeSelector:</span><br><span class="line">        kubernetes.io/os: linux</span><br><span class="line">      serviceAccountName: kube-state-metrics</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line">    app.kubernetes.io/version: v1.9.4</span><br><span class="line">  name: kube-state-metrics</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None</span><br><span class="line">  ports:</span><br><span class="line">  - name: http-metrics</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: http-metrics</span><br><span class="line">  - name: telemetry</span><br><span class="line">    port: 8081</span><br><span class="line">    targetPort: telemetry</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: kube-state-metrics</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="prometheus创建kube-state-netrics监控任务"><a href="#prometheus创建kube-state-netrics监控任务" class="headerlink" title="prometheus创建kube-state-netrics监控任务"></a>prometheus创建kube-state-netrics监控任务</h5><p>通过kubernetes服务发现，监控kube-state-metrics</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kube-state-metrics&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [ __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: kube-state-metrics;http-metrics</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/http:$&#123;2&#125;:$&#123;3&#125;/proxy/metrics</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h4 id="内置对prometheus支持的应用监控"><a href="#内置对prometheus支持的应用监控" class="headerlink" title="内置对prometheus支持的应用监控"></a>内置对prometheus支持的应用监控</h4><p>对于内置了Promthues支持的应用，需要从Pod实例中采集其自定义监控指标。在这需要对应用添加以annotations：</p><ul><li>prometheus.io&#x2F;scrape: ‘true’</li><li>prometheus.io&#x2F;port: ‘your_port’</li><li>prometheus.io&#x2F;path: ‘your_metrics_path’</li></ul><p>通过这些标签可以筛选掉无用的应用。</p><p>添加promtheus任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-kube-service&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: endpoints</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: instance</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_name, __meta_kubernetes_pod_container_port_number, __meta_kubernetes_service_annotation_prometheus_io_path]</span><br><span class="line">    regex: ([^;]+);([^;]+);([^;]+);([^;]+)</span><br><span class="line">    target_label: __metrics_path__</span><br><span class="line">    replacement: /api/v1/namespaces/$&#123;1&#125;/pods/http:$&#123;2&#125;:$&#123;3&#125;/proxy/$&#123;4&#125;</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    action: replace</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h4 id="对Ingress和Service进行网络探测"><a href="#对Ingress和Service进行网络探测" class="headerlink" title="对Ingress和Service进行网络探测"></a>对Ingress和Service进行网络探测</h4><p>为了能够对Ingress和Service进行探测，我们需要在集群部署Blackbox Exporter实例。 如下所示，创建blackbox-exporter.yaml用于描述部署相关的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  name: blackbox-exporter</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: blackbox</span><br><span class="line">    port: 9115</span><br><span class="line">    protocol: TCP</span><br><span class="line">  selector:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  type: ClusterIP</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: blackbox-exporter</span><br><span class="line">  name: blackbox-exporter</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: blackbox-exporter</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: blackbox-exporter</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: prom/blackbox-exporter</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: blackbox-exporter</span><br></pre></td></tr></table></figure><p>为了能够让Prometheus能够自动的对Service进行探测，我们需要通过服务发现自动找到所有的Service信息。 如下所示，在Prometheus的配置文件中添加名为kubernetes-services的监控采集任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-services&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  params:</span><br><span class="line">    module: [http_2xx]</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: service</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__address__]</span><br><span class="line">    target_label: __param_target</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - target_label: __metrics_path__</span><br><span class="line">    replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br><span class="line">  - source_labels: [__param_target]</span><br><span class="line">    target_label: instance</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><p>在该任务配置中，通过指定kubernetes_sd_config的role为service指定服务发现模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubernetes_sd_configs:</span><br><span class="line">    - role: service</span><br><span class="line">      api_server: https://192.168.1.4:6443</span><br><span class="line">      tls_config:</span><br><span class="line">        insecure_skip_verify: true</span><br><span class="line">      bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br></pre></td></tr></table></figure><p>为了区分集群中需要进行探测的Service实例，我们通过标签‘prometheus.io&#x2F;probe: true’进行判断，从而过滤出需要探测的所有Service实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">  action: keep</span><br><span class="line">  regex: true</span><br></pre></td></tr></table></figure><p>为了能够在外部访问k8s集群内部的blackbox，这里使用的Kubernetes proxy api</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- target_label: __address__</span><br><span class="line">  replacement: 192.168.1.4:6443</span><br><span class="line">- target_label: __metrics_path__</span><br><span class="line">  replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br></pre></td></tr></table></figure><p>对于Ingress而言，也是一个相对类似的过程，这里给出对Ingress探测的Promthues任务配置作为参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;kubernetes-ingresses&#x27;</span><br><span class="line">  tls_config:</span><br><span class="line">    insecure_skip_verify: true</span><br><span class="line">  bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  scheme: https</span><br><span class="line">  params:</span><br><span class="line">    module: [http_2xx]</span><br><span class="line">  kubernetes_sd_configs:</span><br><span class="line">  - role: ingress</span><br><span class="line">    api_server: https://192.168.1.4:6443</span><br><span class="line">    tls_config:</span><br><span class="line">      insecure_skip_verify: true</span><br><span class="line">    bearer_token_file: C:/Users/Administrator/Desktop/prometheus-token</span><br><span class="line">  relabel_configs:</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe]</span><br><span class="line">    action: keep</span><br><span class="line">    regex: true</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]</span><br><span class="line">    regex: (.+);(.+);(.+)</span><br><span class="line">    replacement: $&#123;1&#125;://$&#123;2&#125;$&#123;3&#125;</span><br><span class="line">    target_label: __param_target</span><br><span class="line">  - target_label: __address__</span><br><span class="line">    replacement: 192.168.1.4:6443</span><br><span class="line">  - target_label: __metrics_path__</span><br><span class="line">    replacement: api/v1/namespaces/default/services/blackbox-exporter:9115/proxy/probe</span><br><span class="line">  - source_labels: [__param_target]</span><br><span class="line">    target_label: instance</span><br><span class="line">  - action: labelmap</span><br><span class="line">    regex: __meta_kubernetes_ingress_label_(.+)</span><br><span class="line">  - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">    target_label: kubernetes_namespace</span><br><span class="line">  - source_labels: [__meta_kubernetes_ingress_name]</span><br><span class="line">    target_label: kubernetes_name</span><br></pre></td></tr></table></figure><h3 id="prometheus部署在k8s集群内部监控实现"><a href="#prometheus部署在k8s集群内部监控实现" class="headerlink" title="prometheus部署在k8s集群内部监控实现"></a>prometheus部署在k8s集群内部监控实现</h3><p>prometheus部署在k8s集群内部监控k8s和部署在外部监控的原理是一样的，唯一的区别：</p><ul><li>集群内部，可以通过集群的DNS访问监控对象，不需要通过api server代理。</li><li>服务发现时，不需要制定api server 的地址。</li></ul><p>具体过程如下：</p><p>1.授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources:</span><br><span class="line">  - nodes</span><br><span class="line">  - nodes/proxy</span><br><span class="line">  - pods</span><br><span class="line">  - proxy</span><br><span class="line">  - pods/proxy</span><br><span class="line">  - services</span><br><span class="line">  - services/proxy</span><br><span class="line">  - endpoints</span><br><span class="line">  - pods</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups:</span><br><span class="line">  - extensions</span><br><span class="line">  resources:</span><br><span class="line">  - ingresses</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">- nonResourceURLs: [&quot;/metrics&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;]</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: prometheus</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: prometheus</span><br><span class="line">  namespace: default</span><br></pre></td></tr></table></figure><p>2.将prometheus的配置放在configmap中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  prometheus.yml: |-</span><br><span class="line">    global:</span><br><span class="line">      scrape_interval:     15s </span><br><span class="line">      evaluation_interval: 15s</span><br><span class="line">    scrape_configs:</span><br><span class="line">    - job_name: &#x27;kubernetes-apiservers&#x27;</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: default;kubernetes;https</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">    - job_name: &#x27;kube-scheduler&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-scheduler-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kube-controller-manager&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-controller-manager-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kubernetes-kubelet&#x27;</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: node</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        regex: (.+)</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        target_label: &quot;kubernetes_node_name&quot;</span><br><span class="line">    - job_name: &#x27;kubernetes-cadvisor&#x27;</span><br><span class="line">      scheme: https</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: node</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: kubernetes.default.svc:443</span><br><span class="line">      - source_labels: [__meta_kubernetes_node_name]</span><br><span class="line">        regex: (.+)</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        replacement: /api/v1/nodes/$&#123;1&#125;/proxy/metrics/cadvisor</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_node_label_(.+)</span><br><span class="line">    - job_name: &#x27;kube-proxy&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape, __meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: true;kube-system;kube-proxy-prometheus-discovery</span><br><span class="line">        action: keep</span><br><span class="line">    - job_name: &#x27;kube-dns-discovery&#x27;</span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name]</span><br><span class="line">        regex: kube-system;kube-dns</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__meta_kubernetes_endpoint_port_name]</span><br><span class="line">        separator: ;</span><br><span class="line">        regex: metrics</span><br><span class="line">        replacement: $1</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: instance</span><br><span class="line">    - job_name: &#x27;kube-state-metrics&#x27;        </span><br><span class="line">      tls_config:</span><br><span class="line">        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: endpoints</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]</span><br><span class="line">        regex: kube-state-metrics;http-metrics</span><br><span class="line">        action: keep</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __scheme__</span><br><span class="line">        regex: (https?)</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        regex: (.+)</span><br><span class="line">      - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __address__</span><br><span class="line">        regex: (.+)(?::\d+);(\d+)</span><br><span class="line">        replacement: $1:$2</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_name        </span><br><span class="line">    - job_name: &#x27;kubernetes-pods&#x27;</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: pod</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: __metrics_path__</span><br><span class="line">        regex: (.+)</span><br><span class="line">      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]</span><br><span class="line">        action: replace</span><br><span class="line">        regex: ([^:]+)(?::\d+)?;(\d+)</span><br><span class="line">        replacement: $1:$2</span><br><span class="line">        target_label: __address__</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_pod_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_name]</span><br><span class="line">        action: replace</span><br><span class="line">        target_label: kubernetes_pod_name   </span><br><span class="line">      - source_labels: [__meta_kubernetes_pod_node_name]</span><br><span class="line">        target_label: kubernetes_node_name   </span><br><span class="line">    - job_name: &#x27;kubernetes-services&#x27;</span><br><span class="line">      metrics_path: /probe</span><br><span class="line">      params:</span><br><span class="line">        module: [http_2xx]</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: service</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__address__]</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: blackbox-exporter.default.svc.cluster.local:9115</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_service_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_service_name]</span><br><span class="line">        target_label: kubernetes_name</span><br><span class="line">    - job_name: &#x27;kubernetes-ingresses&#x27;</span><br><span class="line">      metrics_path: /probe</span><br><span class="line">      params:</span><br><span class="line">        module: [http_2xx]</span><br><span class="line">      kubernetes_sd_configs:</span><br><span class="line">      - role: ingress</span><br><span class="line">      relabel_configs:</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe]</span><br><span class="line">        action: keep</span><br><span class="line">        regex: true</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]</span><br><span class="line">        regex: (.+);(.+);(.+)</span><br><span class="line">        replacement: $&#123;1&#125;://$&#123;2&#125;$&#123;3&#125;</span><br><span class="line">        target_label: __param_target</span><br><span class="line">      - target_label: __address__</span><br><span class="line">        replacement: blackbox-exporter.default.svc.cluster.local:9115</span><br><span class="line">      - source_labels: [__param_target]</span><br><span class="line">        target_label: instance</span><br><span class="line">      - action: labelmap</span><br><span class="line">        regex: __meta_kubernetes_ingress_label_(.+)</span><br><span class="line">      - source_labels: [__meta_kubernetes_namespace]</span><br><span class="line">        target_label: kubernetes_namespace</span><br><span class="line">      - source_labels: [__meta_kubernetes_ingress_name]</span><br><span class="line">        target_label: kubernetes_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus-config</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.创建prometheus service和deployment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus</span><br><span class="line">  name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: prometheus</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: prometheus</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: prometheus</span><br><span class="line">      serviceAccount: prometheus</span><br><span class="line">      containers:</span><br><span class="line">      - name: prometheus</span><br><span class="line">        image: prom/prometheus:v2.2.1</span><br><span class="line">        command:</span><br><span class="line">        - &quot;/bin/prometheus&quot;</span><br><span class="line">        args:</span><br><span class="line">        - &quot;--config.file=/etc/prometheus/prometheus.yml&quot;</span><br><span class="line">        - &quot;--web.enable-lifecycle&quot;</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          protocol: TCP</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;/etc/prometheus&quot;</span><br><span class="line">          name: prometheus-config</span><br><span class="line">      volumes:</span><br><span class="line">      - name: prometheus-config</span><br><span class="line">        configMap:</span><br><span class="line">          name: prometheus-config</span><br><span class="line">        </span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: &quot;Service&quot;</span><br><span class="line">metadata:</span><br><span class="line">  name: prometheus</span><br><span class="line">  labels:</span><br><span class="line">    name: prometheus</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: prometheus</span><br><span class="line">    protocol: TCP</span><br><span class="line">    port: 9090</span><br><span class="line">    targetPort: 9090</span><br><span class="line">    nodePort: 30090</span><br><span class="line">  selector:</span><br><span class="line">    app: prometheus</span><br><span class="line">  type: NodePort</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里创建的prometheus service是NodePort类型，可以直接通过ip:30090访问prometheus。</p><h2 id="kubernetes监控方案"><a href="#kubernetes监控方案" class="headerlink" title="kubernetes监控方案"></a>kubernetes监控方案</h2><p>上面讲述了如何在集群外部和集群内部监控k8s 。对于单集群来说，这两种方案已经能够满足我们的需求。那对于多集群监控呢。下面列出两种方案：</p><table><thead><tr><th>方案</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>采用外部部署prometheus的方式，写多套配置</td><td>无需对k8s造成额外的资源占用</td><td>增加了api server的负载</td></tr><tr><td>利用联邦集群，每个k8s中部署一个prometheus，由外部prometheus汇总</td><td>api server负载小</td><td>对k8s造成额外的资源占用</td></tr></tbody></table><p>两种方案各有各自的优缺点，在部署实施过程中，可根据需求选择对应方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;promtheus监控kubernetes&quot;&gt;&lt;a href=&quot;#promtheus监控kubernetes&quot; class=&quot;headerlink&quot; title=&quot;promtheus监控kubernetes&quot;&gt;&lt;/a&gt;promtheus监控kubernetes&lt;/</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="Prometheus监控kubernetes方案及实现" scheme="https://tianxiafeiyu.github.io/tags/Prometheus%E7%9B%91%E6%8E%A7kubernetes%E6%96%B9%E6%A1%88%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch学习</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E5%AD%A6%E4%B9%A0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/16/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/Elasticsearch%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-16T00:43:25.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做skywalking相关的项目，skywalking使用了Elasticsearch对数据指标进行存取，要理解skywalking的工程项目，就需要对 Elasticsearch 有一定的了解。</p><p>转载自 <a href="https://www.jianshu.com/p/d48c32423789">https://www.jianshu.com/p/d48c32423789</a></p><h2 id="什么是-Elasticsearch"><a href="#什么是-Elasticsearch" class="headerlink" title="什么是 Elasticsearch"></a>什么是 Elasticsearch</h2><p><a href="https://www.elastic.co/cn/elasticsearch">https://www.elastic.co/cn/elasticsearch</a></p><p>Elasticsearch是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><p>Elasticsearch用 Java 编写，内部采用 Lucene 做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene 做了一层封装，它提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。</p><p>Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确地形容：</p><ul><li>一个分布式的实时文档存储系统，每个字段可以被索引与搜索；</li><li>一个分布式实时分析搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><p>现在，Elasticsearch已成为全文搜索领域的主流软件之一。维基百科、卫报、Stack Overflow、GitHub等都纷纷采用它来做搜索。</p><h2 id="Elasticsearch-一些概念"><a href="#Elasticsearch-一些概念" class="headerlink" title="Elasticsearch 一些概念"></a>Elasticsearch 一些概念</h2><p>【Cluster】</p><p>集群,一个ES集群由一个或多个节点(Node)组成,每个集群都有一个cluster name作为标识</p><p>【node】</p><p>节点,一个ES实例就是一个node,一个机器可以有多个实例,所以并不能说一台机器就是一个node，大多数情况下每个node运行在一个独立的环境或者虚拟机上。</p><p>【index】<br>索引，即文档的集合</p><p>【shard】</p><ol><li>分片,ES是分布式搜索引擎,每个索引有一个或多个分片,索引的数据被分配到各个分片上，相当于一桶水分N个杯子装。</li><li>分片有助于横向扩展，N个分片会尽可能平均地分配在不同的节点上。（2个节点，4个分片，则每个节点会分到2个分片。后面增加2个节点后，ES会自动感知进行分配，每个节点一个分片）</li><li>分片是独立的。</li><li>每个分片都是一个Lucene Index，所以一个分片只能存放Integer.MAX_VALUE-128&#x3D;2,147,483,519个docs。</li><li>分片中有 主分片（primary shard）和备份分片（replica shard），主分片和备份分片不会出现在同一个节点上（防止单点故障），默认情况下一个索引会创建5个分片及它们的备份（5primary 5replica&#x3D;10个分片）。如果只有一个节点，备份分片将会无法分配（unassigned）,此时集群状态为Yellow。</li><li>对于一个索引，除非重建索引，否则不能调整分片数目（主分片数目, number_of_shards）,但是可以随时调整备份分片数目（number_of_replicas）</li></ol><p>【ES集群状态】</p><ul><li>Green：所有主分片和备份分片都准备就绪（分配成功）。</li><li>Yellow：所有主分片准备就绪，存在至少一个备份分片没有准备就绪。</li><li>Red：存在至少一个主分片没有准备就绪，此时查询可能会出现数据丢失。</li></ul><p>【replica作用】</p><ul><li>容灾：primary分片丢失,replica分片就会被顶上去成为新的主分片,同时根据这个新的主分片创建新的replica，集群数据安然无恙。</li><li>提高查询性能：主分片和备份分片的数据是相同的，所有对于查询请求既可以查主分片也可以查备份分片，在合适的范围内多个replica性能会更优。</li></ul><h3 id="1-文档"><a href="#1-文档" class="headerlink" title="1. 文档"></a>1. 文档</h3><h4 id="1-1-什么是文档？"><a href="#1-1-什么是文档？" class="headerlink" title="1.1 什么是文档？"></a>1.1 什么是文档？</h4><p>对象 or 文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:         &quot;John Smith&quot;,</span><br><span class="line">    &quot;age&quot;:          42,</span><br><span class="line">    &quot;confirmed&quot;:    true,</span><br><span class="line">    &quot;join_date&quot;:    &quot;2014-06-01&quot;,</span><br><span class="line">    &quot;home&quot;: &#123;</span><br><span class="line">        &quot;lat&quot;:      51.5,</span><br><span class="line">        &quot;lon&quot;:      0.1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;accounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;facebook&quot;,</span><br><span class="line">            &quot;id&quot;:   &quot;johnsmith&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;twitter&quot;,</span><br><span class="line">            &quot;id&quot;:   &quot;johnsmith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们使用的术语 <code>对象</code> 和 <code>文档</code> 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，<code>文档</code> 有着特定的含义。它是指最顶层或者根对象, 这个根对象被序列化成 JSON 并存储到 Elasticsearch 中，指定了唯一 ID。</p><h4 id="1-2-文档元数据"><a href="#1-2-文档元数据" class="headerlink" title="1.2 文档元数据"></a>1.2 文档元数据</h4><p>一个文档不仅仅包含它的数据 ，也包含 元数据 —— 有关 文档的信息。<br>三个必须的元数据元素如下：</p><ul><li><p>_index<br> 文档在哪存放<br>我们可以简单理解为一个文档存储在一个索引内，索引和文档是一对多的关系。  </p><blockquote><p> 实际上，在 Elasticsearch 中，我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。 然而，这是一个内部细节，我们的应用程序根本不应该关心分片，对于应用程序而言，只需知道文档位于一个 索引 内。 Elasticsearch 会处理所有的细节。</p></blockquote></li><li><p>_type<br> 文档表示的对象类别<br><code>types</code> （类型）允许在索引中对数据进行逻辑分区。不同 <code>types</code> 的文档可能有不同的字段，但最好能够非常相似。一个  <code>_type</code> 命名可以是大写或者小写，但是不能以下划线或者句号开头，不应该包含逗号， 并且长度限制为256个字符。</p></li><li><p>_id<br>文档唯一标识<br>它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。<br>创建一个新的文档时，可以指定 <code>_id</code> ，也可以让 Elasticsearch 自动生成。</p></li></ul><p>当然，还有很多其他的元数据</p><h3 id="2-分布式文档存储"><a href="#2-分布式文档存储" class="headerlink" title="2. 分布式文档存储"></a>2. 分布式文档存储</h3><h4 id="2-1-文档的存放位置"><a href="#2-1-文档的存放位置" class="headerlink" title="2.1 文档的存放位置"></a>2.1 文档的存放位置</h4><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？</p><p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shard = hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure><p><code>routing </code> : 可变值，默认是文档的 _id ，也可以设置成一个自定义的值</p><p><code>number_of_primary_shards </code> : 主分片的数量</p><p><code>shard</code> : 文档所在分片的位置，取值范围 [0, number_of_primary_shards-1]</p><p>这也解释了为什么创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p><blockquote><p>你可能觉得由于 Elasticsearch 主分片数量是固定的会使索引难以进行扩容。实际上当你需要时有很多技巧可以轻松实现扩容。</p></blockquote><p><strong>所有的文档 API（ get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档——例如所有属于同一个用户的文档——都被存储到同一个分片中</strong>。</p><h4 id="2-2-主分片和副本分片如何交互"><a href="#2-2-主分片和副本分片如何交互" class="headerlink" title="2.2 主分片和副本分片如何交互"></a>2.2 主分片和副本分片如何交互</h4><h5 id="2-2-1-分片分布规则"><a href="#2-2-1-分片分布规则" class="headerlink" title="2.2.1 分片分布规则"></a>2.2.1 分片分布规则</h5><p>假设有一个集群由三个节点组成。 它包含一个叫 blogs 的索引，有两个主分片，每个主分片有两个副本分片，相同分片的副本不会放在同一节点。类似如下图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/410BA879B6594958B1AAC8F3DF0DD8F7?method=getImage&version=8841&cstk=XTuNqpzO" alt="集群"></p><p>我们可以发送请求到集群中的任一节点。 每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。负责转发的节点称为 ***协调节点(coordinating node)***。</p><h5 id="2-2-2-索引、新建和删除"><a href="#2-2-2-索引、新建和删除" class="headerlink" title="2.2.2 索引、新建和删除"></a>2.2.2 索引、新建和删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 索引文档- 存储和使文档可被搜索 (也可以作为更新功能)</span><br><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;value&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 例如</span><br><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;:  &quot;Just trying this out...&quot;,</span><br><span class="line">  &quot;date&quot;:  &quot;2014/01/01&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 新建新文档（与索引的区分就是确保生成新的文档，而不是覆盖）</span><br><span class="line">POST /website/blog/  # es自动生成_id，保证唯一</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">PUT /website/blog/123/_create   # 指定 _id 为 123，若是已存在_id，则创建失败并且返回409</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"># 删除文档</span><br><span class="line">DELETE /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em><strong>注意：在 Elasticsearch 中文档是 不可改变 的，不能修改它们。如果想要更新现有的文档，需要 重建索引 或者进行替换</strong></em></p><p>新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/6A476F43F8264DDBB17485EF3150A97B?method=getImage&version=7159&cstk=kixc2ey7" alt="新建、索引和删除单个文档"></p><p>以下是在主副分片和任何副本分片上面 成功新建，索引和删除文档所需要的步骤顺序：</p><ol><li>客户端向 <code>Node 1</code> 发送新建、索引或者删除请求。</li><li>节点使用文档的 <code>_id</code> 确定文档属于分片 0 。请求会被转发到 <code>Node 3</code>，因为分片 0 的主分片目前被分配在 <code>Node 3</code> 上。</li><li><code>Node 3</code> 在主分片上面执行请求。如果成功了，它将请求并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 的副本分片上。一旦所有的副本分片都报告成功, <code>Node 3</code> 将向协调节点报告成功，协调节点向客户端报告成功。</li></ol><p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。</p><h5 id="2-2-3-单文档查询"><a href="#2-2-3-单文档查询" class="headerlink" title="2.2.3 单文档查询"></a>2.2.3 单文档查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br><span class="line">#pretty 参数，将会调用 Elasticsearch 的 pretty-print 功能，该功能将会格式化数据，提高可读性。</span><br><span class="line"></span><br><span class="line"># 获取文档部分内容</span><br><span class="line">GET /website/blog/123?_source=title,text</span><br><span class="line"></span><br><span class="line"># 只想得到 _source 字段，不需要任何元数据</span><br><span class="line">GET /website/blog/123?_source</span><br></pre></td></tr></table></figure><p>响应体包括常见元数据元素，再加上  <code>_source</code> 字段，这个字段包含我们索引数据时发送给 Elasticsearch 的原始 JSON 文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; :   &quot;website&quot;,</span><br><span class="line">  &quot;_type&quot; :    &quot;blog&quot;,</span><br><span class="line">  &quot;_id&quot; :      &quot;123&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; :    true,</span><br><span class="line">  &quot;_source&quot; :  &#123;</span><br><span class="line">      &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">      &quot;text&quot;:  &quot;Just trying this out...&quot;,</span><br><span class="line">      &quot;date&quot;:  &quot;2014/01/01&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Get 获取文档，可以从主分片或者从其它任意副本分片检索文档 ，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/A249BA20D8BC434FB1329C7EE93D2093?method=getImage&version=8204&cstk=XTuNqpzO" alt="获取文档"></p><p>以下是从主分片或者副本分片检索文档的步骤顺序：</p><ol><li><p>客户端向 <code>Node 1</code> 发送获取请求。</p></li><li><p>节点使用文档的 <code>_id</code> 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 <code>Node 2</code> 。</p></li><li><p><code>Node 2</code> 将文档返回给 <code>Node 1</code> ，然后将文档返回给客户端。</p></li></ol><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。</p><p>在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h5 id="2-2-4-局部更新文档"><a href="#2-2-4-局部更新文档" class="headerlink" title="2.2.4 局部更新文档"></a>2.2.4 局部更新文档</h5><p>update 请求最简单的一种形式是接收文档的一部分作为 doc 的参数， 它只是与现有的文档进行合并。对象被合并到一起，覆盖现有的字段，增加新的字段。 例如，我们增加字段 tags 和 views 到我们的博客文章，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">   &quot;doc&quot; : &#123;</span><br><span class="line">      &quot;tags&quot; : [ &quot;testing&quot; ],</span><br><span class="line">      &quot;views&quot;: 0</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求成功，我们看到类似于 index 请求的响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;_index&quot; :   &quot;website&quot;,</span><br><span class="line">   &quot;_id&quot; :      &quot;1&quot;,</span><br><span class="line">   &quot;_type&quot; :    &quot;blog&quot;,</span><br><span class="line">   &quot;_version&quot; : 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检索文档显示了更新后的 _source 字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;_index&quot;:    &quot;website&quot;,</span><br><span class="line">   &quot;_type&quot;:     &quot;blog&quot;,</span><br><span class="line">   &quot;_id&quot;:       &quot;1&quot;,</span><br><span class="line">   &quot;_version&quot;:  3,</span><br><span class="line">   &quot;found&quot;:     true,</span><br><span class="line">   &quot;_source&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:  &quot;My first blog entry&quot;,</span><br><span class="line">      &quot;text&quot;:   &quot;Starting to get the hang of this...&quot;,</span><br><span class="line">      &quot;tags&quot;: [ &quot;testing&quot; ],    #新添加</span><br><span class="line">      &quot;views&quot;:  0   #新添加</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部更新文档，<code>update</code> API 结合了先前说明的读取和写入模式：</p><p><img src="https://note.youdao.com/yws/api/personal/file/E5B6A405579E4720854EAFF23B14CC0A?method=getImage&version=7157&cstk=kixc2ey7" alt="局部更新文档"></p><p>以下是部分更新一个文档的步骤：</p><ol><li>客户端向 <code>Node 1</code> 发送更新请求。</li><li>它将请求转发到主分片所在的 <code>Node 3</code> 。</li><li>Node 3 从主分片检索文档，修改 <code>_source</code> 字段中的 <code>JSON</code> ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 <code>retry_on_conflict</code> 次后放弃。</li><li>如果 <code>Node 3</code> 成功地更新文档，它将新版本的文档并行转发到 <code>Node 1</code> 和 <code>Node 2</code> 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， <code>Node 3</code> 向协调节点也返回成功，协调节点向客户端返回成功。</li></ol><p><code>update</code> API 还接受在 新建、索引和删除文档 章节中介绍的 <code>routing</code> 、 <code>replication</code> 、 <code>consistency</code> 和 <code>timeout</code> 参数。</p><blockquote><p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p></blockquote><h5 id="2-2-5-多文档操作"><a href="#2-2-5-多文档操作" class="headerlink" title="2.2.5 多文档操作"></a>2.2.5 多文档操作</h5><p>将多个请求合并成一个，避免单独处理每个请求花费的网络延时和开销。 如果你需要从 Elasticsearch 检索很多文档，那么使用 <code>multi-get</code> 或者 <code>mget</code> API 来将这些检索请求放在一个请求中，将比逐个文档请求更快地检索到全部文档。</p><p><code>mget</code> API 要求有一个 <code>docs</code> 数组作为参数，每个元素包含需要检索文档的元数据， 包括 <code>_index</code> 、 <code>_type</code> 和  <code>_id</code> 。如果你想检索一个或者多个特定的字段，那么你可以通过 <code>_source</code> 参数来指定这些字段的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查询多个文档</span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;blog&quot;,</span><br><span class="line">         &quot;_id&quot; :    2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">         &quot;_type&quot; :  &quot;pageviews&quot;,</span><br><span class="line">         &quot;_id&quot; :    1,</span><br><span class="line">         &quot;_source&quot;: &quot;views&quot; #指定查询字段</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;docs&quot; : [</span><br><span class="line">      &#123; &quot;_id&quot; : 2 &#125;,</span><br><span class="line">      &#123; &quot;_type&quot; : &quot;pageviews&quot;, &quot;_id&quot; :   1 &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">   &quot;ids&quot; : [ &quot;2&quot;, &quot;1&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个文档的检索是异步执行的，相互之间不会有影响。</p><p><img src="https://note.youdao.com/yws/api/personal/file/8D769E5874344107A60A740E11852523?method=getImage&version=7154&cstk=kixc2ey7" alt="获取多文档"></p><p>以下是使用单个 <code>mget</code> 请求取回多个文档所需的步骤顺序：</p><ol><li>客户端向 <code>Node 1</code> 发送 <code>mget</code> 请求。</li><li><code>Node 1</code> 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， <code>Node 1</code> 构建响应并将其返回给客户端。</li></ol><p>可以对 docs 数组中每个文档设置 <code>routing</code> 参数。</p><h5 id="2-2-6-多文档创建、索引、删除和更新"><a href="#2-2-6-多文档创建、索引、删除和更新" class="headerlink" title="2.2.6 多文档创建、索引、删除和更新"></a>2.2.6 多文档创建、索引、删除和更新</h5><p><code>mget</code> 可以使我们一次取回多个文档同样的方式， <code>bulk</code> API 允许在单个步骤中进行多次 <code>create</code> 、 <code>index</code> 、 <code>update</code> 或 <code>delete</code> 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。</p><p>bulk 与其他的请求体格式稍有不同，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body        &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个完整的 bulk 请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125; </span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;:    &quot;My first blog post&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;:  &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;:    &quot;My second blog post&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;title&quot; : &quot;My updated blog post&quot;&#125; &#125; </span><br></pre></td></tr></table></figure><p>每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。 </p><p><code>mget</code> 和 <code>bulk</code> API 的模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。</p><p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p><p><code>bulk</code> API，允许在单个批量请求中执行多个创建、索引、删除和更新请求，如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/019587FBADCB4224812553F474652AB1?method=getImage&version=7158&cstk=kixc2ey7" alt="使用 bulk 修改多个文档"></p><p>bulk API 按如下步骤顺序执行：</p><ol><li>客户端向 Node 1 发送 bulk 请求。</li><li>Node 1 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。</li><li>主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</li></ol><p>bulk API 还可以在整个批量请求的最顶层使用 consistency 参数，以及在每个请求中的元数据中使用 routing 参数。</p><blockquote><p> “为什么 bulk API 需要有换行符的有趣格式，而不是发送包装在 JSON 数组中的请求，例如 mget API？”</p></blockquote><p> 在批量请求中引用的每个文档可能属于不同的主分片， 每个文档可能被分配给集群中的任何节点。这意味着批量请求 bulk 中的每个 操作 都需要被转发到正确节点上的正确分片。</p><p> 如果单个请求被包装在 JSON 数组中，那就意味着我们需要执行以下操作：</p><ol><li>将 JSON 解析为数组（包括文档数据，可以非常大）</li><li>查看每个请求以确定应该去哪个分片</li><li>为每个分片创建一个请求数组</li><li>将这些数组序列化为内部传输格式</li><li>将请求发送到每个分片</li></ol><p>这是可行的，但需要大量的 RAM 来存储原本相同的数据的副本，并将创建更多的数据结构，Java虚拟机（JVM）将不得不花费时间进行垃圾回收。</p><p>相反，Elasticsearch可以直接读取被网络缓冲区接收的原始数据。 它使用换行符字符来识别和解析小的  action&#x2F;metadata 行来决定哪个分片应该处理每个请求。</p><p>这些原始请求会被直接转发到正确的分片。没有冗余的数据复制，没有浪费的数据结构。整个请求尽可能在最小的内存中处理。</p><h2 id="Elasticsearch-搜索"><a href="#Elasticsearch-搜索" class="headerlink" title="Elasticsearch 搜索"></a>Elasticsearch 搜索</h2><p> Elasticsearch 真正强大之处在于可以从无规律的数据中找出有意义的信息——从“大数据”到“大信息”。</p><p> 搜索（search） 可以做到：</p><ul><li>在类似于 gender 或者 age 这样的字段上使用结构化查询，join_date 这样的字段上使用排序，就像SQL的结构化查询一样。</li><li>全文检索，找出所有匹配关键字的文档并按照_相关性（relevance）_ 排序后返回结果。</li><li>以上二者兼而有之。</li></ul><p>关键概念：</p><ul><li>映射（Mapping）<br>描述数据在每个字段内如何存储</li><li>分析（Analysis）<br>全文是如何处理使之可以被搜索的</li><li>领域特定查询语言（Query DSL）<br>Elasticsearch 中强大灵活的查询语言</li></ul><h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><p>搜索API的最基础的形式是没有指定任何查询的空搜索，它简单地返回集群中所有索引下的所有文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure><p>返回的结果（为了界面简洁编辑过的）类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;hits&quot; : &#123;</span><br><span class="line">      &quot;total&quot; :       14,   #匹配到的文档总数</span><br><span class="line">      &quot;hits&quot; : [    #hits 数组包含所查询结果的前十个文档。</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;_index&quot;:   &quot;us&quot;,</span><br><span class="line">          &quot;_type&quot;:    &quot;tweet&quot;,</span><br><span class="line">          &quot;_id&quot;:      &quot;7&quot;,</span><br><span class="line">          &quot;_score&quot;:   1,    #衡量了文档与查询的匹配程度,默认情况下，首先返回最相关的文档结果，即返回的文档是按照 _score 降序排列的，</span><br><span class="line">          &quot;_source&quot;: &#123;</span><br><span class="line">             &quot;date&quot;:    &quot;2014-09-17&quot;,</span><br><span class="line">             &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">             &quot;tweet&quot;:   &quot;The Query DSL is really powerful and flexible&quot;,</span><br><span class="line">             &quot;user_id&quot;: 2</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... 9 RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      &quot;max_score&quot; :   1   #查询所匹配文档的 _score 的最大值</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;took&quot; :           4,    #执行整个搜索请求耗费了多少毫秒</span><br><span class="line">   &quot;_shards&quot; : &#123;    #查询中参与分片的总数和查询情况</span><br><span class="line">      &quot;failed&quot; :      0,</span><br><span class="line">      &quot;successful&quot; :  10,</span><br><span class="line">      &quot;total&quot; :       10</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;timed_out&quot; :      false   #查询是否超时，默认情况下，搜索请求不会超时，可以自定义超时时间 GET /_search?timeout=10ms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多索引、多类型搜索"><a href="#多索引、多类型搜索" class="headerlink" title="多索引、多类型搜索"></a>多索引、多类型搜索</h3><p>在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索，如下所示：</p><ul><li>&#x2F;_search<br>在所有的索引中搜索所有的类型</li><li>&#x2F;gb&#x2F;_search<br>在 gb 索引中搜索所有的类型</li><li>&#x2F;gb,us&#x2F;_search<br>在 gb 和 us 索引中搜索所有的文档</li><li>&#x2F;g*,u*&#x2F;_search<br>在任何以 g 或者 u 开头的索引中搜索所有的类型</li><li>&#x2F;gb&#x2F;user&#x2F;_search<br>在 gb 索引中搜索 user 类型</li><li>&#x2F;gb,us&#x2F;user,tweet&#x2F;_search<br>在 gb 和 us 索引中搜索 user 和 tweet 类型</li><li>&#x2F;_all&#x2F;user,tweet&#x2F;_search<br>在所有的索引中搜索 user 和 tweet 类型</li></ul><p>当然，可以在url后面加上 <code>pretty</code> 提高返回结果的可阅读性，如 <code>/gb/_search?pretty</code></p><p>当在单一的索引下进行搜索的时候，Elasticsearch 转发请求到索引的每个分片中，可以是主分片也可以是副本分片，然后从每个分片中收集结果。多索引搜索恰好也是用相同的方式工作的—只是会涉及到更多的分片。</p><p>tip：搜索一个索引有五个主分片和搜索五个索引各有一个分片准确来所说是等价的。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>默认情况下<code>hits</code> 数组中只有前 10 个文档（有10个或以上的话），要在搜索中显示其余的文档，需要使用分页功能。</p><p>和 SQL 使用 <code>LIMIT</code> 关键字返回单个 <code>page</code> 结果的方法相同，Elasticsearch 接受 <code>from</code> 和 <code>size</code> 参数：</p><ul><li>size<br>显示应该返回的结果数量，默认是 10</li><li>from<br>显示应该跳过的初始结果数量，默认是 0</li></ul><p>如果每页展示 5 条结果，可以用下面方式请求得到 1 到 3 页的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?size=5   #第1页</span><br><span class="line">GET /_search?size=5&amp;from=5    #第2页</span><br><span class="line">GET /_search?size=5&amp;from=10   #第3页</span><br></pre></td></tr></table></figure><h3 id="轻量搜索"><a href="#轻量搜索" class="headerlink" title="轻量搜索"></a>轻量搜索</h3><p>两种形式的搜索 API：</p><ol><li><p>“轻量的” 查询字符串 版本<br>使用 Get 请求，参数通过url传递</p></li><li><p>请求体 版本<br>使用 Post 请求，使用 JSON 格式和更丰富的查询表达式作为搜索语言</p></li></ol><p>现介绍轻量搜索</p><p>查询字符串搜索非常适用于通过命令行做即席查询（用户自定义查询条件）。例如，查询在 <code>tweet</code> 类型中 <code>tweet</code> 字段包含 <code>elasticsearch</code> 单词的所有文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_all/tweet/_search?q=tweet:elasticsearch</span><br></pre></td></tr></table></figure><p>查询在 name 字段中包含 john 并且在 tweet 字段中包含 mary 的文档，实际的地址是这样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary   #在url编码中，%2B为“+”，%3A为“:”</span><br></pre></td></tr></table></figure><p>+ 前缀表示必须与查询条件匹配。类似地， - 前缀表示一定不与查询条件匹配。没有 + 或者 - 的所有其他条件都是可选的——匹配的越多，文档就越相关。</p><h4 id="all-字段"><a href="#all-字段" class="headerlink" title="_all 字段"></a><code>_all</code> 字段</h4><p>查询字段值中存在mary的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=mary</span><br></pre></td></tr></table></figure><p>其实，当索引一个文档的时候，Elasticsearch 取出所有字段的值拼接成一个大的字符串，作为 <code>_all</code> 字段进行索引。相当于增加了一个名叫 <code>_all</code> 的额外字段，所以如果不指定字段名，将会匹配 <code>_all</code>字段，也即匹配所有字段。</p><p>例如，当索引这个文档时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tweet&quot;:    &quot;However did I manage before Elasticsearch?&quot;,</span><br><span class="line">    &quot;date&quot;:     &quot;2014-09-14&quot;,</span><br><span class="line">    &quot;name&quot;:     &quot;Mary Jones&quot;,</span><br><span class="line">    &quot;user_id&quot;:  1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就好似增加了一个名叫 _all 的额外字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;_all&quot;: &quot;However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1&quot;</span><br></pre></td></tr></table></figure><p>当然，也可以设置 <code>_all</code> 字段无效。</p><h4 id="更复杂一点的查询"><a href="#更复杂一点的查询" class="headerlink" title="更复杂一点的查询"></a>更复杂一点的查询</h4><p>下面的查询针对 <code>tweents</code> 类型，并使用以下的条件：</p><ul><li>name 字段中包含 mary 或者 john</li><li>date 值大于 2014-09-10</li><li>_all 字段包含 aggregations 或者 geo<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># GET /_all/tweents/_search?q=+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</span><br><span class="line">GET /_all/tweents/_search?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</span><br></pre></td></tr></table></figure></li></ul><p>Get查询虽然比较简洁轻量，但是可读性很差，难以扩展，不好维护，主要是用于开发测试和简单的查询，生产环境中更多地使用功能全面的 request body 查询API</p><h2 id="分析和映射"><a href="#分析和映射" class="headerlink" title="分析和映射"></a>分析和映射</h2><h3 id="精确值和全文"><a href="#精确值和全文" class="headerlink" title="精确值和全文"></a>精确值和全文</h3><p>Elasticsearch 中的数据可以概括的分为两类：精确值和全文</p><p>精确值如日期、数字等数据，字符串也可以作为精确值。对于精确值来讲，Foo 和 foo 是不同的，2014 和 2014-09-15 也是不同的。</p><p>全文通常是指非结构化的数据，例如一个推文的内容或一封邮件的内容。</p><p>精确值很容易查询。结果是二进制的：要么匹配查询，要么不匹配。这种查询很容易用 SQL 表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHERE name    = &quot;John Smith&quot;</span><br><span class="line">  AND user_id = 2</span><br><span class="line">  AND date    &gt; &quot;2014-09-15&quot;</span><br></pre></td></tr></table></figure><p>我们很少对全文类型的域做精确匹配。相反，我们希望在文本类型的域中搜索。不仅如此，我们还希望搜索能够理解我们的 意图 ：</p><ul><li>搜索 <code>UK</code> ，会返回包含 <code>United Kindom</code> 的文档。</li><li>搜索 <code>jump</code> ，会匹配 <code>jumped</code> ， <code>jumps</code> ， <code>jumping</code> ，甚至是 <code>leap</code> 。</li><li>搜索 <code>johnny walker</code> 会匹配 <code>Johnnie Walker</code> ， <code>johnnie depp</code> 应该匹配 <code>Johnny Depp</code> 。</li><li><code>fox news hunting</code> 应该返回福克斯新闻（ Foxs News ）中关于狩猎的故事，同时， <code>fox hunting news</code> 应该返回关于猎狐的故事。</li></ul><p>Elasticsearch 使用到排索引完成这类查询。</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>Elasticsearch 使用一种称为 倒排索引 的结构，它适用于快速的全文搜索。一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。</p><p>例如，假设我们有两个文档，每个文档的 content 域包含如下内容：</p><ol><li>The quick brown fox jumped over the lazy dog</li><li>Quick brown foxes leap over lazy dogs in summer</li></ol><p>为了创建倒排索引，我们首先将每个文档的 content 域拆分成单独的 词（我们称它为 词条 或 tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2  </span><br><span class="line">-------------------------  </span><br><span class="line">Quick   |       |  X </span><br><span class="line">The     |   X   |</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |</span><br><span class="line">dogs    |       |  X</span><br><span class="line">fox     |   X   |</span><br><span class="line">foxes   |       |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jumped  |   X   |</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">leap    |       |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><p>现在，如果我们想搜索 quick brown ，我们只需要查找包含每个词条的文档：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TermTerm      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1     </span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">quick   |   X   |</span><br><span class="line">------------------------</span><br><span class="line">Total   |   2   |  1</span><br></pre></td></tr></table></figure><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单 相似性算法 ，那么，我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p><p>但是，我们目前的倒排索引有一些问题：</p><ul><li>Quick 和 quick 以独立的词条出现，然而用户可能认为它们是相同的词。</li><li>fox 和 foxes 非常相似, 就像 dog 和 dogs ；他们有相同的词根。</li><li>jumped 和 leap, 尽管没有相同的词根，但他们的意思很相近。他们是同义词。</li></ul><p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p><p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p><ul><li>Quick 可以小写化为 quick 。</li><li>foxes 可以 词干提取 –变为词根的格式– 为 fox 。类似的， dogs 可以为提取为 dog 。</li><li>jumped 和 leap 是同义词，可以索引为相同的单词 jump 。</li></ul><p>现在索引看上去像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">brown   |   X   |  X</span><br><span class="line">dog     |   X   |  X</span><br><span class="line">fox     |   X   |  X</span><br><span class="line">in      |       |  X</span><br><span class="line">jump    |   X   |  X</span><br><span class="line">lazy    |   X   |  X</span><br><span class="line">over    |   X   |  X</span><br><span class="line">quick   |   X   |  X</span><br><span class="line">summer  |       |  X</span><br><span class="line">the     |   X   |  X</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure><p>这还远远不够。我们搜索 +Quick +fox 仍然 会失败，因为在我们的索引中，已经没有 Quick 了。但是，如果我们对搜索的字符串使用与 content 域相同的标准化规则，会变成查询 +quick +fox ，这样两个文档都会匹配！</p><p>分词和标准化的过程称为 分析。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析是决定文档如何被搜索到的方式。</p><p>分析 包含下面的过程：</p><ul><li>首先，将一块文本分成适合于倒排索引的独立的 词条 ，</li><li>之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall</li></ul><p>分析器执行上面的工作。 分析器 实际上是将三个功能封装到了一个包里：</p><ol><li>字符过滤器<br>首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 &amp; 转化成 and。</li><li>分词器<br>其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li><li>Token 过滤器<br>最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像 jump 和 leap 这种同义词）。</li></ol><p>Elasticsearch提供了开箱即用的字符过滤器、分词器和token 过滤器。 这些可以组合起来形成自定义的分析器以用于不同的目的。</p><h4 id="内置分析器"><a href="#内置分析器" class="headerlink" title="内置分析器"></a>内置分析器</h4><p>Elasticsearch 内置了常用的分析器。用下面字符串举例：</p><p><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p><p>使用不同的分析器将会得到不同的结果：</p><h5 id="1-标准分析器"><a href="#1-标准分析器" class="headerlink" title="1. 标准分析器"></a>1. 标准分析器</h5><p>标准分析器是Elasticsearch默认使用的分析器。它是分析各种语言文本最常用的选择。它根据 Unicode 联盟 定义的 单词边界 划分文本。删除绝大部分标点。最后，将词条小写。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set_trans, 5</span><br></pre></td></tr></table></figure><h5 id="2-简单分析器"><a href="#2-简单分析器" class="headerlink" title="2. 简单分析器"></a>2. 简单分析器</h5><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set, the, shape, to, semi, transparent, by, calling, set, trans</span><br></pre></td></tr></table></figure><h5 id="3-空格分析器"><a href="#3-空格分析器" class="headerlink" title="3. 空格分析器"></a>3. 空格分析器</h5><p>空格分析器在空格的地方划分文本。它会产生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</span><br></pre></td></tr></table></figure><h5 id="4-语言分析器"><a href="#4-语言分析器" class="headerlink" title="4. 语言分析器"></a>4. 语言分析器</h5><p>特定语言分析器可用于 很多语言。它们可以考虑指定语言的特点。例如， 英语 分析器附带了一组英语无用词（常用单词，例如 and 或者 the ，它们对相关性没有多少影响），它们会被删除。 由于理解英语语法的规则，这个分词器可以提取英语单词的 词干 。</p><p>英语 分词器会产生下面的词条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># transparent、 calling 和 set_trans 已经变为词根格式。</span><br><span class="line">set, shape, semi, transpar, call, set_tran, 5</span><br></pre></td></tr></table></figure><h4 id="测试分析器"><a href="#测试分析器" class="headerlink" title="测试分析器"></a>测试分析器</h4><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用 analyze API 来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Text to analyze&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果中每个元素代表一个单独的词条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;tokens&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;text&quot;,    #实际存储到索引中的词条</span><br><span class="line">         &quot;start_offset&quot;: 0,     #指明字符在原始字符串中的开始位置</span><br><span class="line">         &quot;end_offset&quot;:   4,     #指明字符在原始字符串中的结束位置</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     1      #指明词条在原始文本中出现的位置</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;to&quot;,</span><br><span class="line">         &quot;start_offset&quot;: 5,</span><br><span class="line">         &quot;end_offset&quot;:   7,</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;token&quot;:        &quot;analyze&quot;,</span><br><span class="line">         &quot;start_offset&quot;: 8,</span><br><span class="line">         &quot;end_offset&quot;:   15,</span><br><span class="line">         &quot;type&quot;:         &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">         &quot;position&quot;:     3</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在在映射中指定分析器。</p><h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p>映射定义了文档结构，类似与关系数据库中的表结构概念。</p><p>在 Elasticsearch 中，索引中每个文档都有 <strong>类型</strong> 。每种类型都有它自己的 <strong>映射</strong>。映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p><p>注：“域”指的是数据类型、属性，比如时间域、数字域、字符串域</p><h4 id="核心简单域类型"><a href="#核心简单域类型" class="headerlink" title="核心简单域类型"></a>核心简单域类型</h4><p>Elasticsearch 支持如下简单域类型：</p><ul><li>字符串: string</li><li>整数 : byte, short, integer, long</li><li>浮点数: float, double</li><li>布尔型: boolean</li><li>日期: date</li></ul><p>索引（创建）一个包含新域的文档—之前未曾出现– Elasticsearch 会使用 动态映射 ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p><table><thead><tr><th>JSON type</th><th>域 type</th></tr></thead><tbody><tr><td>布尔型: true 或者 false</td><td>boolean</td></tr><tr><td>整数: 123</td><td>long</td></tr><tr><td>浮点数: 123.45</td><td>double</td></tr><tr><td>字符串，有效日期: 2014-09-15</td><td>date</td></tr><tr><td>字符串: foo bar</td><td>string</td></tr></tbody></table><blockquote><p>这意味着如果你通过引号( “123” )索引一个数字，它会被映射为 string 类型，而不是 long 。但是，如果这个域已经映射为 long ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p></blockquote><h4 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h4><p>通过 <code>/_mapping</code> ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射。比如获取索引 <code>gb</code> 中类型 <code>tweet</code> 的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br></pre></td></tr></table></figure><p>Elasticsearch 根据我们索引的文档，为域(称为 属性 )动态生成的映射:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;gb&quot;: &#123;</span><br><span class="line">      &quot;mappings&quot;: &#123;</span><br><span class="line">         &quot;tweet&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">               &quot;date&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">                  &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;name&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;tweet&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;string&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;user_id&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;long&quot;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义域映射"><a href="#自定义域映射" class="headerlink" title="自定义域映射"></a>自定义域映射</h4><p>尽管在很多情况下基本域数据类型已经够用，但你经常需要为单独域自定义映射，特别是字符串域。自定义映射允许你执行下面的操作：</p><ul><li>全文字符串域和精确值字符串域的区别</li><li>使用特定语言分析器</li><li>优化域以适应部分匹配</li><li>指定自定义数据格式</li><li>更多</li></ul><p>域最重要的属性是 <code>type</code> 。对于不是 <code>string</code> 的域，一般只需要设置 <code>type</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认， <code>string</code> 类型域会被认为包含全文。就是说，它们的值在索引前，会通过一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p><p><code>string</code> 域映射的两个最重要属性是 <code>index</code> 和 <code>analyzer</code> 。</p><h5 id="index"><a href="#index" class="headerlink" title="index"></a>index</h5><p>index 属性控制怎样索引字符串。它可以是下面三个值：<br>    1. analyzed<br>    首先分析字符串，然后索引它。换句话说，以全文索引这个域。<br>    2. not_analyzed<br>    索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。<br>    3. no<br>    不索引这个域。这个域不会被搜索到。</p><p><code>string</code> 域 <code>index</code> 属性默认是 <code>analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 <code>not_analyzed</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tag&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">        &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他简单类型（例如 long ， double ， date 等）也接受 <code>index</code> 参数，但有意义的值只有 <code>no</code> 和 <code>not_analyzed</code> ， 因为它们永远不会被分析，总是使用精确匹配。</p><h5 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h5><p>对于 <code>analyzed</code> 字符串域，用 <code>analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code>standard</code> 分析器， 但你可以指定一个内置的分析器替代它，例如 <code>whitespace</code> 、 <code>simple</code> 和 <code>english</code>，当然也可以自定义分析器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tweet&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">        &quot;index&quot;:     &quot;analyzed&quot;,</span><br><span class="line">        &quot;analyzer&quot;:    &quot;english&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h4><p>首次创建一个索引的时候，可以指定类型的映射。也可以使用 <code>_mapping</code> 为新类型增加映射或者为已存在的类型更新映射。</p><p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 analyzed 改为 not_analyzed 。</p><p>创建一个新索引，指定 tweet 域使用 english 分析器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb </span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;tweet&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :    &quot;string&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;date&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;date&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;name&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;string&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user_id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; :   &quot;long&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新这个索引的类型的映射，<code>tweet</code> 映射增加一个新的名为 <code>tag</code> 的 <code>not_analyzed</code> 的文本域，使用 <code>_mapping</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot; : &#123;</span><br><span class="line">    &quot;tag&quot; : &#123;</span><br><span class="line">      &quot;type&quot; :    &quot;string&quot;,</span><br><span class="line">      &quot;index&quot;:    &quot;not_analyzed&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能修改和删除映射已存在域，只能新增域。</p><h4 id="测试映射"><a href="#测试映射" class="headerlink" title="测试映射"></a>测试映射</h4><p>使用 analyze API 测试字符串域的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;name&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /gb/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;tag&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Black-cats&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>name</code> 域产生两个词条 <code>black</code> 和 <code>cat</code>（分词） ， <code>tag</code> 域产生单独的词条 <code>Black-cats</code> （不分词）。换句话说，我们的映射正常工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在做skywalking相关的项目，skywalking使用了Elasticsearch对数据指标进行存取，要理解skywalking的工程项目，就需要对 Elasticsearch 有一定的了解。&lt;/p&gt;
&lt;p&gt;转载自 &lt;a href=&quot;https://www.jia</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="database" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/"/>
    
    <category term="es" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/database/es/"/>
    
    
    <category term="Elasticsearch学习" scheme="https://tianxiafeiyu.github.io/tags/Elasticsearch%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>websocket学习</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/websocket%E5%AD%A6%E4%B9%A0/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/websocket%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSocke简述"><a href="#WebSocke简述" class="headerlink" title="WebSocke简述"></a>WebSocke简述</h2><p>随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。</p><p>　　我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和Comet技术。其实后者本质上也是一种轮询，只不过有所改进。</p><p>　　轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p><p>　　Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p><p>　　这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。</p><p>　　伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B&#x2F;S模式具备了C&#x2F;S模式的实时通信能力。WebSocket的工作流程是这 样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小 了很多　　</p><ul><li><p>WebSocke是 HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p></li><li><p>WebSocket协议是基于TCP的一种新的网络协议，是一个应用层协议，是TCP&#x2F;IP协议的子集。</p></li><li><p>它实现了浏览器与服务器全双工（full-duplex）通信，客户端和服务器都可以向对方主动发送和接收数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p></li><li><p>在JS中创建WebSocket后，会有一个HTTP请求从浏览器发向服务器。在取得服务器响应后，建立的连接会使用HTTP升级将HTTP协议转换为WebSocket协议。也就是说，使用标准的HTTP协议无法实现WebSocket，只有支持那些协议的专门浏览器才能正常工作。由于WebScoket使用了自定义协议，所以URL与HTTP协议略有不同。未加密的连接为ws:&#x2F;&#x2F;，而不是http:&#x2F;&#x2F;。加密的连接为wss:&#x2F;&#x2F;，而不是https:&#x2F;&#x2F;，所以如果你的项目使用了网关，又想使用WebSocket，在网关转发这方面，就会遇到问题。</p></li></ul><h2 id="WebSocket特点"><a href="#WebSocket特点" class="headerlink" title="WebSocket特点"></a>WebSocket特点</h2><p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p><p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送文本，也可以发送二进制数据。</p><p>（5）没有同源限制，客户端可以与任意服务器通信。</p><p>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。如 <code>ws:localhost:80\test</code></p><h2 id="gorilla-x2F-websocket-介绍"><a href="#gorilla-x2F-websocket-介绍" class="headerlink" title="gorilla&#x2F;websocket 介绍"></a>gorilla&#x2F;websocket 介绍</h2><p><a href="https://github.com/gorilla/websocket">https://github.com/gorilla/websocket</a></p><p>这是一个封装了go原生websocket的库。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>创建websocket连接地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(&quot;/ws&quot;, serveWs)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func serveWs(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">ws, err := upgrader.Upgrade(w, r, nil)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(&quot;upgrade:&quot;, err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer ws.Close()</span><br><span class="line">    //...</span><br><span class="line">    // 数据写入，发送消息</span><br><span class="line">    ws.WriteMessage(websocket.TextMessage, s.Bytes())</span><br><span class="line">    // 数据读取，接受消息</span><br><span class="line">    _, message, err := ws.ReadMessage()</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><ol><li>聊天室</li><li>c&#x2F;s 架构使用websocket通信</li><li>文件监听</li><li>远程命令</li></ol><h2 id="WebSocket网关"><a href="#WebSocket网关" class="headerlink" title="WebSocket网关"></a>WebSocket网关</h2><p>如果是全新的服务和架构，原生支持websocket固然值最好的</p><p>痛点：</p><ol><li>新服务需要考虑到ws部分的实现和支持；前后端对接增加工作</li><li>不能使用原先的框架快速开发</li><li>旧服务设计之初就不支持ws，服务多，需要重新对接，容易改动引发，改造耗时耗力</li></ol><p>如果存在这样一个服务：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WebSocke简述&quot;&gt;&lt;a href=&quot;#WebSocke简述&quot; class=&quot;headerlink&quot; title=&quot;WebSocke简述&quot;&gt;&lt;/a&gt;WebSocke简述&lt;/h2&gt;&lt;p&gt;随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="websocket学习" scheme="https://tianxiafeiyu.github.io/tags/websocket%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>交换机端口标识含义</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="交换机端口标识含义"><a href="#交换机端口标识含义" class="headerlink" title="交换机端口标识含义"></a>交换机端口标识含义</h4><ul><li>FastEthernet 百兆端口</li><li>GigabitEthernet 千兆端口</li><li>TenGigabitEthernet 万兆端口</li><li>vlan 逻辑端口，划分物理端口的逻辑分区</li><li>StackSub 堆叠端口，支持堆叠的交换机一般有专门的堆叠模块和端口<br>堆叠是指将一台以上的交换机组合起来共同工作，以便在有限的空间内提供尽可能多的端口。</li><li>Port-channel 加入port group 中的物理端口满足某种条件时进行端口汇聚，形成一个port channel。所以Port-channel是逻辑端口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;交换机端口标识含义&quot;&gt;&lt;a href=&quot;#交换机端口标识含义&quot; class=&quot;headerlink&quot; title=&quot;交换机端口标识含义&quot;&gt;&lt;/a&gt;交换机端口标识含义&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;FastEthernet 百兆端口&lt;/li&gt;
&lt;li&gt;GigabitEt</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="交换机端口标识含义" scheme="https://tianxiafeiyu.github.io/tags/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%AB%AF%E5%8F%A3%E6%A0%87%E8%AF%86%E5%90%AB%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>基于etcd实现的分布式锁</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>lock.sh<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @CreateTime:   2021-03-23 16:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Description:  分布式锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @Note:         在axis中实现分布式锁时，由于Python的语言特性，导致性能特别差；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此这里直接基于etcd进行实现，对性能有大幅提升！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁名</span></span><br><span class="line"></span><br><span class="line">LOCK\_NAME=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话超时时间，即服务异常退出时锁的最长自动释放时间，单位/秒</span></span><br><span class="line"></span><br><span class="line">TTL=30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否本地锁，如果是本地锁，那么作用和flock类似，不会对集群的其他节点造成影响</span></span><br><span class="line"></span><br><span class="line">IS\_LOCAL=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 待执行命令</span></span><br><span class="line"></span><br><span class="line">COMMAND=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接|获取锁|释放锁的超时时间，单位/秒</span></span><br><span class="line"></span><br><span class="line">TIMEOUT=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否输出调试信息</span></span><br><span class="line"></span><br><span class="line">DEBUG=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 用法说明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: dlock \[-n|--name] \[-t|--ttl] \[-w|--timeout] \[-l|--local] \[-d|--debug] \[-h|--help] \&lt;command&gt; \[command args]&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Options:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -n  --name        锁名，默认为被执行命令名&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -t  --ttl         会话超时时间，即服务异常退出时锁的最长自动释放时间，单位/秒&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -w  --timeout     连接超时时间，单位/秒&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -l  --local       本地锁，类似flock&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -d  --debug       输出调试信息&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;  -h  --help        输出帮助信息并退出&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 解析命令行参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> parse\_cmdline\<span class="function"><span class="title">_args</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">local</span> parsed\_args</span><br><span class="line">parsed\_args=`$(getopt -a -n dlock -o n:t:w:ldh --long name:,ttl:,<span class="built_in">timeout</span>:,<span class="built_in">local</span>,debug,<span class="built_in">help</span> -- <span class="string">&quot;$`@&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> \[ \$? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">usage</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span> <span class="built_in">set</span> -- <span class="string">&quot;<span class="variable">$parsed_args</span>&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">            -n | --name)    LOCK_NAME=<span class="string">&quot;<span class="variable">$2</span>&quot;</span>         ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -t | --ttl)     TTL=<span class="variable">$2</span>                 ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -w | --<span class="built_in">timeout</span>) TIMEOUT=<span class="variable">$2</span>             ; <span class="built_in">shift</span> 2  ;;</span><br><span class="line">            -l | --<span class="built_in">local</span>)   IS_LOCAL=<span class="literal">true</span>          ; <span class="built_in">shift</span>    ;;</span><br><span class="line">            -d | --debug)   DEBUG=<span class="literal">true</span>             ; <span class="built_in">shift</span>    ;;</span><br><span class="line">            -h | --<span class="built_in">help</span>)    usage ;;</span><br><span class="line">            --)             <span class="built_in">shift</span>; <span class="built_in">break</span> ;;</span><br><span class="line">            *)              usage ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 剩余参数就当做被执行命令看待</span></span><br><span class="line">    COMMAND=<span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$COMMAND</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        usage</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数: 主函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">parse\_cmdline\_args <span class="string">&quot;\$@&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 未指定锁名的情况下，默认使用可执行文件作为锁名</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$LOCK_NAME</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        LOCK_NAME=$(<span class="built_in">echo</span> <span class="variable">$COMMAND</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为本地锁的情况下，使用主机名作为锁名前缀</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$IS_LOCAL</span> = <span class="literal">true</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> hostname</span><br><span class="line">        hostname=$(hostname)</span><br><span class="line">        LOCK_NAME=<span class="string">&quot;<span class="variable">$hostname</span>/<span class="variable">$LOCK_NAME</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目前基于etcd来实现分布式锁</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$TIMEOUT</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">export</span> ETCDCTL_CONNECTION_TIMEOUT=<span class="variable">$TIMEOUT</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 需要把etcdctl的第一行warning日志去掉或者过滤掉</span></span><br><span class="line">    /sf/bin/etcdctl lock --debug=<span class="variable">$DEBUG</span> --ttl=<span class="variable">$TTL</span> <span class="string">&quot;<span class="variable">$LOCK_NAME</span>&quot;</span> <span class="variable">$COMMAND</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main <span class="string">&quot;\$@&quot;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;lock.sh&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="基于etcd实现的分布式锁" scheme="https://tianxiafeiyu.github.io/tags/%E5%9F%BA%E4%BA%8Eetcd%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法---常见算法减治、分治、递归、迭代、回溯、动态规划、贪心的基本思想</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95---%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/cqfdcw/article/details/100063987">https://blog.csdn.net/cqfdcw/article/details/100063987</a></p><h4 id="一、减而治之"><a href="#一、减而治之" class="headerlink" title="一、减而治之"></a>一、减而治之</h4><p>减而治之与分而治之都是递归中常用的算法策略。其中减而治之是将一个大规模的问题，将其划分为两个子问题，其一是平凡问题，另一个规模缩减。递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡问题。</p><p>应用举例1：求解数组元素的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n&lt;<span class="number">1</span>)?<span class="number">0</span>:sum(A,n-<span class="number">1</span>)+A[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：数组中元素倒置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为得到整个数组的倒置，可以先对换其首、末元素，然后递归地倒置除这两个元素以外的部分。</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> lo, <span class="type">int</span> hi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo &lt; hi) &#123;</span><br><span class="line">        swap(A[lo],A[hi]);</span><br><span class="line">        reverse(A, lo + <span class="number">1</span>, hi - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、分而治之"><a href="#二、分而治之" class="headerlink" title="二、分而治之"></a>二、分而治之</h4><p>可以将其划分为多个（通常情况下为两个）子问题，两个问题的规模大体相同。由子问题的解，通过递归得到原问题的解。</p><p>应用举例1：求解数组元素的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (low == high) ? A[low] : sum(A, low, (low + high) &gt;&gt; <span class="number">1</span>) + sum(A, ((low + high) &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(vector&lt;T&gt; &amp;arr, <span class="type">int</span> L, <span class="type">int</span> mid, <span class="type">int</span> R)</span> &#123;  <span class="comment">//有序向量的逐层归并</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp;   <span class="comment">//临时变量用来存放本次合并后的数组</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">temp.push_back(arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的循环退出后，把剩余的元素依次填入到temp中，只有一个while会执行</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">temp.push_back(arr[p1++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">temp.push_back(arr[p2++]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把最终的排序的结果复制给原数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.size(); i++) &#123;</span><br><span class="line">arr[L + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(vector&lt;T&gt; &amp;arr , <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123; <span class="comment">//无序向量的逐层分解</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;  <span class="comment">//只有一个元素的时候返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">mergeSort(arr, L, mid);  </span><br><span class="line">mergeSort(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、递归与迭代"><a href="#三、递归与迭代" class="headerlink" title="三、递归与迭代"></a>三、递归与迭代</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>重复调用函数自身实现循环，A函数调用A函数。简而言之，通过不断地深层调用函数，直到函数有返回才会逐层的返回，把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解(子问题须与原始问题为同样的事，且更为简单)；递归是用栈机制实现的，每深入一层，都要占去一块栈数据区域。</p><p>应用举例1：二叉树的先序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sytem.out.println(node.val);</span><br><span class="line">    preorder(node.left);</span><br><span class="line">    preorder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用举例2：递归求阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>利用变量的原值推出新值称为迭代，或着说迭代是函数内某段代码实现循环，A函数调用B函数；每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。重复执行一系列运算步骤，从前面的量依次求出后面的量的过程。</p><p>应用举例1：迭代法求阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代   阶乘</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归与迭代比较"><a href="#递归与迭代比较" class="headerlink" title="递归与迭代比较"></a>递归与迭代比较</h4><p>递归满足条件后，逐层返回，每层都计算完后才返回结果；迭代满足条件后，通过计数器结束循环，直接返回计算结果。 递归与迭代相比较，递归的效率较低。</p><ul><li>| 定义 | 优点 | 缺点<br>—|— | —|—<br>递归 |重复调用函数自身实现循环|a.用有限的循环语句实现无限集合；b.代码易读；c.大问题转化成小问题，减少了代码量。|a.递归不断调用函数，浪费空间；b.容易造成堆栈溢出<br>迭代 |利用变量的原值推出新值；函数内某段代码实现循环。|a.效率高，运行时间只随循环的增加而增加；b.无额外开销。|a.代码难理解；b.代码不如递归代码简洁；c.编写复杂问题时，代码逻辑不易想出<br>关系|a.递归中一定有迭代，但是迭代中不一定有递归；大部分可以相互转换。b.相对来说，能用迭代不用递归（因为递归不断调用函数，浪费空间，容易造成堆栈溢出）||</li></ul><h4 id="四、回溯"><a href="#四、回溯" class="headerlink" title="四、回溯"></a>四、回溯</h4><p>又称为试探法，可以理解为尝试不同岔路口，遇到错误原路返回到岔路口走另外一条路，当解决问题的每一步都有多种选择时候，在某一步选择了其中一个选项时，则进入此选项，然后继续新的选择。若选择符合题目要求则此选择是正确的；若此选择不符合题目要求则此选择是不正确的，此时就需要(递归)返回上一步，重新进行选择。</p><p>回溯法说白了就是穷举法。回溯法一般用递归来解决。</p><p>回溯法通常要确定三个要素：</p><ol><li><p>选择<br> 对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列</p></li><li><p>条件<br> 对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。</p></li><li><p>结束<br> 当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。</p></li></ol><p>回溯法中，递归函数的设计需要遵循以下四个原则：</p><ol><li><p>必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。</p></li><li><p>可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。</p></li><li><p>最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。</p></li><li><p>要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。</p></li></ol><h4 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h4><h5 id="题目1：给出n对括号，打印出所有可能的括号排列序列。"><a href="#题目1：给出n对括号，打印出所有可能的括号排列序列。" class="headerlink" title="题目1：给出n对括号，打印出所有可能的括号排列序列。"></a>题目1：给出n对括号，打印出所有可能的括号排列序列。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackTracking</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> leftnum=n,rightnum=n;<span class="comment">//左括号和右括号都各有n个</span></span><br><span class="line">ArrayList&lt;String&gt; results=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//用于存放解空间</span></span><br><span class="line">parentheses(<span class="string">&quot;&quot;</span>, results, leftnum, rightnum);</span><br><span class="line"><span class="keyword">for</span>(String s:results)</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parentheses</span><span class="params">(String sublist, ArrayList&lt;String&gt; results, <span class="type">int</span> leftnum, <span class="type">int</span> rightnum)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(leftnum==<span class="number">0</span>&amp;&amp;rightnum==<span class="number">0</span>)<span class="comment">//结束</span></span><br><span class="line">results.add(sublist);</span><br><span class="line"><span class="keyword">if</span>(rightnum&gt;leftnum)<span class="comment">//选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间</span></span><br><span class="line">parentheses(sublist+<span class="string">&quot;)&quot;</span>, results, leftnum, rightnum-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(leftnum&gt;<span class="number">0</span>)</span><br><span class="line">parentheses(sublist+<span class="string">&quot;(&quot;</span>, results, leftnum-<span class="number">1</span>, rightnum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应回溯法三要素：</p><ol><li>选择。在这个例子中，解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号。</li><li>条件。在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于0才能放入左括号。这里if的顺序会影响输出的顺序，但是不影响最终解。</li><li>结束。这里的结束条件很显然就是，左右括号都放完了。</li></ol><p>对应回溯法递归函数参数设计：</p><ol><li>用了一个空字符串来作为临时变量存储不完整解。</li><li>用了一个ArrayList<String> results来存放符合要求的解。在后面可以看到，不一定要这样做，也可以直接打印结果。</li><li>把leftnum和rightnum传入给递归函数，这样可以用于判断结束条件。</li><li>这个例子不明显。但是事实上也符合这个条件。可以仔细观察代码，可以发现由于使用了两个if，所以当一次递归退出后，例如从第一个if退出，第二个递归直接递归的是leftnum-1和rightnum，这其实是已经恢复状态了（如果没有恢复状态，那就是leftnum, rightnum-1）。因此不需要人为让他恢复状态。但是恢复状态这点是很重要的，因为回溯法，顾名思义要回溯，不恢复状态，怎么回溯呢。</li></ol><h5 id="题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于-该目标的组合（数字不同组合顺序当做一个解）。"><a href="#题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于-该目标的组合（数字不同组合顺序当做一个解）。" class="headerlink" title="题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于 该目标的组合（数字不同组合顺序当做一个解）。"></a>题目2：给出包含一个不重复且大于0数字的数组和一个目标，求数组中数的和等于 该目标的组合（数字不同组合顺序当做一个解）。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackTracking</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> target=<span class="number">9</span>;</span><br><span class="line">find(num, target, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] num, <span class="type">int</span> target, String temp)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(issolution(temp,target))&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(num[i]!=-<span class="number">1</span>)&#123;<span class="comment">//如果取过这个数字了，就置为-1</span></span><br><span class="line"><span class="type">int</span> k=num[i];</span><br><span class="line">num[i]=-<span class="number">1</span>;</span><br><span class="line">find(num, target, temp+k);</span><br><span class="line">num[i]=k;   <span class="comment">//在递归后，必须把数组恢复。这也是参数的特征的第四点所说的内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">issolution</span><span class="params">(String temp, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"><span class="type">boolean</span> result=<span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.length();i++)&#123;</span><br><span class="line">count=count+Integer.valueOf(temp.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==target)</span><br><span class="line">result=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目3：给一个字符串-字符不重复，给出他的所有排列"><a href="#题目3：给一个字符串-字符不重复，给出他的所有排列" class="headerlink" title="题目3：给一个字符串,字符不重复，给出他的所有排列"></a>题目3：给一个字符串,字符不重复，给出他的所有排列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BackTracking &#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">String s=&quot;abc&quot;;</span><br><span class="line">pailie(s,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void pailie(String s, String temp)&#123;//参数设计地尽量地简洁</span><br><span class="line">if(s.length()==0)&#123;</span><br><span class="line">System.out.println(temp);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">String news=s.substring(0, i)+s.substring(i+1,s.length());//去掉String中的某个字母</span><br><span class="line">pailie(news, temp+s.charAt(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="题目4："><a href="#题目4：" class="headerlink" title="题目4："></a>题目4：</h5><h4 id="五、贪心算法"><a href="#五、贪心算法" class="headerlink" title="五、贪心算法"></a>五、贪心算法</h4><p>在对问题进行求解时，总是做出当前看来是最好的选择的一种方法，从而希望能够导致结果是最好或者最优的算法(可能是局部最优解也可能是全局最优解)。是动态规划的一种特例，能用贪心解决的问题，也可以用动态规划解决。</p><h4 id="六、动态规划"><a href="#六、动态规划" class="headerlink" title="六、动态规划"></a>六、动态规划</h4><p>动态规划的实质是分治思想和解决冗余，是一种将问题实例分解为更小的、相似的子问题，求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，避免计算重复的子问题，以解决最优化问题的算法策略。（可分为多个相关子问题，子问题的解被重复使用）。</p><p>[]: <a href="https://blog.csdn.net/cqfdcw/article/details/100063987">https://blog.csdn.net/cqfdcw/article/details/100063987</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net/cqfdcw/article/details/100063987&quot;&gt;https://blog.csdn.net/cqfdcw/article/details/100063987&lt;/a&gt;&lt;/p&gt;
&lt;h4 i</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="数据结构与算法---常见算法减治、分治、递归、迭代、回溯、动态规划、贪心的基本思想【转】" scheme="https://tianxiafeiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%87%8F%E6%B2%BB%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%81%E8%BF%AD%E4%BB%A3%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81%E8%B4%AA%E5%BF%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E3%80%90%E8%BD%AC%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>火焰图怎么看</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/</id>
    <published>2022-12-15T23:41:44.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “平顶”（plateaus），就表示该函数可能存在性能问题。</p><p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “平顶”（plateaus），就表示该函数可能存在性能问题。</p><p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。&lt;/p&gt;
&lt;p&gt;x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="火焰图怎么看" scheme="https://tianxiafeiyu.github.io/tags/%E7%81%AB%E7%84%B0%E5%9B%BE%E6%80%8E%E4%B9%88%E7%9C%8B/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue-优先级队列</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、什么是优先级队列"><a href="#一、什么是优先级队列" class="headerlink" title="一、什么是优先级队列"></a>一、什么是优先级队列</h4><p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p><p>优先级队列底层的数据结构其实是一棵二叉堆</p><h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 不用比较器，默认升序排列，每次出列都是队列中最大元素，相当于小顶堆</span></span><br><span class="line">        Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 降序排列，每次出列都是队列中最小元素，相当于大顶堆</span></span><br><span class="line">        Queue&lt;Integer&gt; maxHeap1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        Queue&lt;Integer&gt; maxHeap2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            minHeap.add(num);   <span class="comment">// 添加元素</span></span><br><span class="line">            maxHeap1.add(num);</span><br><span class="line">            maxHeap2.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> minHeap.peek(); <span class="comment">// 获得队首元素，不出列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> minHeap.poll(); <span class="comment">// 获得队首元素并出列，队列为空返回 null</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> minHeap.remove();  <span class="comment">// 获得队首元素并出列, 队列为空报错</span></span><br><span class="line"></span><br><span class="line">        System.out.println(a + <span class="string">&quot;,&quot;</span> + b + <span class="string">&quot;,&quot;</span> + c);  <span class="comment">// 1,1,3</span></span><br><span class="line">        System.out.println(maxHeap1.peek() + <span class="string">&quot;,&quot;</span> + maxHeap1.poll() + <span class="string">&quot;,&quot;</span> + maxHeap1.remove());  <span class="comment">// 9,9,7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、什么是优先级队列&quot;&gt;&lt;a href=&quot;#一、什么是优先级队列&quot; class=&quot;headerlink&quot; title=&quot;一、什么是优先级队列&quot;&gt;&lt;/a&gt;一、什么是优先级队列&lt;/h4&gt;&lt;p&gt;PriorityQueue类在Java1.5中引入。PriorityQueu</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="PriorityQueue-优先级队列" scheme="https://tianxiafeiyu.github.io/tags/PriorityQueue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>实体类中用基本类型还是包装类</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中基本类型：</p><p>int、short、byte、long、float、double、char、boolean </p><p>对应的包装类：</p><p>Integer 、Long、Short、Byte、Character、Double、Float、Boolean</p><table><thead><tr><th>Java中基本类型</th><th>默认初始值</th><th>bit</th></tr></thead><tbody><tr><td>byte</td><td>0</td><td>8</td></tr><tr><td>short</td><td>0</td><td>16</td></tr><tr><td>int</td><td>0</td><td>32</td></tr><tr><td>long</td><td>0</td><td>64</td></tr><tr><td>float</td><td>0.0</td><td>32</td></tr><tr><td>double</td><td>0.0</td><td>64</td></tr><tr><td>char</td><td>‘ ‘</td><td>16</td></tr><tr><td>boolean</td><td>false</td><td>32</td></tr></tbody></table><table><thead><tr><th>对应的包装类</th><th>默认初始值</th><th>bit</th></tr></thead><tbody><tr><td>Byte</td><td>null</td><td></td></tr><tr><td>Short</td><td>null</td><td></td></tr><tr><td>Integer</td><td>null</td><td></td></tr><tr><td>Long</td><td>null</td><td></td></tr><tr><td>Float</td><td>null</td><td></td></tr><tr><td>Double</td><td>null</td><td></td></tr><tr><td>Character</td><td>null</td><td></td></tr><tr><td>Boolean</td><td>null</td><td></td></tr></tbody></table><h4 id="建模的时候用基本类型还是包装类型呢？"><a href="#建模的时候用基本类型还是包装类型呢？" class="headerlink" title="建模的时候用基本类型还是包装类型呢？"></a>建模的时候用基本类型还是包装类型呢？</h4><p>个人认为还是包装类的好，原因有下：</p><p>数据库null问题，表字段都<br>可能有null，包装类型默认值为null，基本类型不能为null</p><p>但是需要注意的是：Integer 的判断问题，需要使用 intValue 方法。 &#x3D;&#x3D; 判断可能会出现许多的问题。S</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java中基本类型：&lt;/p&gt;
&lt;p&gt;int、short、byte、long、float、double、char、boolean &lt;/p&gt;
&lt;p&gt;对应的包装类：&lt;/p&gt;
&lt;p&gt;Integer 、Long、Short、Byte、Character、Double、Float、Bo</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="实体类中用基本类型还是包装类" scheme="https://tianxiafeiyu.github.io/tags/%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>混乱的Java版本命名</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://www.cnblogs.com/biggw/p/11776294.html">https://www.cnblogs.com/biggw/p/11776294.html</a></p><h2 id="JDK版本与发行时间"><a href="#JDK版本与发行时间" class="headerlink" title="JDK版本与发行时间"></a>JDK版本与发行时间</h2><table><thead><tr><th>版本</th><th>名称</th><th>发行日期</th></tr></thead><tbody><tr><td>JDK 1.0</td><td>Oak(橡树)</td><td>1996-01-23</td></tr><tr><td>JDK 1.1</td><td>none（无）</td><td>1997-02-19</td></tr><tr><td>JDK 1.1.4</td><td>Sparkler（宝石）</td><td>1997-09-12</td></tr><tr><td>JDK 1.1.5</td><td>Pumpkin（南瓜）</td><td>1997-12-13</td></tr><tr><td>JDK 1.1.6</td><td>Abigail（阿比盖尔–女子名）</td><td>1998-04-24</td></tr><tr><td>JDK 1.1.7</td><td>Brutus（布鲁图–古罗马政治家和将军）</td><td>1998-09-28</td></tr><tr><td>JDK 1.1.8</td><td>Chelsea（切尔西–城市名）</td><td>1999-04-08</td></tr><tr><td>J2SE 1.2</td><td>Playground（运动场）</td><td>1998-12-04</td></tr><tr><td>J2SE 1.2.1</td><td>none（无）</td><td>1999-03-30</td></tr><tr><td>J2SE 1.2.2</td><td>Cricket（蟋蟀）</td><td>1999-07-08</td></tr><tr><td>J2SE 1.3</td><td>Kestrel（美洲红隼）</td><td>2000-05-08</td></tr><tr><td>J2SE 1.3.1</td><td>Ladybird（瓢虫）</td><td>2001-05-17</td></tr><tr><td>J2SE 1.4.0</td><td>Merlin（灰背隼）</td><td>2002-02-13</td></tr><tr><td>J2SE 1.4.1</td><td>grasshopper（蚱蜢）</td><td>2002-09-16</td></tr><tr><td>J2SE 1.4.2</td><td>Mantis（螳螂）</td><td>2003-06-26</td></tr><tr><td>Java SE 5.0 (1.5.0)</td><td>Tiger（老虎）</td><td>2004-09-30</td></tr><tr><td>Java SE 6.0 (1.6.0)</td><td>Mustang（野马）</td><td>2006-04</td></tr><tr><td>Java SE 7.0 (1.7.0)</td><td>Dolphin（海豚）</td><td>2011-07-28</td></tr><tr><td>Java SE 8.0 (1.8.0)</td><td>Spider（蜘蛛）</td><td>2014-03-18</td></tr><tr><td>Java SE 9.0</td><td>none（无）</td><td>2017-09-21</td></tr><tr><td>Java SE 10.0</td><td>none（无）</td><td>2018-03-21</td></tr><tr><td>Java SE 11.0</td><td>none（无）</td><td>2018-09-25</td></tr></tbody></table><p>Java大体有3大类命名方式：JDK、J2SE、JAVA SE。</p><p>我们口中说的Java8、JDK8、JDK1.8都是一个东西，JDK(Java Development Kit)</p><h2 id="Java命名方式更改的事件原因"><a href="#Java命名方式更改的事件原因" class="headerlink" title="Java命名方式更改的事件原因"></a>Java命名方式更改的事件原因</h2><p>1998年12月8日，Sun公司发布了第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应用于基于Java的应用服务器。</p><p>2004年9月30日，J2SE1.5发布。为了表示该版本的重要性，J2SE 1.5更名为Java SE 5.0（内部版本号1.5.0）</p><p>2005年6月，Java SE 6正式发布。此时，Java的各种版本已经更名，已取消其中的数字2（如J2EE更名为JavaEE，J2SE更名为JavaSE，J2ME更名为JavaME）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://www.cnblogs.com/biggw/p/11776294.html&quot;&gt;https://www.cnblogs.com/biggw/p/11776294.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;JDK版本与发行时间&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="混乱的Java版本命名" scheme="https://tianxiafeiyu.github.io/tags/%E6%B7%B7%E4%B9%B1%E7%9A%84Java%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>解读阿里巴巴 Java 代码规范</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%20Java%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2022-12-15T23:41:31.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/">https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2017 年阿里云栖大会，阿里发布了针对 Java 程序员的《阿里巴巴 Java 开发手册（终极版）》，这篇文档作为阿里数千位 Java 程序员的经验积累呈现给公众，并随之发布了适用于 Eclipse 和 Intellim 的代码检查插件。为了能够深入了解 Java 程序员编码规范，也为了深入理解为什么阿里这样规定，是否规定有误，本文以阿里发布的这篇文档作为分析起源，扩大范围至业界其他公司的规范，例如谷歌、FaceBook、微软、百度、华为，并搜索网络上技术大牛发表的技术文章，深入理解每一条规范的设计背景和目标。</p><p>由于解读文章仅有两篇，所以按照阿里的篇幅权重分为上篇仅针对 Java 语言本身的编码规约，下篇包含日志管理、异常处理、单元测试、MySQL 规范、工程规范等方面内容进行解读。本文是上篇，主要针对编码规约部分进行解读，由于篇幅限制，仅挑选一小部分进行解读，如果需要全篇，请联系本文作者。</p><h2 id="一、编码规约"><a href="#一、编码规约" class="headerlink" title="一、编码规约"></a>一、编码规约</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><h4 id="1-下划线或者美元符号"><a href="#1-下划线或者美元符号" class="headerlink" title="1. 下划线或者美元符号"></a>1. 下划线或者美元符号</h4><p>阿里强制规定代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p><p>反例：<code>Java_name/__name/$Object/name_/name$/Object$</code></p><p><strong>我的理解：</strong></p><p>Oracle 官网建议不要使用$或者开始变量命名，并且建议在命名中完全不要使用”$”字符，原文是”The convention,however,is to always begin your variable names with a letter,not ‘$’ or ‘‘”。对于这一条，腾讯的看法是一样的，百度认为虽然类名可以支持使用”$”符号，但只在系统生成中使用（如匿名类、代理类），编码不能使用。</p><p>这类问题在 StackOverFlow 上有很多人提出，主流意见为人不需要过多关注，只需要关注原先的代码是否存在”“，如果存在就继续保留，如果不存在则尽量避免使用。也有一位提出尽量不适用”“的原因是低分辨率的显示器，肉眼很难区分”“（一个下划线）和”_“（两个下划线）。</p><p>我个人觉得可能是由于受 C 语言的编码规范所影响。因为在 C 语言里面，系统头文件里将宏名、变量名、内部函数名用开头，因为当你#include 系统头文件时，这些文件里的名字都有了定义，如果与你用的名字冲突，就可能引起各种奇怪的现象。综合各种信息，建议不要使用”“、”$”、空格作为命名开始，以免不利于阅读或者产生奇怪的问题。</p><h4 id="2-类命名"><a href="#2-类命名" class="headerlink" title="2. 类命名"></a>2. 类命名</h4><p>阿里强制规定类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO&#x2F;BO&#x2F;DTO&#x2F;VO&#x2F;AO。 </p><p>正例：<code>MarcoPolo/UserDO/XmlService/TcpUdpDeal/TarPromotion</code></p><p>反例：<code>macroPolo/UserDo/XMLService/TCPUDPD/TAPromotion</code></p><p><strong>我的理解：</strong></p><p>百度除了支持阿里的规范以外，规定虽然类型支持”$”符号，但只在系统生成中使用（如匿名类、代理类），编码中不能使用。</p><p>对于类名，俄罗斯 Java 专家 Yegor Bugayenko 给出的建议是尽量采用现实生活中实体的抽象，如果类的名字以”-er”结尾，这是不建议的命名方式。他指出针对这一条有一个例外，那就是工具类，例如 StringUtils、FileUtils、IOUtils。对于接口名称，不要使用 IRecord、IfaceEmployee、RedcordInterface，而是使用现实世界的实体命名。如清单 3 所示。</p><p>清单 3 示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class SimpleUser implements User&#123;&#125;;</span><br><span class="line">Class DefaultRecord implements Record&#123;&#125;;</span><br><span class="line">Class Suffixed implements Name&#123;&#125;;</span><br><span class="line">Class Validated implements Content&#123;&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-抽象类的命名"><a href="#3-抽象类的命名" class="headerlink" title="3. 抽象类的命名"></a>3. 抽象类的命名</h4><p>阿里强制规定抽象类命名使用 Abstratc 或 Base 开头。</p><p><strong>我的理解：</strong></p><p>Oracle 的抽象类和方法规范并没有要求必须采用 Abstract 或者 Base 开头命名，事实上官网上的示例没有这种命名规范要求，如清单 4 所示。</p><p>清单 4 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GraphicObject</span>&#123;</span><br><span class="line">    <span class="comment">//declare fields</span></span><br><span class="line">    <span class="comment">//declare nonabstract methods</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也查了一下 JDK，确实源码里很多类都是以这样的方式命名的，例如抽象类 java.util.AbstractList。</p><p>Stackoverflow 上对于这个问题的解释是，由于这些类不会被使用，一定会由其他的类继承并实现内部细节，所以需要明白地告诉读者这是一个抽象类，那以 Abstract 开头比较合适。</p><p>JoshuaBloch的理解是支持以 Abstract 开头。我的理解是不要以 Base 开头命名，因为实际的基类也以 Base 开头居多，这样意义有多样性，不够直观。</p><h3 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h3><h4 id="1-避免魔法值的使用"><a href="#1-避免魔法值的使用" class="headerlink" title="1. 避免魔法值的使用"></a>1. 避免魔法值的使用</h4><p>阿里强制规定不允许任何魔法值（未经定义的常量）直接出现在代码中。</p><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;Id#taobao_&quot;</span> + tradeId；</span><br><span class="line">cache.put(key,value);</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>魔法值确实让你很疑惑，比如你看下面这个例子：</p><p>int priceTable[] &#x3D; new int[16];&#x2F;&#x2F;这样定义错误；这个 16 究竟代表什么？</p><p>正确的定义方式是这样的：</p><p>static final int PRICE_TABLE_MAX &#x3D; 16; &#x2F;&#x2F;这样定义正确，通过使用完整英语单词的常量名明确定义</p><p>int price Table[] &#x3D; new int[PRICE_TABLE_MAX];</p><p>魔法值会让代码的可读性大大降低，而且如果同样的数值多次出现时，容易出现不清楚这些数值是否代表同样的含义。另一方面，如果本来应该使用相同的数值，一旦用错，也难以发现。因此可以采用以下两点，极力避免使用魔法数值。</p><ol><li>不适用魔法数值，使用带名字的 Static final 或者 enum 值；</li><li>原则上 0 不用于魔法值，这是因为 0 经常被用作数组的最小下标或者变量初始化的缺省值。</li></ol><h4 id="2-变量值范围"><a href="#2-变量值范围" class="headerlink" title="2. 变量值范围"></a>2. 变量值范围</h4><p>阿里推荐如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面这个正例中的数字就是延伸信息，表示星期几。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum &#123;MONDAY(<span class="number">1</span>),TUESDAY(<span class="number">2</span>),WEDNESDAY(<span class="number">3</span>),THURSDAY(<span class="number">4</span>),FRIDAY(<span class="number">5</span>),SATURDAY(<span class="number">6</span>),SUNDAY(<span class="number">7</span>);&#125;</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>对于固定并且编译时对象，如 Status、Type 等，应该采用 enum 而非自定义常量实现，enum 的好处是类型更清楚，不会再编译时混淆。这是一个建议性的试用推荐，枚举可以让开发者在 IDE 下使用更方便，也更安全。另外就是枚举类型是一种具有特殊约束的类类型，这些约束的存在使得枚举类本身更加简洁、安全、便捷。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h4 id="1-大括号的使用约定"><a href="#1-大括号的使用约定" class="headerlink" title="1. 大括号的使用约定"></a>1. 大括号的使用约定</h4><p>阿里强制规定如果是大括号为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则遵循如下原则：</p><ol><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>右大括号后还有 else 等代码则不换行表示终止的右大括号后必须换行</li></ol><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// try to do...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">// do somthing...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// do somthing...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong></p><p>阿里的这条规定应该是参照了 SUN 公司 1997 年发布的代码规范（SUN 公司是 JAVA 的创始者），Google 也有类似的规定，大家都是遵循 K&amp;R 风格（Kernighan 和 Ritchie），Kernighan 和 Ritchie 在《The C Programming Language》一书中推荐这种风格，JAVA 语言的大括号风格就是受到了 C 语言的编码风格影响。</p><p>注意，SUN 公司认为方法名和大括号之间不应该有空格。</p><h4 id="2-单行字符数限制"><a href="#2-单行字符数限制" class="headerlink" title="2. 单行字符数限制"></a>2. 单行字符数限制</h4><p>阿里强制规定单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p><ol><li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>方法调用时，多个参数，需要换行时，在逗号后进行。</li><li>在括号前不要换行，见反例。</li></ol><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br><span class="line">    .append(<span class="string">&quot;huang&quot;</span>)...</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="comment">//超过 120 个字符的情况下，不要在括号前换行</span></span><br><span class="line">sb.append(<span class="string">&quot;zi&quot;</span>).append(<span class="string">&quot;xin&quot;</span>).append</span><br><span class="line">(<span class="string">&quot;huang&quot;</span>);</span><br><span class="line"><span class="comment">//参数很多的方法调用可能超过 120 个字符，不要在逗号前换行</span></span><br><span class="line">method(args1,args2,args3,....,argsX);</span><br></pre></td></tr></table></figure><p><strong>我的理解：</strong><br>SUN 公司 1997 年的规范中指出单行不要超过 80 个字符，对于文档里面的代码行，规定不要超过 70 个字符单行。当表达式不能在一行内显示的时候，遵循以下原则进行切分：</p><ol><li>在逗号后换行；</li><li>在操作符号前换行；</li><li>倾向于高级别的分割；</li><li>尽量以描述完整作为换行标准；</li><li>如果以下标准造成代码阅读困难，直接采用 8 个空格方式对第二行代码留出空白。</li></ol><h3 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h3><h4 id="1-静态变量及方法调用"><a href="#1-静态变量及方法调用" class="headerlink" title="1. 静态变量及方法调用"></a>1. 静态变量及方法调用</h4><p>阿里强制规定代码中避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p><p><strong>我的理解：</strong></p><p>谷歌公司在代码规范中指出必须直接使用类名对静态成员进行引用。并同时举例说明，如清单 9 所示。</p><p>清单 9 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">aFoo</span> <span class="operator">=</span> …;</span><br><span class="line">Foo.aStaticMethod();<span class="comment">//good</span></span><br><span class="line">aFoo.aStaticMethod();<span class="comment">//bad</span></span><br><span class="line">somethingThatYieldsAFoo().aStaticMethod();<span class="comment">//very bad</span></span><br></pre></td></tr></table></figure><p>SUN 公司 1997 年发布的代码规范也做了类似的要求。</p><p>为什么需要这样做呢？因为被 static 修饰过的变量或者方法都是随着类的初始化产生的，在堆内存中有一块专门的区域用来存放，后续直接用类名访问即可，避免编译成本的增加和实例对象存放空间的浪费。</p><p>StackOverflow 上也有人提出了相同的疑问，网友较为精辟的回复是”<strong>这是由于生命周期决定的，静态方法或者静态变量不是以实例为基准的，而是以类为基准，所以直接用类访问，否则违背了设计初衷</strong>“。那为什么还保留了实例的访问方式呢？可能是因为允许应用方无污染修改吧。</p><h4 id="2-可变参数编程"><a href="#2-可变参数编程" class="headerlink" title="2. 可变参数编程"></a>2. 可变参数编程</h4><p>阿里强制规定相同参数类型、相同业务类型，才可以使用 Java 的可变参数，避免使用 Object，并且要求可变参数必须放置在参数列表的最后（提倡同学们尽量不用可变参数编程）。</p><p><strong>我的理解：</strong><br>我们先来了解可变参数的使用方式：</p><ol><li>在方法中定义可变参数后，我们可以像操作数组一样操作该参数。</li><li>如果该方法除了可变参数还有其他的参数，可变参数必须放到最后。</li><li>拥有可变参数的方法可以被重载，在被调用时，如果能匹配到参数定长的方法则优先调用参数定长的方法。</li><li><strong>可变参数可以兼容数组参数，但数组参数暂时无法兼容可变参数</strong>。</li></ol><p>至于为什么可变参数需要被放在最后一个，这是因为参数个数不定，所以当其后还有相同类型参数时，编译器无法区分传入的参数属于前一个可变参数还是后边的参数，所以只能让可变参数位于最后一项。</p><p>可变参数编程有一些好处，例如反射、过程建设、格式化等。对于阿里同学提出的尽量不使用可变参数编程，我猜测的原因是不太可控，比如 Java8 推出 Lambda 表达式之后，可变参数编程遇到了实际的实现困难。</p><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><h4 id="1-单例模式需要保证线程安全"><a href="#1-单例模式需要保证线程安全" class="headerlink" title="1. 单例模式需要保证线程安全"></a>1. 单例模式需要保证线程安全</h4><p>阿里强制要求获取单例对象需要保证线程安全，其中的方法也要保证线程安全，并进一步说明资源驱动类、工具类、单例工厂类都需要注意。</p><p><strong>我的理解：</strong></p><p>对于这一条规范是通识化规定，我这里进一步讲讲如何做好针对单例对象的线程安全，主要有以下几种方式：</p><p><strong>1. 方法中申明 synchronized 关键字</strong></p><p>出现非线程安全问题，是由于多个线程可以同时进入 getInstance()方法，那么只需要对该方法进行 synchronized 锁同步即可，如清单 15 所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 清单 15 synchronized 关键字方式</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式</span></span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//创建实例之前可能会有一些准备性的耗时工作</span></span><br><span class="line">             Thread.sleep(<span class="number">500</span>);</span><br><span class="line">             Instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">     &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从执行结果上来看，多线程访问的问题已经解决了，返回的是一个实例。但是这种实现方式的运行效率很低。我们接下来采用同步方法块实现。</p><p><strong>2. 2. 同步方法块实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (MySingleton.class) &#123;          </span><br><span class="line">                <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式   </span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;      </span><br><span class="line">                    <span class="comment">//创建实例之前可能会有一些准备性的耗时工作 </span></span><br><span class="line">                    Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现能够保证多线程并发下的线程安全性，但是这样的实现将全部的代码都被锁上了，同样的效率很低下。</p><p><strong>3. 针对某些重要的代码来进行单独的同步:</strong></p><p>针对某些重要的代码进行单独的同步，而不是全部进行同步，可以极大的提高执行效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式                    </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="comment">//创建实例之前可能会有一些准备性的耗时工作 </span></span><br><span class="line">                Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                <span class="keyword">synchronized</span> (MySingleton.class) &#123; </span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果来看，这样的方法进行代码块同步，代码的运行效率是能够得到提升，但是却没能保住线程的安全性。看来还得进一步考虑如何解决此问题。</p><p><strong>4. 双检查锁机制（Double Check Locking）</strong></p><p>为了达到线程安全，又能提高代码执行效率，我们这里可以采用 DCL 的双检查锁机制来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123; </span><br><span class="line">    <span class="comment">//使用 volatile 关键字保其可见性 </span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>)&#123;<span class="comment">//懒汉式 </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="comment">//创建实例之前可能会有一些准备性的耗时工作  </span></span><br><span class="line">                Thread.sleep(<span class="number">300</span>); </span><br><span class="line">                <span class="keyword">synchronized</span> (MySingleton.class) &#123; </span><br><span class="line">                    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;<span class="comment">//二次检查  </span></span><br><span class="line">                        instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在声明变量时使用了 volatile 关键字来保证其线程间的可见性；在同步代码块中使用二次检查，以保证其不被重复实例化。集合其二者，这种实现方式既保证了其高效性，也保证了其线程安全性。</p><p><strong>5. 静态内置类方式</strong></p><p>DCL 解决了多线程并发下的线程安全问题，其实使用其他方式也可以达到同样的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123;          </span><br><span class="line">    <span class="comment">//内部类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySingletonHandler</span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> MySingletonHandler.instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 序列化与反序列化方式</strong></p><p>静态内部类虽然保证了单例在多线程并发下的线程安全性，但是在遇到序列化对象时，默认的方式运行得到的结果就是多例的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySingleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySingletonHandler</span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">MySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> MySingletonHandler.instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7. 使用枚举数据类型方式</strong></p><p>枚举 enum 和静态代码块的特性相似，在使用枚举时，构造方法会被自动调用，利用这一特性也可以实现单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumFactory</span>&#123; </span><br><span class="line">    singletonFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> MySingleton instance; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EnumFactory</span><span class="params">()</span>&#123;<span class="comment">//枚举类的构造方法在类加载是被实例化</span></span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;<span class="comment">//需要获实现单例的类，比如数据库连接 Connection  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写枚举类被完全暴露了，据说违反了”职责单一原则”，我们可以按照下面的代码改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFactory</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">MyEnumSingleton</span>&#123; </span><br><span class="line">        singletonFactory; </span><br><span class="line">        <span class="keyword">private</span> MySingleton instance; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">MyEnumSingleton</span><span class="params">()</span>&#123;<span class="comment">//枚举类的构造方法在类加载是被实例化 </span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">MySingleton</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> instance; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> MyEnumSingleton.singletonFactory.getInstance(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span>&#123;<span class="comment">//需要获实现单例的类，比如数据库连接 Connection  </span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不太理解这种写法，为什么不直接把单例类改成枚举呢？？（2020.11.12）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MySingleton</span>&#123; </span><br><span class="line">    instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MySingleton</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="1-Switch-语句的使用"><a href="#1-Switch-语句的使用" class="headerlink" title="1. Switch 语句的使用"></a>1. Switch 语句的使用</h4><p>阿里强制规定在一个 switch 块内，每个 case 要么通过 break&#x2F;return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</p><p><strong>我的理解：</strong></p><p>首先理解前半部分，”每个 case 要么通过 break&#x2F;return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止”。因为这样可以比较清楚地表达程序员的意图，有效防止无故遗漏的 break 语句。default 语句里面也应该有 break&#x2F;return。</p><h3 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h3><h4 id="1-集合转数组处理"><a href="#1-集合转数组处理" class="headerlink" title="1. 集合转数组处理"></a>1. 集合转数组处理</h4><p>阿里强制规定使用集合转数组的方法，必须使用集合的 toArray(T[] arrays)，传入的是类型完全一样的数组，大小就是 list.size()。使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[list.size()]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。正例如清单 25 所示。</p><p>清单 25 正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="string">&quot;guan&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bao&quot;</span>);</span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line">array = list.toArray(array);</span><br></pre></td></tr></table></figure><h3 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h3><h4 id="1-方法注释要求"><a href="#1-方法注释要求" class="headerlink" title="1. 方法注释要求"></a>1. 方法注释要求</h4><p>阿里强制要求方法内部单行注释，在被注释语句上方另起一行，使用&#x2F;&#x2F;注释。方法内部多行注释使用&#x2F;**&#x2F;注释，注意与代码对照。</p><p><strong>我的理解：</strong></p><p>百度规定方法注释采用标准的 Javadoc 注释规范，注释中必须提供方法说明、参数说明及返回值和异常说明。腾讯规定采用 JavaDoc 文档注释，在方法定义之前应该对其进行注释，包括方法的描述、输入、输出以及返回值说明、抛出异常说明、参考链接等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="1-数据结构初始化大小"><a href="#1-数据结构初始化大小" class="headerlink" title="1. 数据结构初始化大小"></a>1. 数据结构初始化大小</h4><p>阿里推荐任何数据结构的构造或初始化，都应指定大小，避免数据结构暂时无限增长吃光内存。</p><p><strong>我的理解：</strong></p><p>首先明确一点，阿里这里指的大小具体是指数据结构的最大长度。大部分 Java 集合类在构造时指定的大小都是初始尺寸（initial Capacity），而不是尺寸上限（Capacity），只有几种队列除外，例如 ArrayBlockingQueue、LinkedBlockingQueue，它们在构造时可以指定队列的最大长度。阿里推荐的目的是为了合理规划内存，避免出现 OOM（Out of Memory）异常。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="1-不要捕获-RuntimeException"><a href="#1-不要捕获-RuntimeException" class="headerlink" title="1. 不要捕获 RuntimeException"></a>1. 不要捕获 RuntimeException</h4><p>阿里强制规定 Java 类库中的 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，例如 IndexOutOfBoundsException、NullPointerException 等。</p><p><strong>我的理解：</strong></p><p>RuntimeException，也被称为运行时异常，通常是由于代码中的 bug 引起的，正确的处理方式是去检查代码，通过添加数据长度判断，判断对象是否为空等方法区规避，而不是靠捕获来规避这种异常。</p><h4 id="2-事务中的异常需要回滚"><a href="#2-事务中的异常需要回滚" class="headerlink" title="2. 事务中的异常需要回滚"></a>2. 事务中的异常需要回滚</h4><p>阿里强制规定有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p><p><strong>我的理解：</strong></p><p>try catch 代码块中对异常的处理，可能会遗漏事务的一致性，当事务控制不使用其他框架管理时，事务需要手动回滚。实际使用如果引入第三方的框架对事务进行管理，比如 Spring，则根据第三方框架的实际实现情况，确定是否有必要手动回滚。当第三方事务管理框架本身就会对于异常进行抛出时需要做事务回滚。例如 Spring 在@Transactional 的 annotation 注解下，会默认开启运行时异常事务回滚。</p><h4 id="3-不能在-finally-块中使用-return"><a href="#3-不能在-finally-块中使用-return" class="headerlink" title="3. 不能在 finally 块中使用 return"></a>3. 不能在 finally 块中使用 return</h4><p>阿里强制要求 finally 块中不使用 return，因为执行完该 return 后方法结束执行，不会再执行 try 块中的 return 语句。</p><p><strong>我的理解：</strong></p><p>在try-catch-finally中, 当return遇到finally，return对finally无效，即:<br>1.在try catch块里return的时候，finally也会被执行。<br>2.finally里的return语句会把try catch块里的return语句效果给覆盖掉。</p><p>return语句并不一定都是函数的出口，执行return时，只是把return后面的值复制了一份到返回值变量里去了。所以在finally有return时，会覆盖掉try-catch中的return。</p><p>finally语句是不是总会被执行？</p><p>答案是否。以下情况finally语句不会执行：</p><ol><li>try语句没有被执行到，如在try语句之前return就返回了，这样finally语句就不会执行。这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。</li><li>在try块|catch块中有System.exit(0);这样的语句。System.exit(0)是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。</li></ol><h3 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h3><h4 id="1-不可直接使用日志系统"><a href="#1-不可直接使用日志系统" class="headerlink" title="1. 不可直接使用日志系统"></a>1. 不可直接使用日志系统</h4><p>阿里强制规定应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><p><strong>我的理解：</strong></p><p>SLF4J 即简单日志门面模式，不是具体的日志解决方案，它只服务于各种各样的日志系统。在使用 SLF4J 时不需要指定哪个具体的日志系统，只需要将使用到的具体日志系统的配置文件放到类路径下去。</p><p>正例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;please use SLF4J,rather than logback or log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;please use SLF4J,rather than logback or log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-日志文件保留时间"><a href="#2-日志文件保留时间" class="headerlink" title="2. 日志文件保留时间"></a>2. 日志文件保留时间</h4><p>阿里强制规定日志文件至少保存 15 天，因为有些异常具备以”周”为频次发生的特点。</p><p><strong>我的理解：</strong></p><p>日志保留时间推荐 15 天以上，但是保留时间也不宜过长，一般不超过 21 天，否则造成硬盘空间的浪费。对于一些长周期性执行的逻辑，可以根据实际情况调整该保存时间，同时也需要保证日志能够监控到关键的应用。</p><p>对于长周期执行的逻辑，可以使用特定的 appender，并使用不同的日志清理规则，如时间、大小等。如一月执行一次的定时任务，可以将日志输出到新的日志文件，然后通过大小限定的规则进行清理，并不一定要使用时间清理的逻辑。</p><h3 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h3><h4 id="1-权限控制校验"><a href="#1-权限控制校验" class="headerlink" title="1. 权限控制校验"></a>1. 权限控制校验</h4><p>阿里强制要求对于隶属于用户个人的页面或者功能必须进行权限控制校验。</p><p><strong>我的理解：</strong></p><p>涉及到对于数据的增删改查，必须有权限的控制和校验，要有一个黑白名单的控制，不能依赖于前台页面的简单控制，后台要有对于完整的权限控制的实现。这样就能尽可能地防治数据的错误修改。</p><h4 id="2-用户传入参数校验"><a href="#2-用户传入参数校验" class="headerlink" title="2. 用户传入参数校验"></a>2. 用户传入参数校验</h4><p>阿里强制要求用户请求传入的任何参数必须做有效校验。</p><p><strong>我的理解：</strong></p><p>对于用户输入的任何参数，前端页面上都必须要做一定的有效性校验，并且在数据发送至服务器的时候在页面上给出验证结果提示，那么在用户请求传入的任务参数，后台同样也要对其有效性进行验证，防止前端页面未能过滤或者暂时无法验证的错误参数。忽略参数的验证会导致的问题很多，page size 过大会导致内存溢出、SQL 溢出等，只有验证才能尽可能地减少这些问题的出现，进而减少错误的排查几率。</p><p>所以说在前端已经做了参数校验的情况下，后端也有必要做参数校验。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="1-单元测试应该自动执行"><a href="#1-单元测试应该自动执行" class="headerlink" title="1. 单元测试应该自动执行"></a>1. 单元测试应该自动执行</h4><p>阿里强制单元测试应该是全自动执行的，并且非交互式的。测试框架通常是定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个号的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</p><p><strong>我的理解：</strong></p><p>这条原则比较容易理解。单元测试是整个系统的最小测试单元，针对的是一个类中一个方法的测试，如果这些测试的结果需要人工校验是否正确，那么对于验证人来说是一项痛苦而且耗时的工作。另外，单元测试作为系统最基本的保障，需要在修改代码、编译、打包过程中都会运行测试用例，保障基本功能，自动化的测试是必要条件。其实自动化测试不仅是单元测试特有的，包括集成测试、系统测试等，都在慢慢地转向自动化测试，以降低测试的人力成本。</p><h4 id="2-单元测试应该是独立的"><a href="#2-单元测试应该是独立的" class="headerlink" title="2. 单元测试应该是独立的"></a>2. 单元测试应该是独立的</h4><p>阿里强制保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</p><p>反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p><p><strong>我的理解：</strong></p><p>单元测试作为系统的最小测试单元，主要目的是尽可能早地测试编写的代码，降低后续集成测试期间的测试成本，以及在运行测试用例的时候能够快速地定位到对应的代码段并解决相关问题。</p><p>我们假设这么一个场景，method1 方法被 10 个其他 method 方法调用，如果 10 个 method 方法的测试用例都需要依赖 method1，那么当 methdo1 被修改导致运行出错的情况下，会导致 method1 以及依赖它的 10 个 method 的所有测试用例报错，这样就需要排查这 11 个方法到底哪里出了问题，这与单元测试的初衷不符，也会大大的增加排查工作量，所以单元测试必须是独立的，不会因为受到外部修改（这里的修改包括了依赖方法的修改以及外部环境的修改），编写单元测试时遇到的这类依赖可以使用 mock 来模拟输入和期望的返回，这样所以来的方法内部逻辑的变更就不会影响到外部的实现。</p><h4 id="3-BCDE-原则"><a href="#3-BCDE-原则" class="headerlink" title="3. BCDE 原则"></a>3. BCDE 原则</h4><p>阿里推荐编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</p><p><strong>我的理解：</strong></p><p>BCDE 原则逐一解释如下：</p><p>B（Border）：确保参数边界值均被覆盖。</p><p>例如：对于数字，测试负数、0、正数、最小值、最大值、NaN（非数字）、无穷大值等。对于字符串，测试空字符串、单字符、非 ASCII 字符串、多字节字符串等。对于集合类型，测试空、第一个元素、最后一个元素等。对于日期，测试 1 月 1 日、2 月 29 日、12 月 31 日等。被测试的类本身也会暗示一些特定情况下的边界值。对于边界情况的测试一定要详尽。</p><p>C（Connect）：确保输入和输出的正确关联性。</p><p>例如，测试某个时间判断的方法 boolean inTimeZone(Long timeStamp)，该方法根据输入的时间戳判断该事件是否存在于某个时间段内，返回 boolean 类型。如果测试输入的测试数据为 Long 类型的时间戳，对于输出的判断应该是对于 boolean 类型的处理。如果测试输入的测试数据为非 Long 类型数据，对于输出的判断应该是报错信息是否正确。</p><p>D（Design）：任务程序的开发包括单元测试都应该遵循设计文档。</p><p>E（Error）：单元测试包括对各种方法的异常测试，测试程序对异常的响应能力。</p><p>除了这些解释之外，《单元测试之道（Java 版）》这本书里面提到了关于边界测试的 <strong>CORRECT</strong> 原则：</p><p>一致性（Conformance）：值是否符合预期格式（正常的数据），列出所有可能不一致的数据，进行验证。</p><p>有序性（Ordering）：传入的参数的顺序不同的结果是否正确，对排序算法会产生影响，或者是对类的属性赋值顺序不同会不会产生错误。</p><p>区间性（Range）：参数的取值范围是否在某个合理的区间范围内。</p><p>引用&#x2F;耦合性（Reference）：程序依赖外部的一些条件是否已满足。前置条件：系统必须处于什么状态下，该方法才能运行。后置条件，你的方法将会保证哪些状态发生改变。</p><p>存在性（Existence）：参数是否真的存在，引用为 Null，String 为空，数值为 0 或者物理介质不存在时，程序是否能正常运行。</p><p>基数性（Cardinality）：考虑以”0-1-N 原则”，当数值分别为 0、1、N 时，可能出现的结果，其中 N 为最大值。</p><p>时间性（Time）：相对时间指的是函数执行的依赖顺序，绝对时间指的是超时问题、并发问题。</p><h3 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h3><h4 id="1-建表的是与否规则"><a href="#1-建表的是与否规则" class="headerlink" title="1. 建表的是与否规则"></a>1. 建表的是与否规则</h4><p>阿里强制要求如果遇到需要表达是与否的概念时，必须使用 is_xxx 的方法命令，数据类型是 unsigned tinyint，1 表示是，0 表示否。</p><p>说明：任务字段如果为非负数，必须是 unsigned。</p><p>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p><p><strong>我的理解：</strong></p><p>命名使用 is_xxx 第一个好处是比较清晰的，第二个好处是使用者根据命名就可以知道这个字段的取值范围，也方便做参数验证。</p><p>类型使用 unsigned 的好处是如果只存整数，unsigned 类型有更大的取值范围，可以节约磁盘和内存使用。</p><p>对于表的名字，MySQL 社区有自己推荐的命名规范：</p><p>表包含多个英文单词时，需要用下划线进行单词分割，这一点类似于 Java 类名的命名规范，例如 master_schedule、security_user_permission；<br>由于 InnoDB 存储引擎本身是针对操作系统的可插拔设计的，所以原则上所有的表名组成全部由小写字母组成；<br>不允许出现空格，需要分割一律采用下划线；<br>名字不允许出现数字，仅包含英文字母；<br>名字需要总长度少于 64 个字符。</p><h4 id="2-数据类型精度考量"><a href="#2-数据类型精度考量" class="headerlink" title="2. 数据类型精度考量"></a>2. 数据类型精度考量</h4><p>阿里强制要求存放小数时使用 decimal，禁止使用 float 和 double。</p><p>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p><p><strong>我的理解：</strong></p><p>我们先来看看各个精度的范围。</p><p>Float：浮点型，4 字节数 32 位，表示数据范围-3.4E38~3.4E38</p><p>Double：双精度型，8 字节数 64 位，表示数据范围-1.7E308~1.7E308</p><p>Decimal：数字型，16 字节数 128 位，不存在精度损失，常用于银行账目计算</p><p>在精确计算中使用浮点数是非常危险的，在对精度要求高的情况下，比如银行账目就需要使用 Decimal 存储数据。</p><p>实际上，所有涉及到数据存储的类型定义，都会涉及数据精度损失问题。Java 的数据类型也存在 float 和 double 精度损失情况，阿里没有指出这条规约，就全文来说，这是一个比较严重的规约缺失。</p><p>Joshua Bloch（著名的 Effective Java 书作者）认为，float 和 double 这两个原生的数据类型本身是为了科学和工程计算设计的，它们本质上都采用单精度算法，也就是说在较宽的范围内快速获得精准数据值。但是，需要注意的是，这两个原生类型都不保证也不会提供很精确的值。单精度和双精度类型特别不适用于货币计算，因为不可能准确地表示 0.1（或者任何其他十的负幂）。</p><p>我们再来看一个实际的例子。假设你有 1 块钱，现在每次购买蛋糕的价格都会递增 0.10 元，为我们一共可以买几块蛋糕。口算一下，应该是 4 块（因为 0.1+0.2+0.3+0.4&#x3D;1.0），我们写个程序验证看看，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方式</span></span><br><span class="line"><span class="type">double</span> <span class="variable">funds1</span> <span class="operator">=</span> <span class="number">1.00</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">itemsBought</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">.10</span>;funds&gt;=price;price+=<span class="number">.10</span>)&#123;</span><br><span class="line"> funds1 -=price;</span><br><span class="line"> itemsBought++;</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println(itemsBought+<span class="string">&quot; items boughts.&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;Changes:&quot;</span>+funds1);</span><br><span class="line"> <span class="comment">// 3 items boughts.</span></span><br><span class="line"><span class="comment">// Changes:0.3999999999999999</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//正确的方式</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">BigDecimal</span> <span class="variable">TEN_CENTS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;.10&quot;</span>);</span><br><span class="line"> itemsBought = <span class="number">0</span>;</span><br><span class="line"> <span class="type">BigDecimal</span> <span class="variable">funds2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">BigDecimal</span> <span class="variable">price</span> <span class="operator">=</span> TEN_CENTS;funds2.compareTo(price)&gt;<span class="number">0</span>;price =</span><br><span class="line"> price.add(TEN_CENTS))&#123;</span><br><span class="line"> fund2 = fund2.substract(price);</span><br><span class="line"> itemsBought++;</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(itemsBought+<span class="string">&quot; items boughts.&quot;</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;Changes:&quot;</span>+funds2);</span><br><span class="line"><span class="comment">// 4 items boughts.</span></span><br><span class="line"><span class="comment">// Changes:0.00</span></span><br></pre></td></tr></table></figure><p>这里我们可以看到使用了 BigDecimal 解决了问题，实际上 int、long 也可以解决这类问题。采用 BigDecimal 有一个缺点，就是使用过程中没有原始数据这么方便，效率也不高。如果采用 int 方式，最好不要在有小数点的场景下使用，可以在 100、10 这样业务场景下选择使用。</p><h4 id="3-使用-Char"><a href="#3-使用-Char" class="headerlink" title="3. 使用 Char"></a>3. 使用 Char</h4><p>阿里强制要求如果存储的字符串长度几乎相等，使用 Char 定长字符串类型。</p><p><strong>我的理解：</strong></p><p>从性能上分析，character(n)通常是最慢的，在大多数情况下，应该使用 text 或者 character varying。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><h4 id="1-服务间依赖关系"><a href="#1-服务间依赖关系" class="headerlink" title="1. 服务间依赖关系"></a>1. 服务间依赖关系</h4><p>阿里推荐默认上层依赖于下层，箭头关系表示可直接依赖，如：Controller层可以依赖于 Web 层，也可以直接依赖于 Service 层。</p><p><strong>我的理解：</strong></p><p>《软件架构模式》一书中介绍了分层架构思想：</p><p>分层架构是一种很常见的架构模式，它也被叫做 N 层架构。这种架构是大多数 Java EE 应用的实际标准。许多传统 IT 公司的组织架构和分层模式十分的相似，所以它很自然地成为大多数应用的架构模式。</p><p>分层架构模式里的组件被分成几个平行的层次，每一层都代表了应用的一个功能（展示逻辑或者业务逻辑）。尽管分层架构没有规定自身要分成几层几种，大多数的结构都分成四个层次，即展示层、业务层、持久层和数据库层。业务层和持久层有时候可以合并成单独的一个业务层，尤其是持久层的逻辑绑定在业务层的组件当中。因此，有一些小的应用可能只有三层，一些有着更复杂的业务的大应用可能有五层甚至更多的层。</p><p>分层架构中的每一层都有着特定的角色和职能。举个例子，展示层负责所有的界面展示以及交互逻辑，业务层负责处理请求对应的业务。架构里的层次是具体工作的高度抽象，它们都是为了实现某种特定的业务请求。比如说展示层并不关心如何得到用户数据，它只需在屏幕上以特定的格式展示信息。业务层并不关心要展示在屏幕上的用户数据格式，也不关心这些用户数据从哪里来，它只需要从持久层得到数据，执行与数据有关的相应业务逻辑，然后把这些信息传递给展示层。</p><p>分层架构的一个突出特性地组件间关注点分离。一个层中的组件只会处理本层的逻辑。比如说，展示层的组件只会处理展示逻辑，业务层中的组件只会去处理业务逻辑。因为有了组件分离设计方式，让我们更容易构造有效的角色和强力的模型，这样应用变得更好开发、测试、管理和维护。</p><h4 id="2-高并发服务器-time-wait"><a href="#2-高并发服务器-time-wait" class="headerlink" title="2. 高并发服务器 time_wait"></a>2. 高并发服务器 time_wait</h4><p>阿里推荐高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</p><p>说明：操作系统默认 240 秒后才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</p><p>正例：在 Linux 服务器上通过变更&#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout&#x3D;30</p><p><strong>我的理解：</strong></p><p>服务器在处理完客户端的连接后，主动关闭，就会有 time_wait 状态。TCP 连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发 FIN 包的一方执行的是主动关闭，后发 FIN 包的一方执行的是被动关闭。主动关闭的一方会进入 time_wait 状态，并且在此状态停留两倍的 MSL 时长。</p><p>主动关闭的一方收到被动关闭的一方发出的 FIN 包后，回应 ACK 包，同时进入 time_wait 状态，但是因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回就是两倍的 MSL 时长。如果主动关闭的一方跳过 time_wait 直接进入 closed，或者在 time_wait 停留的时长不足两倍的 MSL，那么当被动关闭的一方早于先发出的延迟包达到后，就可能出现类似下面的问题：</p><ol><li><p>旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包</p></li><li><p>新的 TCP 连接被建立起来了，延迟包可能干扰新的连接</p></li></ol><p>不管是哪种情况都会让 TCP 不再可靠，所以 time_wait 状态有存在的必要性。</p><p>修改 net.ipv4.tcp_fin_timeout 也就是修改了 MSL 参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://developer.ibm.com/zh/articles/deconding-code-specification-part-1/&quot;&gt;https://developer.ibm.com/zh/articles/deconding-</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/java/"/>
    
    
    <category term="解读阿里巴巴 Java 代码规范" scheme="https://tianxiafeiyu.github.io/tags/%E8%A7%A3%E8%AF%BB%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>TCP 协议灵魂 12 问 【转】</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/TCP%20%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82%2012%20%E9%97%AE%20%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/TCP%20%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82%2012%20%E9%97%AE%20%E3%80%90%E8%BD%AC%E3%80%91/</id>
    <published>2022-12-15T23:41:00.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://my.oschina.net/u/4192546/blog/4644900">https://my.oschina.net/u/4192546/blog/4644900</a></p><h3 id="01-能不能说一说-TCP-和-UDP-的区别？"><a href="#01-能不能说一说-TCP-和-UDP-的区别？" class="headerlink" title="01. 能不能说一说 TCP 和 UDP 的区别？"></a>01. 能不能说一说 TCP 和 UDP 的区别？</h3><p>基本区别：</p><p>TCP是一个面向连接的、可靠的、基于字节流的传输层协议。</p><p>而UDP是一个面向无连接的传输层协议。(就这么简单，其它TCP的特性也就没有了)。</p><p>具体分析：</p><p>和 UDP 相比，TCP 有三大核心特性:</p><ol><li><p>面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p></li><li><p>可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。<br>当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。相应的，UDP 就是无状态, 不可控的。</p></li><li><p>面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</p></li></ol><h3 id="02-说说-TCP-三次握手的过程？为什么是三次而不是两次、四次？"><a href="#02-说说-TCP-三次握手的过程？为什么是三次而不是两次、四次？" class="headerlink" title="02. 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？"></a>02. 说说 TCP 三次握手的过程？为什么是三次而不是两次、四次？</h3><p>TCP 的三次握手，目的是确认双方的两样能力: 发送的能力和接收的能力。</p><ol><li>客户端：“喂，能听到我说话吗”</li><li>服务端：“我能听到，你能听到我吗”</li><li>客户端：“能听到”</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/4085089A13624557A4019F74C06BB727?method=download&shareKey=c1fd86182fb4e46caef87b65223d45db" alt="tcp三次握手"></p><p>从图中可以看出，SYN （同步序列标志 Synchronize Sequence Numbers）是需要消耗一个序列号的，下次发送对应的 ACK（确认标志  Acknowledgement Number） 序列号要加1，为什么呢？只需要记住一个规则:</p><p>凡是需要对端确认的，一定消耗TCP报文的序列号。</p><p>SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。</p><p><strong>为什么不是两次？</strong> 根本原因: 无法确认客户端的接收能力。</p><p>分析如下:</p><p>如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。</p><p>看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。</p><p>看到问题的吧，这就带来了连接资源的浪费。</p><p><strong>为什么不是四次？</strong> 三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？</p><p>当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。</p><p>三次握手过程中可以携带数据么？ 第三次握手的时候，可以携带。前两次握手不能携带数据。</p><p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p><p>第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p><h3 id="03-说说-TCP-四次挥手的过程"><a href="#03-说说-TCP-四次挥手的过程" class="headerlink" title="03. 说说 TCP 四次挥手的过程"></a>03. 说说 TCP 四次挥手的过程</h3><ol><li>客户端：我好了。</li><li>服务端：收到。</li><li>服务端：我也好了。</li><li>客户端：收到。</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/82900C4A92994B989F6A19895365E10C?method=download&shareKey=46fc8447859229c1b2d41e489b9f4c75" alt="tcp四次挥手"></p><p>需要注意的是，第4步客户端发送确认响应给服务端后，连接并不会马上断开。<strong>客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK</strong>。</p><p><strong>等待2MSL的意义 如果不等待会怎样？</strong></p><p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。</p><p>那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</p><p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端<br>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。<br>为什么是四次挥手而不是三次？ 因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p><strong>如果是三次挥手会有什么问题？</strong> 等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。</p><h3 id="04-说说半连接队列和-SYN-Flood-攻击的关系"><a href="#04-说说半连接队列和-SYN-Flood-攻击的关系" class="headerlink" title="04. 说说半连接队列和 SYN Flood 攻击的关系"></a>04. 说说半连接队列和 SYN Flood 攻击的关系</h3><p>三次握手前，服务端的状态从CLOSED变为LISTEN, 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。</p><p><strong>半连接队列</strong> 当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，也就是半连接队列。</p><p><strong>全连接队列</strong> 当客户端返回ACK, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。</p><p><strong>SYN Flood 攻击原理</strong> SYN Flood 属于典型的 DoS&#x2F;DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送SYN。对于服务端而言，会产生两个危险的后果:</p><p>处理大量的SYN包并返回对应ACK, 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。</p><p>由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</p><p><strong>如何应对 SYN Flood 攻击？</strong></p><ol><li>增加 SYN 连接，也就是增加半连接队列的容量。</li><li>减少 SYN + ACK 重试次数，避免大量的超时重发。</li><li>利用 SYN Cookie 技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证 Cookie 合法之后才分配连接资源。</li></ol><h3 id="05-介绍一下-TCP-报文头部的字段"><a href="#05-介绍一下-TCP-报文头部的字段" class="headerlink" title="05. 介绍一下 TCP 报文头部的字段"></a>05. 介绍一下 TCP 报文头部的字段</h3><p>报文头部结构如下(单位为字节):<br><img src="/" alt="TCP 报文头部的字段"></p><p><strong>源端口、目标端口</strong> 如何标识唯一标识一个连接？答案是 TCP 连接的四元组——源 IP、源端口、目标 IP 和目标端口。</p><p>那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP 。TCP 只需要记录两者的端口即可。</p><p><strong>序列号</strong> 即Sequence number, 指的是本报文段第一个字节的序列号。</p><p>从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。</p><p>序列号在 TCP 通信的过程中有两个作用:</p><p>在 SYN 报文中交换彼此的初始序列号。<br>保证数据包按正确的顺序组装。</p><p><strong>ISN</strong> 即Initial Sequence Number（初始序列号）,在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。</p><p>ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？</p><p>如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。</p><p>而动态增长的 ISN 大大提高了猜测 ISN 的难度。</p><p><strong>确认号</strong> 即ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。</p><p><strong>标记位</strong> 常见的标记位有SYN,ACK,FIN,RST,PSH。</p><p>SYN 和 ACK 已经在上文说过，后三个解释如下: FIN：即 Finish，表示发送方准备断开连接。</p><p>RST：即 Reset，用来强制断开连接。</p><p>PSH：即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p><p><strong>窗口大小</strong> 占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</p><p><strong>校验和</strong> 占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。</p><p><strong>可选项</strong> 可选项的格式如下: 在这里插入图片描述 常用的可选项有以下几个:</p><ul><li>TimeStamp: TCP 时间戳，后面详细介绍。</li><li>MSS: 指的是 TCP 允许的从对方接收的最大报文段。</li><li>SACK: 选择确认选项。</li><li>Window Scale：窗口缩放选项。</li></ul><h2 id="06-说说-TCP-快速打开的原理-TFO"><a href="#06-说说-TCP-快速打开的原理-TFO" class="headerlink" title="06. 说说 TCP 快速打开的原理(TFO)"></a>06. 说说 TCP 快速打开的原理(TFO)</h2><p>第一节讲了 TCP 三次握手，可能有人会说，每次都三次握手好麻烦呀！能不能优化一点？</p><p>可以啊。今天来说说这个优化后的 TCP 握手流程，也就是 TCP 快速打开(TCP Fast Open, 即TFO)的原理。</p><p>优化的过程是这样的，还记得我们说 SYN Flood 攻击时提到的 SYN Cookie 吗？这个 Cookie 可不是浏览器的Cookie, 用它同样可以实现 TFO。</p><p>TFO 流程</p><p>首轮三次握手 首先客户端发送SYN给服务端，服务端接收到。</p><p>注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie, 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。</p><p>客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。</p><p>首轮三次握手就是这样的流程。而后面的三次握手就不一样啦！</p><p>后面的三次握手 在后面的三次握手中，客户端会将之前缓存的 Cookie、SYN 和HTTP请求(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回SYN + ACK。</p><p>重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。</p><p>当然，客户端的ACK还得正常传过来，不然怎么叫三次握手嘛。</p><p><img src="/" alt="TCP 快速打开流程"></p><p>注意：客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。</p><p>TFO 的优势 TFO 的优势并不在与首轮三次握手，而在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输，积累起来还是一个比较大的优势。</p><h3 id="07-能不能说说TCP报文中时间戳的作用？"><a href="#07-能不能说说TCP报文中时间戳的作用？" class="headerlink" title="07.  能不能说说TCP报文中时间戳的作用？"></a>07.  能不能说说TCP报文中时间戳的作用？</h3><p>timestamp是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:</p><p>kind(1 字节) + length(1 字节) + info(8 个字节) 其中 kind &#x3D; 8， length &#x3D; 10， info 有两部分构成: timestamp和timestamp echo，各占 4 个字节。</p><p>那么这些字段都是干嘛的呢？它们用来解决那些问题？</p><p>接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题:</p><ul><li>计算往返时延 RTT(Round-Trip Time)</li><li>防止序列号的回绕问题:<br>  序列号的范围其实是在0 ~ 2 ^ 32 - 1浮动，在一次传输中可能存在相同的序列号报文，这时可用时间戳区分。</li></ul><h3 id="08-TCP-的超时重传时间是如何计算的？"><a href="#08-TCP-的超时重传时间是如何计算的？" class="headerlink" title="08. TCP 的超时重传时间是如何计算的？"></a>08. TCP 的超时重传时间是如何计算的？</h3><p>TCP 具有超时重传机制，即间隔一段时间没有等到数据包的回复时，重传这个数据包。</p><p>那么这个重传间隔是如何来计算的呢？</p><p>…</p><h3 id="09-能不能说一说-TCP-的流量控制？"><a href="#09-能不能说一说-TCP-的流量控制？" class="headerlink" title="09.  能不能说一说 TCP 的流量控制？"></a>09.  能不能说一说 TCP 的流量控制？</h3><p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。</p><p>而流量控制索要做的事情，就是在通过设置接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p><p>要具体理解流量控制，首先需要了解滑动窗口的概念。</p><p>TCP 滑动窗口 TCP 滑动窗口分为两种: 发送窗口和接收窗口。</p><p>流量控制过程 这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家理解。</p><p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。</p><p>假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。</p><p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。</p><p>注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。</p><p>因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。</p><p>此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。</p><p>这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。</p><h3 id="10-能不能说说-TCP-的拥塞控制？"><a href="#10-能不能说说-TCP-的拥塞控制？" class="headerlink" title="10. 能不能说说 TCP 的拥塞控制？"></a>10. 能不能说说 TCP 的拥塞控制？</h3><p>上一节所说的流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是拥塞控制需要处理的问题。</p><p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p><ul><li>拥塞窗口（Congestion Window，cwnd）</li><li>慢启动阈值（Slow Start Threshold，ssthresh）</li></ul><p>涉及到的算法有这几个:</p><ul><li>慢启动</li><li>拥塞避免</li><li>快速重传和快速恢复</li></ul><p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。</p><p><strong>拥塞窗口</strong> 拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。</p><p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p><ul><li>接收窗口(rwnd)是接收端给的限制</li><li>拥塞窗口(cwnd)是发送端的限制</li></ul><p>限制谁呢？</p><p>限制的是发送窗口的大小。</p><p>有了这两个窗口，如何来计算发送窗口？</p><p>发送窗口大小 &#x3D; min(rwnd, cwnd) 取两者的较小值。而拥塞控制，就是来控制cwnd的变化。</p><p><strong>慢启动</strong> 刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。</p><p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:</p><p>首先，三次握手，双方宣告自己的接收窗口大小<br>双方初始化自己的拥塞窗口(cwnd)大小<br>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。<br>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做慢启动阈值，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！</p><p>在到达阈值后，如何来控制 cwnd 的大小呢？</p><p>这就是拥塞避免做的事情了。</p><p>拥塞避免 原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 &#x2F; cwnd。那你仔细算算，一轮 RTT（往返时延） 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。</p><p>也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。</p><p>当然，慢启动和拥塞避免是一起作用的，是一体的。</p><p><strong>快速重传和快速恢复</strong></p><p><strong>快速重传</strong> 在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。</p><p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。</p><p>这就是快速重传，它解决的是是否需要重传的问题。</p><p><strong>选择性重传</strong> 那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？</p><p>当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。</p><p>在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是如何重传的问题。</p><p><strong>快速恢复</strong> 当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入快速恢复阶段。</p><p>在这个阶段，发送端如下改变：</p><ul><li>拥塞阈值降低为 cwnd 的一半</li><li>cwnd 的大小变为拥塞阈值</li><li>cwnd 线性增加</li></ul><p>以上就是 TCP 拥塞控制的经典算法: 慢启动、拥塞避免、快速重传和快速恢复。</p><h3 id="11-能不能说说-Nagle-算法和延迟确认？"><a href="#11-能不能说说-Nagle-算法和延迟确认？" class="headerlink" title="11. 能不能说说 Nagle 算法和延迟确认？"></a>11. 能不能说说 Nagle 算法和延迟确认？</h3><p>**Nagle 算法 ** 试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。</p><p>而避免小包的频繁发送，这就是 Nagle 算法要做的事情。</p><p>具体来说，Nagle 算法的规则如下:</p><p>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送 后面发送满足下面条件之一就可以发了: 数据包大小达到最大段大小(Max Segment Size, 即 MSS) 之前所有包的 ACK 都已接收到</p><p><strong>延迟确认</strong> 试想这样一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那我是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？</p><p>延迟确认(delayed ack)所做的事情，就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。</p><p>不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:</p><ul><li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li><li>TCP 处于 quickack 模式（通过tcp_in_quickack_mode设置）</li><li>发现了乱序包</li></ul><p><strong>两者一起使用会怎样？</strong> 前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p><h3 id="12-如何理解-TCP-的-keep-alive？"><a href="#12-如何理解-TCP-的-keep-alive？" class="headerlink" title="12. 如何理解 TCP 的 keep-alive？"></a>12. 如何理解 TCP 的 keep-alive？</h3><p>大家都听说过 http 的keep-alive, 不过 TCP 层面也是有keep-alive机制，而且跟应用层不太一样。</p><p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的。</p><p>这个时候就出现了 keep-alive, 它的作用就是探测对端的连接有没有失效。</p><p>在 Linux 下，可以这样查看相关的配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -a | grep keepalive</span><br><span class="line"></span><br><span class="line">// 每隔 7200 s 检测一次</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">// 一次最多重传 9 个包</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">// 每个包的间隔重传间隔 75 s</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75</span><br></pre></td></tr></table></figure><p>不过，现状是大部分的应用并没有默认开启 TCP 的keep-alive选项，为什么？</p><p>站在应用的角度:</p><ul><li>7200s 也就是两个小时检测一次，时间太长</li><li>时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接</li></ul><p>因此是一个比较尴尬的设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;转载自 &lt;a href=&quot;https://my.oschina.net/u/4192546/blog/4644900&quot;&gt;https://my.oschina.net/u/4192546/blog/4644900&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;01-能不能说一说-TCP-和</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="os" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/os/"/>
    
    
    <category term="TCP 协议灵魂 12 问 【转】" scheme="https://tianxiafeiyu.github.io/tags/TCP-%E5%8D%8F%E8%AE%AE%E7%81%B5%E9%AD%82-12-%E9%97%AE-%E3%80%90%E8%BD%AC%E3%80%91/"/>
    
  </entry>
  
  <entry>
    <title>NaN代表什么意思</title>
    <link href="https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>https://tianxiafeiyu.github.io/2022/12/15/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</id>
    <published>2022-12-15T23:40:42.000Z</published>
    <updated>2022-12-16T21:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>返回NaN的运算有如下三种：</p><ul><li>至少有一个参数是NaN的运算</li><li>不定式  <ul><li>除法运算：0&#x2F;0、∞&#x2F;∞、∞&#x2F;−∞、−∞&#x2F;∞、−∞&#x2F;−∞  </li><li>乘法运算：0×∞、0×−∞   </li><li>加法运算：∞ + (−∞)、(−∞) + ∞  </li><li>减法运算：∞ - ∞、(−∞) - (−∞)</li></ul></li><li>产生复数结果的实数运算。例如：<br>对负数进行开偶次方的运算<br>对负数进行对数运算<br>对正弦或余弦到达域以外的数进行反正弦或反余弦运算。</li></ul><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul><li>NaN 表示无效数据（超出表示范围、不是有效整数等）</li><li>Perl的BigInt包用“NaN”来表示不含有效整数数据字符串的处理结果</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的</summary>
      
    
    
    
    <category term="技术开发" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="grocery" scheme="https://tianxiafeiyu.github.io/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/grocery/"/>
    
    
    <category term="NaN代表什么意思" scheme="https://tianxiafeiyu.github.io/tags/NaN%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    
  </entry>
  
</feed>

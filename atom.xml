<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dalin blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-12T17:36:23.245Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Dalin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E6%9C%8D%E5%8A%A1%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0/"/>
    <id>http://example.com/2022/12/12/开发笔记/服务缓存数据更新/</id>
    <published>2022-12-12T17:36:23.245Z</published>
    <updated>2022-12-12T17:36:23.245Z</updated>
    
    <content type="html"><![CDATA[<p>内存缓存作为最方便的提升效率的手段，很多程序都有使用到。</p><p>缓存痛点：</p><ol><li>内存占用</li><li>缓存一致性</li><li>缓存并发</li></ol><p>怎么解决时效性，保证缓存能够及时更新：</p><p>更新方法：</p><ol><li>定时更新</li><li>动态更新</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内存缓存作为最方便的提升效率的手段，很多程序都有使用到。&lt;/p&gt;
&lt;p&gt;缓存痛点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;缓存一致性&lt;/li&gt;
&lt;li&gt;缓存并发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;怎么解决时效性，保证缓存能够及时更新：&lt;/p&gt;
&lt;p&gt;更新方法：&lt;/
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2022/12/12/开发笔记/进程间通信技术/</id>
    <published>2022-12-12T17:36:23.245Z</published>
    <updated>2022-12-12T17:36:23.245Z</updated>
    
    <content type="html"><![CDATA[<p>转自 <a href="https://my.oschina.net/taogang/blog/4313908">https://my.oschina.net/taogang/blog/4313908</a></p><p>最早在Unix&#x2F;Linux的编程领域，提供了进程间通信的手段，例如：管道，信号量，消息队列，套接字（Socket）等。如果你的应用是由不同语言编写的，那么这里只能选择Socket通信作为应用之间的API手段。但是Socket通信是一种非常低Level的通信手段，它以底层的数据包作为抽象和通信内容，很难维护和使用。</p><p>早期的进程间通信技术包括：</p><ul><li>DCOM （ Distributed Component Object Model ）分布式组件对象模型，这个是微软的技术，只能用于Windows平台， 通过网络实现远程对象间的通信</li><li>RMI （ Remote Method Call) Java的远程方法调用，这个是Java自己的RPC，只能用于Java应用之间的远程调用。</li><li>JNI Java的本地接口， 支持Java应用调用本地方法，这个是跨越语言障碍的，但是仅仅局限于Java应用调用其它的本地应用，不具备互操作性，是个单项通道。</li></ul><h3 id="CORBA"><a href="#CORBA" class="headerlink" title="CORBA"></a>CORBA</h3><p>1991年一种名叫CORBA （ Common Object Request Broker Architecture ） 的技术出现。</p><p>CORBA和之前提到的DCOM和RMI类似，都提供了远程的对象&#x2F;方法调用，但是CORBA是一种与语言和实现无关的技术</p><p>CORBA定了与语言解耦的系统间通信的标准。开发CORAB的过程从IDL的定义开始，用户通过IDL定义了对象，然后在Server端实现该对象的应用逻辑，在Client端调用该对象。</p><p>CORBA存在的主要问题：</p><ul><li>对象的生命周期管理比较复杂。远程对象的发现，创建和销毁都会带来问题</li><li>整个CORAB的架构比较复杂</li></ul><h3 id="XML-RPC-x2F-SOAP"><a href="#XML-RPC-x2F-SOAP" class="headerlink" title="XML-RPC &#x2F; SOAP"></a>XML-RPC &#x2F; SOAP</h3><p>XML-RPC发表于1998年，由UserLand Software（UserLand Software）的Dave Winer及Microsoft共同发表。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协议。</p><p>下面是一个 XML-RPC的请求&#x2F;响应的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">  &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">  &lt;params&gt;</span><br><span class="line">    &lt;param&gt;</span><br><span class="line">        &lt;value&gt;&lt;i4&gt;40&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/param&gt;</span><br><span class="line">  &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodResponse&gt;</span><br><span class="line">  &lt;params&gt;</span><br><span class="line">    &lt;param&gt;</span><br><span class="line">        &lt;value&gt;&lt;string&gt;South Dakota&lt;/string&gt;&lt;/value&gt;</span><br><span class="line">    &lt;/param&gt;</span><br><span class="line">  &lt;/params&gt;</span><br><span class="line">&lt;/methodResponse&gt;</span><br></pre></td></tr></table></figure><p>SOAP是 Simple Object Access Protocol 的缩写。SOAP为Web服务提供了Web服务协议栈的Messaging Protocol层。它是一个基于XML的协议，由三部分组成：</p><ol><li>一个信封，它定义了消息结构以及如何处理它</li><li>一组用于表达应用程序定义的数据类型实例的编码规则</li><li>表示过程调用和响应的约定</li></ol><p>SOAP具有三个主要特征：</p><ol><li>可扩展性（安全性和WS-Addressing在开发中）</li><li>中立性（SOAP可以通过HTTP，SMTP，TCP，UDP等任何协议进行操作）</li><li>独立性（SOAP允许任何编程语言）</li></ol><p>作为SOAP过程可以执行的操作的示例，应用程序可以将SOAP请求发送到启用了带有搜索参数的Web服务的服务器（例如，房地产价格数据库）。然后，服务器返回SOAP响应（包含结果数据的XML格式的文档），例如价格，位置，功能。由于生成的数据采用标准化的机器可解析格式，因此发出请求的应用程序可以直接将其集成。</p><p>SOAP体系结构由以下几层规范组成：</p><ul><li>讯息格式</li><li>邮件交换模式（MEP）</li><li>底层传输协议绑定</li><li>消息处理模型</li><li>协议可扩展性</li></ul><p>下面是一个SOAP消息的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 299</span><br><span class="line">SOAPAction: &quot;http://www.w3.org/2003/05/soap-envelope&quot;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:m=&quot;http://www.example.org&quot;&gt;</span><br><span class="line">  &lt;soap:Header&gt;</span><br><span class="line">  &lt;/soap:Header&gt;</span><br><span class="line">  &lt;soap:Body&gt;</span><br><span class="line">    &lt;m:GetStockPrice&gt;</span><br><span class="line">      &lt;m:StockName&gt;T&lt;/m:StockName&gt;</span><br><span class="line">    &lt;/m:GetStockPrice&gt;</span><br><span class="line">  &lt;/soap:Body&gt;</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>相比较XML-RPC，他的功能更多，当然消息结构也更复杂。</p><p>SOAP是W3C推荐的Webservice标准，一度也是非常的流行，但是我们看到基于XML的消息比较复杂，消息本身因为XML的原因，有相当多的开销。于是后面又有了基于JSON的RPC格式。但总的来说，SOAP也已经是昨日黄花，当今的应用构建，你选它的概率应该也不大了。</p><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>REST是当今最为流行的API。因为大量的Web应用采用REST作为其API的选择。REST是 Representational State Transfer 的缩写。是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件&#x2F;程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。所以我么可以看到软件的发展，大体是从复杂变得简单，只有简单的东西才会变的更有生命力。</p><p>为了使任何应用程序真正实现RESTful，必须遵循六个体系结构约束：</p><ol><li>统一接口：意味着必须向Web应用程序中的API使用者提供API接口。</li><li>客户端服务器：客户端和服务器必须彼此独立，并且客户端应仅知道资源的URI。</li><li>无状态：服务器不得存储与客户端请求相关的任何内容。 客户端负责维护应用程序的状态。</li><li>可缓存的：资源必须可缓存。</li><li>分层系统：体系结构必须是分层的，这意味着体系结构的组件可以位于多个服务器中。</li><li>按需代码：客户端必须能够获取可执行代码作为响应。 这是一个可选约束。</li></ol><p>基于REST的Web服务被称为RESTful Web服务。 在这些应用程序中，每个组件都是一种资源，可以使用HTTP标准方法通过公共接口访问这些资源。 以下四种HTTP方法通常用于基于REST的体系结构中：</p><ol><li>GET-对资源的只读访问。</li><li>POST —创建一个新资源。</li><li>DELETE—删除资源。</li><li>PUT-更新现有资源&#x2F;创建新资源。</li></ol><p>RESTFul风格API所有的操作都是一个动词，对应HTTP请求的一种类型。每一个操作都定义了对操作的资源的某种行为。这种抽象，特别适合相当多的Web应用，后台是一个数据库，每一个REST的端点对应了一张数据库的表，很自然的利用REST操作来实现表的增删查改。</p><p>当然RESTFul的风格也有它的不足：</p><ul><li>不是所有的应用操作都可以用资源的增删查改来对应，在实际的开发中经常会需要把一个操作映射为一个资源这种不伦不类的行为。</li><li>REST是同步服务，如果需要可能要引入回调机制。例如Webhook。</li><li>REST只提供客户端调用服务器的选项，不支持服务器端发起请求。</li></ul><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>GraphQL是一个开源的API数据查询和操作语言及实现为了实现上述操作的相应运行环境。 2012年，GraphQL由Facebook内部开发，2015年公开公布。 2018年11月7日，Facebook将GraphQL项目转移到新成立的GraphQL基金会 。</p><p>GraphQL规范概述了5条设计原则，这使其成为现代前端开发的精心设计的解决方案:</p><ul><li>查询是分层结构的，具有分层和嵌套字段，查询与响应数据一对一匹配。 查询和响应的形状像树，可以查询每个项目的其他嵌套字段。</li><li>该结构以产品为中心，着重于前端希望如何接收数据，并构建交付所需的运行时。 这样一来，就可以向后端请求一个所需的所有数据，然后让服务器根据GraphQL的规范从不同的端点获取数据。</li><li>它使用特定于应用程序的类型系统，使开发人员能够确保查询使用有效类型，并且在执行之前在语法上正确。</li><li>GraphQL查询是在客户端指定的，因此客户端确切知道它将以什么格式接收数据。</li><li>带有GraphQL的服务器结构必须是自省的，或者可由GraphQL本身查询。 这将启用功能强大的开发人员工具，例如GraphiQL或GraphQL Playground，这两种工具都将使开发人员能够准确查看哪些查询和字段可供他们在服务器中使用。</li></ul><p>像RESTful API一样，GraphQL API旨在处理HTTP请求并提供对这些请求的响应。 但是，相似之处到此结束。 在REST API建立在请求方法和端点之间的连接上的情况下，GraphQL API设计为仅使用一个始终通过POST请求查询的端点，通常使用URL <a href="http://yourdomain.com/graphql%E3%80%82">yourdomain.com&#x2F;graphql。</a></p><p>达到GraphQL端点后，客户端请求的负担将完全在请求主体内处理。 该请求主体必须遵守GraphQL规范，并且API必须具有适当的服务器端逻辑来处理这些请求并提供适当的响应。 与RESTful API相比，这提供了更流畅的客户端体验，后者可能要求客户端对多个数据进行多次请求，并在数据返回后进行操作。</p><p>GraphQL提供的性能优于REST API，可以为前端开发人员带来回报。 使用GraphQL规范创建服务器可能需要更多设置和编写预测性服务器端逻辑来解析和处理请求。 尽管GraphQL的安装成本可能会高于传统的REST架构，但更具可维护性的代码，强大的开发工具以及简化的客户端查询，这些都是不错的收益。</p><p>除了灵活性这个最大的优点外，GraphQL还有以下的优点：</p><ul><li>声明性的数据获取，避免了客户端和服务器端的额外交互</li><li>优秀的开发体验，不需要版本控制，因为引入新的字段不会影响到API查询。同时客户端和服务器端的团队可以并行的独立工作。</li><li>强类型的GraphQL模式使得代码可预测，并及早发现错误。</li></ul><p>当然，GraphQL也不是没有缺点：</p><ul><li>使用GraphQL，如果您需要查找有关列表或记录集合的信息，则处理起来会很棘手。 例如，如果您想获取包含其地址的用户列表的详细信息，则它将执行n + 1个查询。 一个用于用户列表，然后n查询每个用户的地址。现在它会严重影响性能，因此必须非常小心地处理它。</li><li>很难缓存，缓存API响应的目的主要是为了更快地从将来的请求中获取响应。 与GraphQL不同，RESTful API可以利用HTTP规范中内置的缓存。 正如前面提到的，GraphQL查询可以请求资源的任何字段，因此缓存本质上是困难的。</li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>gRPC是一个开源的远程过程调用框架，用于在服务之间进行高性能的通信。 这是将以不同语言编写的服务与可插拔支持（用于负载平衡，跟踪，运行状况检查和身份验证）相连接的有效方法。 默认情况下，gRPC使用Protobuf（协议缓冲区）序列化结构化数据。 通常，对于微服务体系结构，gRPC被认为是REST协议的更好替代方案。 gRPC中的” g”可以归因于最初开发该技术的Google。</p><p>gRPC是对传统RPC框架的改编。 那么，它与现有的RPC框架有何不同？</p><p>最重要的区别是gRPC使用protobuf 协议缓冲区作为接口定义语言进行序列化和通信，而不是JSON &#x2F; XML。 协议缓冲区可以描述数据的结构，并且可以从该描述中生成代码，以生成或解析表示结构化数据的字节流。 这就是为什么gRPC首选多语言（使用不同技术实现）的Web应用程序的原因。 二进制数据格式使通信更轻松。 gRPC也可以与其他数据格式一起使用，但是首选的是protobuf。</p><p>同样，gRPC建立在HTTP &#x2F; 2之上，它支持双向通信以及传统的请求&#x2F;响应。 gRPC允许服务器和客户端之间的松散耦合。 在实践中，客户端打开与gRPC服务器的长期连接，并且将为每个RPC调用打开一个新的HTTP &#x2F; 2流。</p><p>与使用JSON（主要是JSON）的REST不同，gRPC使用Protobuf，这是编码数据的更好方法。 由于JSON是基于文本的格式，因此它比protobuf格式的压缩数据要重得多。与REST相比，gRPC的另一个显着改进是它使用HTTP 2作为其传输协议。 REST使用的HTTP 1.1基本上是一个请求-响应模型。 gRPC利用HTTP 2的双向通信功能以及传统的响应请求结构。 在HTTP 1.1中，当多个请求来自多个客户端时，它们将被一一处理。 这会降低系统速度。 HTTP 2允许多路复用，因此可以同时处理多个请求和响应。</p><p>gRPC的开发模式和之前提到的CORBA有些类似。Protobuf充当了IDL的角色，然后利用工具生成各种语言的代码，最后在生成的代码上实现服务器端和客户端的逻辑。</p><p>gRPC的优点是：</p><ul><li>出色的性能，因为采用protobuf编码和http&#x2F;2</li><li>支持服务器端和客户端的双向通信</li><li>易用，相比REST开发，需要更少的代码</li></ul><p>缺点：</p><ul><li>更陡峭的学习曲线</li><li>支持的语言的种类没有REST多，当然它还在发展中</li><li>因为需要Protobuf的编译，这带来了服务器和客户端一定的耦合，因为接口变动的时候需要重新编译生成代码。REST的化，基于不同的工具链可能由不同的解决方案</li></ul><p>因为其高性能，gRPC更适合被用于系统内部组件的通信选择。比如微服务架构中，对外的服务采用了REST或者GraphQL的API，而内部微服务之间使用的是gRPC。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转自 &lt;a href=&quot;https://my.oschina.net/taogang/blog/4313908&quot;&gt;https://my.oschina.net/taogang/blog/4313908&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最早在Unix&amp;#x2F;Linux的编程领域，提
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E3%80%81redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <id>http://example.com/2022/12/12/开发笔记/数据库/mysql、redis开启远程访问/</id>
    <published>2022-12-12T17:36:23.245Z</published>
    <updated>2022-12-12T17:36:23.245Z</updated>
    
    <content type="html"><![CDATA[<p>要在本地使用云服务器中的mysql、redis服务，需要开启远程访问，阿里云还需要在控制台中开放3306、6379访问端口。</p><h4 id="1、mysql开启远程访问"><a href="#1、mysql开启远程访问" class="headerlink" title="1、mysql开启远程访问"></a>1、mysql开启远程访问</h4><p>默认情况下，mysql帐号不允许从远程登陆，只能在localhost登录。 在localhost登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，将”localhost”改为”%”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">   Enter password:</span><br><span class="line">    ……</span><br><span class="line">   mysql&gt;</span><br><span class="line">　　mysql&gt;update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br><span class="line"></span><br><span class="line">　　mysql&gt;select host, user from user;</span><br><span class="line">　</span><br></pre></td></tr></table></figure><h4 id="2、redis开启远程访问"><a href="#2、redis开启远程访问" class="headerlink" title="2、redis开启远程访问"></a>2、redis开启远程访问</h4><p>防火墙开放6379端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line">添加字段：</span><br><span class="line">-A RH-Firewall-1-INPUT -m state NEW -m tcp -dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure><p>修改redis配置文件<br>vim &#x2F;etc&#x2F;redis.conf</p><ul><li><code>bind127.0.0.1</code> 这一行注释掉</li><li><code>protected-mode yes</code> 改为 <code>protected-mode no</code></li></ul><p>保存后重启：<br>sysremctl restart redis</p><p><strong>2020-6-1：由于鄙人暴露了mysql到公网上，不加约束、放荡不羁，如今数据库已遭到比特币勒索，血与泪的教训，以后要多加规范，防火防盗防小人</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要在本地使用云服务器中的mysql、redis服务，需要开启远程访问，阿里云还需要在控制台中开放3306、6379访问端口。&lt;/p&gt;
&lt;h4 id=&quot;1、mysql开启远程访问&quot;&gt;&lt;a href=&quot;#1、mysql开启远程访问&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据库" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/12/12/开发笔记/k8s配置文件详解/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s-yaml文件"><a href="#k8s-yaml文件" class="headerlink" title="k8s yaml文件"></a>k8s yaml文件</h2><h3 id="yaml基础"><a href="#yaml基础" class="headerlink" title="yaml基础"></a>yaml基础</h3><p>YAML是专门用来写配置文件的语言，非常简洁和强大，使用比json更方便。它实质上是一种通用的数据串行化格式。</p><p>YAML语法规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大小写敏感</span><br><span class="line">使用缩进表示层级关系</span><br><span class="line">缩进时不允许使用Tal键，只允许使用空格</span><br><span class="line">缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class="line">”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略　</span><br></pre></td></tr></table></figure><p>在Kubernetes中，只需要知道两种结构类型即可：Lists和Maps</p><p>YAML Maps：</p><p>Map顾名思义指的是字典，即一个Key:Value 的键值对信息。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">　　注：---为可选的分隔符 ，当需要在一个文件中定义多个结构的时候需要使用。上述内容表示有两个键apiVersion和kind，分别对应的值为v1和Pod。</span><br></pre></td></tr></table></figure><p>Maps的value既能够对应字符串也能够对应一个Maps。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br></pre></td></tr></table></figure><p>List即列表，说白了就是数组，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">args</span><br><span class="line"> -beijing</span><br><span class="line"> -shanghai</span><br><span class="line"> -shenzhen</span><br><span class="line"> -guangzhou</span><br></pre></td></tr></table></figure><p>当然Lists的子项也可以是Maps，Maps的子项也可以是List，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kube100-site</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: front-end</span><br><span class="line">      image: nginx</span><br><span class="line">      ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">    - name: flaskapp-demo</span><br><span class="line">      image: jcdemo/flaskapp</span><br><span class="line">      ports: 8080</span><br></pre></td></tr></table></figure><h3 id="k8s-yaml"><a href="#k8s-yaml" class="headerlink" title="k8s yaml"></a>k8s yaml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1             #指定api版本，此值必须在kubectl apiversion中  </span><br><span class="line">kind: Pod                  #指定创建资源的角色/类型  </span><br><span class="line">metadata:                  #资源的元数据/属性  </span><br><span class="line">  name: web04-pod          #资源的名字，在同一个namespace中必须唯一  </span><br><span class="line">  labels:                  #设定资源的标签，详情请见http://blog.csdn.net/liyingke112/article/details/77482384</span><br><span class="line">    k8s-app: apache  </span><br><span class="line">    version: v1  </span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;  </span><br><span class="line">  annotations:             #自定义注解列表  </span><br><span class="line">    - name: String         #自定义注解名字  </span><br><span class="line">spec:#specification of the resource content 指定该资源的内容  </span><br><span class="line">  restartPolicy: Always    #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器  </span><br><span class="line">  nodeSelector:            #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1  </span><br><span class="line">    zone: node1  </span><br><span class="line">  containers:  </span><br><span class="line">  - name: web04-pod        #容器的名字  </span><br><span class="line">    image: web:apache      #容器使用的镜像地址  </span><br><span class="line">    imagePullPolicy: Never #三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略，</span><br><span class="line">                           # Always，每次都检查</span><br><span class="line">                           # Never，每次都不检查（不管本地是否有）</span><br><span class="line">                           # IfNotPresent，如果本地有就不检查，如果没有就拉取</span><br><span class="line">    command: [&#x27;sh&#x27;]        #启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT  </span><br><span class="line">    args: [&quot;$(str)&quot;]       #启动容器的命令参数，对应Dockerfile中CMD参数  </span><br><span class="line">    env:                   #指定容器中的环境变量  </span><br><span class="line">    - name: str            #变量的名字  </span><br><span class="line">      value: &quot;/etc/run.sh&quot; #变量的值  </span><br><span class="line">    resources:             #资源管理，请求请见http://blog.csdn.net/liyingke112/article/details/77452630</span><br><span class="line">      requests:            #容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行  </span><br><span class="line">        cpu: 0.1           #CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m）</span><br><span class="line">        memory: 32Mi       #内存使用量  </span><br><span class="line">      limits:              #资源限制  </span><br><span class="line">        cpu: 0.5  </span><br><span class="line">        memory: 32Mi  </span><br><span class="line">    ports:  </span><br><span class="line">    - containerPort: 80    #容器开放对外的端口</span><br><span class="line">      name: httpd          #名称</span><br><span class="line">      protocol: TCP  </span><br><span class="line">    livenessProbe:         #pod内容器健康检查的设置，详情请见http://blog.csdn.net/liyingke112/article/details/77531584</span><br><span class="line">      httpGet:             #通过httpget检查健康，返回200-399之间，则认为容器正常  </span><br><span class="line">        path: /            #URI地址  </span><br><span class="line">        port: 80  </span><br><span class="line">        #host: 127.0.0.1   #主机地址  </span><br><span class="line">        scheme: HTTP  </span><br><span class="line">      initialDelaySeconds: 180 #表明第一次检测在容器启动后多长时间后开始  </span><br><span class="line">      timeoutSeconds: 5    #检测的超时时间  </span><br><span class="line">      periodSeconds: 15    #检查间隔时间  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常  </span><br><span class="line">      #  command:  </span><br><span class="line">      #    - cat  </span><br><span class="line">      #    - /tmp/health  </span><br><span class="line">      #也可以用这种方法  </span><br><span class="line">      #tcpSocket: //通过tcpSocket检查健康   </span><br><span class="line">      #  port: number   </span><br><span class="line">    lifecycle:             #生命周期管理  </span><br><span class="line">      postStart:           #容器运行之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command:  </span><br><span class="line">            - &#x27;sh&#x27;  </span><br><span class="line">            - &#x27;yum upgrade -y&#x27;  </span><br><span class="line">      preStop:             #容器关闭之前运行的任务  </span><br><span class="line">        exec:  </span><br><span class="line">          command: [&#x27;service httpd stop&#x27;]  </span><br><span class="line">    volumeMounts:          #详情请见http://blog.csdn.net/liyingke112/article/details/76577520</span><br><span class="line">    - name: volume         #挂载设备的名字，与volumes[*].name 需要对应    </span><br><span class="line">      mountPath: /data     #挂载到容器的某个路径下  </span><br><span class="line">      readOnly: True  </span><br><span class="line">  volumes:                 #定义一组挂载设备  </span><br><span class="line">  - name: volume           #定义一个挂载设备的名字  </span><br><span class="line">    #meptyDir: &#123;&#125;  </span><br><span class="line">    hostPath:  </span><br><span class="line">      path: /opt           #挂载设备类型为hostPath，路径为宿主机下的/opt,这里设备类型支持很多种  </span><br></pre></td></tr></table></figure><h3 id="k8s-使用过程笔记"><a href="#k8s-使用过程笔记" class="headerlink" title="k8s 使用过程笔记"></a>k8s 使用过程笔记</h3><h5 id="如何进入kubernetes的一个pod"><a href="#如何进入kubernetes的一个pod" class="headerlink" title="如何进入kubernetes的一个pod"></a>如何进入kubernetes的一个pod</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类似于docker</span><br><span class="line">进入docker容器 ：</span><br><span class="line">docker exec -ti  &lt;your-container-name&gt;   /bin/sh</span><br><span class="line"></span><br><span class="line">进入pod：</span><br><span class="line">kubectl exec -ti &lt;your-pod-name&gt;  -n &lt;your-namespace&gt;  -- /bin/sh</span><br></pre></td></tr></table></figure><h5 id="关于k8s使用镜像创建pod的坑"><a href="#关于k8s使用镜像创建pod的坑" class="headerlink" title="关于k8s使用镜像创建pod的坑"></a>关于k8s使用镜像创建pod的坑</h5><p>k8s默认从远程仓库中获取镜像，可以使用镜像获取策略从本地获取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">   - name: test</span><br><span class="line">     image: nginx:1.7.9     #必须带上tag</span><br><span class="line">     imagePullPolicy: Never</span><br></pre></td></tr></table></figure><p>Always 总是拉取镜像</p><p>IfNotPresent 本地有则使用本地镜像,不拉取</p><p>Never 只使用本地镜像，从不拉取，即使本地没有</p><p>如果省略imagePullPolicy 镜像tag为 :latest 策略为always ，否则 策略为 IfNotPresent</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;k8s-yaml文件&quot;&gt;&lt;a href=&quot;#k8s-yaml文件&quot; class=&quot;headerlink&quot; title=&quot;k8s yaml文件&quot;&gt;&lt;/a&gt;k8s yaml文件&lt;/h2&gt;&lt;h3 id=&quot;yaml基础&quot;&gt;&lt;a href=&quot;#yaml基础&quot; class=&quot;
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/session%EF%BC%8Ccookie%EF%BC%8Ctoken%E5%AD%A6%E4%B9%A0%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/12/开发笔记/session，cookie，token学习【转】/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://segmentfault.com/a/1190000017831088">https://segmentfault.com/a/1190000017831088</a></p><h2 id="session，cookie和token究竟是什么"><a href="#session，cookie和token究竟是什么" class="headerlink" title="session，cookie和token究竟是什么"></a>session，cookie和token究竟是什么</h2><h4 id="1-http是一个无状态协议"><a href="#1-http是一个无状态协议" class="headerlink" title="1. http是一个无状态协议"></a>1. http是一个无状态协议</h4><p>什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。坏处是假如我们想要把 <a href="http://www.zhihu.com/login.html">www.zhihu.com/login.html</a> 和 <a href="http://www.zhihu.com/index.html">www.zhihu.com/index.html</a> 关联起来，必须使用某些手段和工具</p><h4 id="2-cookie和session"><a href="#2-cookie和session" class="headerlink" title="2. cookie和session"></a>2. cookie和session</h4><p>2.1 http请求过程</p><p>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下：<br>Set-Cookie: value[; expires&#x3D;date][; domain&#x3D;domain][; path&#x3D;path][; secure]</li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/567D6B03A5704ABCA184CCB2CFA9D8E7?method=download&shareKey=712516258a5c4b9bcc0375ff5e046231" alt="请求过程"></p><p>2.2 注意</p><ul><li>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中</li><li>现在大多都是Session + Cookie的方式，但是只用session不用cookie，或是只用cookie不用session，在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大</li></ul><p>2.3 小结</p><p>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行</p><h4 id="3-token"><a href="#3-token" class="headerlink" title="3. token"></a>3. token</h4><p>3.1 概念</p><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><p>3.2 组成</p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash&#x2F;encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><p>3.3 token认证流程</p><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h4 id="4-token可以抵抗csrf，cookie-session不行"><a href="#4-token可以抵抗csrf，cookie-session不行" class="headerlink" title="4. token可以抵抗csrf，cookie+session不行"></a>4. token可以抵抗csrf，cookie+session不行</h4><p>假如用户正在登录银行网页，登录了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<a href="http://www.bank.com/api/transfer%EF%BC%8Cbody%E4%B8%BAcount=1000&to=Tom%E3%80%82%E5%80%98%E8%8B%A5%E6%98%AFsession+cookie%EF%BC%8C%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%BD%AC%E7%BB%99Tom1000%E5%85%83%E4%BA%86.%E5%9B%A0%E4%B8%BAform">http://www.bank.com/api/transfer，body为count=1000&amp;to=Tom。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form</a> 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h4 id="5-分布式情况下的session和token"><a href="#5-分布式情况下的session和token" class="headerlink" title="5. 分布式情况下的session和token"></a>5. 分布式情况下的session和token</h4><p>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><p>token是无状态的，token字符串里就保存了所有的用户信息。</p><p>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><ul><li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li><li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt只是一个跨域认证的方案</li></ul><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><p>转载自 <a href="https://segmentfault.com/a/1190000015419746">https://segmentfault.com/a/1190000015419746</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分别对Cookie与Session做一个介绍和总结，并分别对两个知识点进行对比分析，让大家对Cookie和Session有一个更深入的了解，并对自己的开发工作中灵活运用带来启示。</p><h2 id="cookie机制"><a href="#cookie机制" class="headerlink" title="cookie机制"></a>cookie机制</h2><p>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。</p><p>具体来说cookie机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的cookie支持。cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。</p><p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p><p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p><p>而session机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。而session提供了方便管理全局变量的方式 。</p><p>session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器。</p><p>就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的session机制更安全些，因为它不会任意读取客户存储的信息。</p><h2 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h2><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p><p>保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p><p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p><h2 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h2><p>Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比较阐明二者的特性以及适用的场所。</p><h4 id="1-存取方式的不同"><a href="#1-存取方式的不同" class="headerlink" title="1. 存取方式的不同"></a>1. 存取方式的不同</h4><p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比较艰难的。</p><p>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p><h4 id="2-隐私策略的不同"><a href="#2-隐私策略的不同" class="headerlink" title="2. 隐私策略的不同"></a>2. 隐私策略的不同</h4><p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</p><p>假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。</p><h4 id="3-有效期上的不同"><a href="#3-有效期上的不同" class="headerlink" title="3. 有效期上的不同"></a>3. 有效期上的不同</h4><p>使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。</p><p>由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。</p><h4 id="4-服务器压力的不同"><a href="#4-服务器压力的不同" class="headerlink" title="4. 服务器压力的不同"></a>4. 服务器压力的不同</h4><p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。</p><p>而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。</p><h4 id="5-浏览器支持的不同"><a href="#5-浏览器支持的不同" class="headerlink" title="5. 浏览器支持的不同"></a>5. 浏览器支持的不同</h4><p>Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。</p><p>假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。</p><p>假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）</p><p>6、跨域支持上的不同<br>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</p><p>仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自 &lt;a href=&quot;https://segmentfault.com/a/1190000017831088&quot;&gt;https://segmentfault.com/a/1190000017831088&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;session，cookie和toke
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/12/开发笔记/一次完整的HTTP请求过程【转】/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在浏览器的地址栏输入 <a href="http://www.linux178.com/">www.linux178.com</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>以Chrome浏览器为例：</p><hr><h4 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h4><p> 首先Chrome浏览器会解析 <a href="http://www.linux178.com/">www.linux178.com</a> 这个域名（准确的叫法应该是主机名）对应的IP地址。怎么解析到对应的IP地址？</p><p> ① Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="http://www.linux178.com/">www.linux178.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p><p>注：我们怎么查看Chrome自身的缓存？可以使用 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns 来进行查看</p><p> ② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.</p><p> 注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig &#x2F;displaydns 来进行查看</p><p> ③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p><p> ④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找到根域的DNS地址，就会向其发起请求（请问<a href="http://www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。">www.linux178.com这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.linux178.com这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.linux178.com这个域名的IP地址，但是我知道linux178.com这个域的DNS地址，你去找它去，于是运营商的DNS又向linux178.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.linux178.com这个域名的IP地址是多少？），这个时候linux178.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.linux178.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.linux178.com对应的IP地址，该进行一步的动作了。</a></p><p> 注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤（以下是针对Windows操作系统）：</p><p>⑤ 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p><p>⑥ 如果第⑤步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p><p>⑦ 如果第⑥步也没有查询成功，那么客户端就要进行广播查找</p><p>⑧ 如果第⑦步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><hr><h4 id="2-发起TCP的3次握手"><a href="#2-发起TCP的3次握手" class="headerlink" title="2.发起TCP的3次握手"></a>2.发起TCP的3次握手</h4><p>拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024 &lt; 端口 &lt; 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP&#x2F;IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP&#x2F;IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序（本文就以Nginx为例），最终建立了TCP&#x2F;IP的连接。</p><p><img src="https://note.youdao.com/yws/api/personal/file/DCF671839B464E2EBDEC1EEEB14CE5EF?method=download&shareKey=8d356f928b246d083b2f839834f486b2" alt="image"></p><p>1） Client首先发送一个连接试探，ACK&#x3D;0 表示确认号无效，SYN &#x3D; 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq &#x3D; x 表示Client自己的初始序号（seq &#x3D; 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p><p>2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack &#x3D; x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack&#x3D;1其实是ack&#x3D;0+1,也就是期望客户端的第1个包），seq &#x3D; y 表示Server 自己的初始序号（seq&#x3D;0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p><p>3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack&#x3D; y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq&#x3D; x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p><p>TCP 为什么需要3次握手？</p><p>2个计算机通信是靠协议（目前流行的TCP&#x2F;IP协议）来实现,如果2个计算机使用的协议不一样，那是不能进行通信的，所以这个3次握手就相当于试探一下对方是否遵循TCP&#x2F;IP协议，协商完成后就可以进行通信了，当然这样理解不是那么准确。</p><p>为什么HTTP协议要基于TCP来实现？</p><p>目前在Internet中所有的传输都是通过TCP&#x2F;IP进行的，HTTP协议作为TCP&#x2F;IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。</p><hr><h4 id="3-建立TCP连接后发起http请求"><a href="#3-建立TCP连接后发起http请求" class="headerlink" title="3.建立TCP连接后发起http请求"></a>3.建立TCP连接后发起http请求</h4><p>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成</p><h5 id="1-请求行"><a href="#1-请求行" class="headerlink" title="1) 请求行"></a>1) 请求行</h5><p>请求行分为三个部分：请求方法、请求地址和协议版本</p><p>请求方法：</p><p>HTTP&#x2F;1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>GET: 完整请求一个资源 （常用）</p><p>  HEAD: 仅请求响应首部</p><p>  POST：提交表单  （常用）</p><p>  PUT: (webdav) 上传文件（但是浏览器不支持该方法）</p><p>  DELETE：(webdav) 删除</p><p>  OPTIONS：返回请求的资源所支持的方法的方法</p><p>  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><p>请求地址：</p><p>URL:统一资源定位符，是一种资源位置的抽象唯一识别方法。</p><p>组成：&lt;协议&gt;：&#x2F;&#x2F;&lt;主机&gt;：&lt;端口&gt;&#x2F;&lt;路径&gt;</p><p>端口和路径有时可以省略（HTTP默认端口号是80），GET请求可能会带参数</p><p>什么是URL、URI、URN？<br>URI  Uniform Resource Identifier 统一资源标识符。<br>格式：  scheme:&#x2F;&#x2F;[username:password@]HOST:port&#x2F;path&#x2F;to&#x2F;source</p><p>URL  Uniform Resource Locator 统一资源定位符<br>格式：  <a href="http://www.magedu.com/downloads/nginx-1.5.tar.gz">http://www.magedu.com/downloads/nginx-1.5.tar.gz</a></p><p>URN  Uniform Resource Name 统一资源名称</p><p>URL和URN 都属于 URI</p><p>协议版本：</p><p>协议版本的格式为：HTTP&#x2F;主版本号.次版本号</p><p>协议有：</p><p>http&#x2F;0.9: stateless</p><p>http&#x2F;1.0: MIME, keep-alive (保持连接), 缓存</p><p>http&#x2F;1.1: 更多的请求方法，更精细的缓存控制，持久连接(persistent connection) 比较常用</p><hr><h5 id="2-请求头部"><a href="#2-请求头部" class="headerlink" title="2) 请求头部"></a>2) 请求头部</h5><p>请求头部为请求报文添加了一些附加信息，如token等，由“名&#x2F;值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><p>下面是Chrome发起的http请求报文头部信息：</p><p><img src="https://note.youdao.com/yws/api/personal/file/8A64C49298E4491CB00EEFEB9F0912F1?method=download&shareKey=7afada5151ba5d6873064b543a997589" alt="http request header"></p><p>Accept  就是告诉服务器端，我接受那些MIME类型</p><p>Accept-Encoding  这个看起来是接受那些压缩方式的文件</p><p>Accept-Lanague   告诉服务器能够发送哪些语言</p><p>Connection       告诉服务器支持keep-alive特性</p><p>Cookie           每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端</p><p>Host             用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机，这里就是用来标识要访问那个虚拟主机。</p><p>User-Agent       用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等  </p><br/><p>条件请求首部：</p><p>If-Modified-Since 是浏览器向服务器端询问某个资源文件如果自从什么时间修改过，那么重新发给我，这样就保证服务器端资源文件更新时，浏览器再次去请求，而不是使用缓存中的文件</p><p>安全请求首部：</p><p>Authorization: 客户端提供给服务器的认证信息；</p><br/><p>什么是MIME？</p><p>MIME（Multipurpose Internet Mail Extesions 多用途互联网邮件扩展）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息，这个标准被定义在RFC 2045、RFC 2046、RFC 2047、RFC 2048、RFC 2049等RFC中。 由RFC 822转变而来的RFC 2822，规定电子邮件标准并不允许在邮件消息中使用7位ASCII字符集以外的字符。正因如此，一些非英语字符消息和二进制文件，图像，声音等非文字消息都不能在电子邮件中传输。MIME规定了用于表示各种各样的数据类型的符号化方法。 此外，在万维网中使用的HTTP协议中也使用了MIME的框架，标准被扩展为互联网媒体类型。</p><p>MIME 遵循以下格式：major&#x2F;minor 主类型&#x2F;次类型 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image/jpg</span><br><span class="line">image/gif</span><br><span class="line">text/html</span><br><span class="line">video/quicktime</span><br><span class="line">appliation/x-httpd-php</span><br></pre></td></tr></table></figure><hr><h5 id="3-请求数据"><a href="#3-请求数据" class="headerlink" title="3) 请求数据"></a>3) 请求数据</h5><p>可选部分，比如GET请求就没有请求数据。</p><h2 id="下面是一个POST方法的请求报文："><a href="#下面是一个POST方法的请求报文：" class="headerlink" title="下面是一个POST方法的请求报文："></a>下面是一个POST方法的请求报文：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST 　/index.php　HTTP/1.1 　　 请求行 </span><br><span class="line">Host: localhost </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头 </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 </span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5 </span><br><span class="line">Accept-Encoding: gzip, deflate </span><br><span class="line">Connection: keep-alive </span><br><span class="line">Referer: http://localhost/ </span><br><span class="line">Content-Length：25 </span><br><span class="line">Content-Type：application/x-www-form-urlencoded </span><br><span class="line">　　空行 </span><br><span class="line">username=aa&amp;password=1234　　请求数据</span><br></pre></td></tr></table></figure></h2><h4 id="4-服务器端响应http请求，浏览器得到html代码"><a href="#4-服务器端响应http请求，浏览器得到html代码" class="headerlink" title="4.服务器端响应http请求，浏览器得到html代码"></a>4.服务器端响应http请求，浏览器得到html代码</h4><p>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><p>1)状态行<br>由3部分组成，分别为：协议版本，状态码，状态码描述。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><p>状态码</p><p>1xx: 信息性状态码</p><pre><code>100, 101</code></pre><p>2xx: 成功状态码</p><pre><code>200OK请求成功。一般用于GET与POST请求201Created已创建。成功请求并创建了新的资源202Accepted已接受。已经接受请求，但未处理完成</code></pre><p>3xx: 重定向状态码</p><pre><code>301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;302: 临时重定向，显式重定向, Location响应首部的值为新的URL304：Not Modified  未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，                    告诉浏览器，你不用请求该资源，直接使用本地的资源即可。</code></pre><p>4xx: 客户端错误状态码</p><pre><code>400：Bad Request客户端请求的语法错误，服务器无法理解401：Unauthorized请求要求用户的身份认证403：Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求404: Not Found  请求的URL资源并不存在</code></pre><p>5xx: 服务器端错误状态码</p><pre><code>500: Internal Server Error  服务器内部错误501：Not Implemented服务器不支持请求的功能，无法完成请求502: Bad Gateway  前面代理服务器联系不到后端的服务器时出现504：Gateway Timeout  这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应</code></pre><p>2.响应头部<br>与请求头部类似，为响应报文添加了一些附加信息</p><p>3.响应数据<br>用于存放需要返回给客户端的数据信息。</p><p><img src="https://note.youdao.com/yws/api/personal/file/9961EAC9AE7346CCB188AEEF8D7DBF45?method=download&shareKey=7ec4caa1f9d7133568247c1b2cd569bb" alt="http响应头"></p><p>Connection            使用keep-alive特性</p><p>Content-Encoding      使用gzip方式对资源压缩</p><p>Content-type          MIME类型为html类型，字符集是 UTF-8</p><p>Date                  响应的日期</p><p>Server                使用的WEB服务器</p><p>Transfer-Encoding:chunked   分块传输编码 是http中的一种数据传输机制，允许HTTP由网页服务器发送给客户端应用（通常是网页浏览器）的数据可以分成多个部分，分块传输编码只在HTTP协议1.1版本（HTTP&#x2F;1.1）中提供</p><p>Vary  这个可以参考（<a href="http://blog.csdn.net/tenfyguo/article/details/5939000%EF%BC%89">http://blog.csdn.NET/tenfyguo/article/details/5939000）</a></p><p>X-Pingback  参考（<a href="http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html%EF%BC%89">http://blog.sina.com.cn/s/blog_bb80041c0101fmfz.html）</a></p><hr><p>那到底服务器端接收到http请求后是怎么样生成html文件？</p><p>假设服务器端使用nginx+PHP(fastcgi)架构提供服务</p><p>① nginx读取配置文件</p><p>我们在浏览器的地址栏里面输入的是 <a href="http://www.linux178.com/">http://www.linux178.com</a> （http:&#x2F;&#x2F;可以不用输入，浏览器会自动帮我们添加），其实完整的应该是<a href="http://www.linux178.com./">http://www.linux178.com./</a> 后面还有个点（这个点代表就是根域，一般情况下我们不用输入，也不显示）,后面的&#x2F;也是不用添加，浏览器会自动帮我们添加（且看第3部那个图里面的URL），那么实际请求的URL是<a href="http://www.linux178.com/%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A5%BD%E4%BA%86Nginx%E5%9C%A8%E6%94%B6%E5%88%B0">http://www.linux178.com/，那么好了Nginx在收到</a> 浏览器 GET &#x2F; 请求时，会读取http请求里面的头部信息，根据Host来匹配 自己的所有的虚拟主机的配置文件的server_name,看看有没有匹配的，有匹配那么就读取该虚拟主机的配置，发现如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /web/echo</span><br></pre></td></tr></table></figure><p>通过这个就知道所有网页文件的就在这个目录下 这个目录就是&#x2F; 当我们<a href="http://www.linux178.com/%E6%97%B6%E5%B0%B1%E6%98%AF%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BE%8B%E5%A6%82%E8%AE%BF%E9%97%AEhttp://www.linux178.com/index.html,%E9%82%A3%E4%B9%88%E4%BB%A3%E8%A1%A8/web/echo%E4%B8%8B%E9%9D%A2%E6%9C%89%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8F%ABindex.html">http://www.linux178.com/时就是访问这个目录下面的文件，例如访问http://www.linux178.com/index.html,那么代表/web/echo下面有个文件叫index.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index index.html index.htm index.php</span><br></pre></td></tr></table></figure><p>通过这个就能得知网站的首页文件是那个文件，也就是我们在入<a href="http://www.linux178.com/">http://www.linux178.com/</a> ，nginx就会自动帮我们把index.html（假设首页是index.php 当然是会尝试的去找到该文件，如果没有找到该文件就依次往下找，如果这3个文件都没有找到，那么就抛出一个404错误）加到后面，那么添加之后的URL是&#x2F;index.php,然后根据后面的配置进行处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php(\/.*)*$ &#123;</span><br><span class="line">   root /web/echo;</span><br><span class="line">   fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">   fastcgi_index  index.php;</span><br><span class="line">   astcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">   include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段配置指明凡是请求的URL中匹配（这里是启用了正则表达式进行匹配） *.php后缀的（后面跟的参数）都交给后端的fastcgi进程进行处理。</p><p>② 把php文件交给fastcgi进程去处理<br>于是nginx把&#x2F;index.php这个URL交给了后端的fastcgi进程处理，等待fastcgi处理完成后（结合数据库查询出数据，填充模板生成html文件）返回给nginx一个index.html文档，Nginx再把这个index.html返回给浏览器，于是乎浏览器就拿到了首页的html代码，同时nginx写一条访问日志到日志文件中去。</p><p>注1：nginx是怎么找index.php文件的？</p><p>当nginx发现需要&#x2F;web&#x2F;echo&#x2F;index.php文件时，就会向内核发起IO系统调用(因为要跟硬件打交道，这里的硬件是指硬盘，通常需要靠内核来操作，而内核提供的这些功能是通过系统调用来实现的)，告诉内核，我需要这个文件,内核从&#x2F;开始找到web目录，再在web目录下找到echo目录，最后在echo目录下找到index.php文件，于是把这个index.php从硬盘上读取到内核自身的内存空间，然后再把这个文件复制到nginx进程所在的内存空间，于是乎nginx就得到了自己想要的文件了。</p><p>注2：寻找文件在文件系统层面是怎么操作的？</p><p>比如nginx需要得到&#x2F;web&#x2F;echo&#x2F;index.php这个文件</p><p>每个分区（像ext3 ext3等文件系统，block块是文件存储的最小单元 默认是4096字节）都是包含元数据区和数据区，每一个文件在元数据区都有元数据条目（一般是128字节大小），每一个条目都有一个编号，我们称之为inode（index node 索引节点），这个inode里面包含 文件类型、权限、连接次数、属主和数组的ID、时间戳、这个文件占据了那些磁盘块也就是块的编号（block，每个文件可以占用多个block,并且block不一定是连续的，每个block是有编号的），如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/62D4C30149744CCBBB205E93ECD804BB?method=download&shareKey=87e1aaf71c8e7d88f224dc2bad6b7f3f" alt="数据区"></p><p> 还有一个要点：目录其实也普通是文件，也需要占用磁盘块，目录不是一个容器。你看默认创建的目录就是4096字节，也就说只需要占用一个磁盘块，但这是不确定的。所以要找到目录也是需要到元数据区里面找到对应的条目，只有找到对应的inode就可找到目录所占用的磁盘块。</p><p> 那到底目录里面存放着什么，难道不是文件或者其他目录吗？</p><p> 其实目录存着这么一张表（姑且这么理解），里面放着 目录或者文件的名称和对应的inode号（暂时称之为映射表）,如</p><table><thead><tr><th>文件名</th><th>innode号</th></tr></thead><tbody><tr><td>test1.txt</td><td>100</td></tr><tr><td>test2.txt</td><td>101</td></tr></tbody></table><p>假设</p><p>&#x2F;           在数据区占据 1、2号block ，&#x2F;其实也是一个目录 里面有3个目录  web 111</p><p>web         占据 5号block  是目录 里面有2个目录 echo data</p><p>echo        占据 11号 block  是目录  里面有1个文件 index.php</p><p>index.php   占据 15 16号 block  是文件</p><p>其在文件系统中分布如下图所示</p><p><img src="https://note.youdao.com/yws/api/personal/file/6311A126C78449E789B73AABB91AEF88?method=download&shareKey=03739ab95a25d66303f5a35f9d216e77" alt="文件系统分布"></p><p>那么内核究竟是怎么找到index.php这个文件的呢？</p><p>内核拿到nginx的IO系统调用要获取&#x2F;web&#x2F;echo&#x2F;index.php这个文件请求之后</p><p>① 内核读取元数据区 &#x2F; 的inode，从inode里面读取&#x2F;所对应的数据块的编号，然后在数据区找到其对应的块（1 2号块），读取1号块上的映射表找到web这个名称在元数据区对应的inode号</p><p>② 内核读取web对应的inode（3号），从中得知web在数据区对应的块是5号块，于是到数据区找到5号块，从中读取映射表，知道echo对应的inode是5号，于是到元数据区找到5号inode</p><p>③ 内核读取5号inode，得到echo在数据区对应的是11号块，于是到数据区读取11号块得到映射表，得到index.php对应的inode是9号</p><p>④ 内核到元数据区读取9号inode，得到index.php对应的是15和16号数据块，于是就到数据区域找到15 16号块，读取其中的内容，得到index.php的完整内容</p><hr><h4 id="5-浏览器解析html代码，并请求html代码中的资源"><a href="#5-浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="5. 浏览器解析html代码，并请求html代码中的资源"></a>5. 浏览器解析html代码，并请求html代码中的资源</h4><p>浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js&#x2F;css&#x2F;image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><br/><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><p><img src="https://note.youdao.com/yws/api/personal/file/040A9AB67B684F2C910A080CE06A29EB?method=download&shareKey=da1371351e72b4bb34552edacabc0a3d" alt="浏览器静态资源请求"></p><p>详细的浏览器工作原理请看：<a href="http://kb.cnblogs.com/page/129756/">http://kb.cnblogs.com/page/129756/</a> </p><h4 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6.浏览器对页面进行渲染呈现给用户"></a>6.浏览器对页面进行渲染呈现给用户</h4><p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p><p>自此一次完整的HTTP事务宣告完成.</p><br/><h4 id="本文出自-“雷纳科斯的博客”-博客，转载自http-linux5588-blog-51cto-com-65280-1351007"><a href="#本文出自-“雷纳科斯的博客”-博客，转载自http-linux5588-blog-51cto-com-65280-1351007" class="headerlink" title="本文出自 “雷纳科斯的博客” 博客，转载自http://linux5588.blog.51cto.com/65280/1351007"></a>本文出自 “雷纳科斯的博客” 博客，转载自<a href="http://linux5588.blog.51cto.com/65280/1351007">http://linux5588.blog.51cto.com/65280/1351007</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们在浏览器的地址栏输入 &lt;a href=&quot;http://www.linux178.com/&quot;&gt;www.linux178.com&lt;/a&gt; ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？&lt;/p&gt;
&lt;p&gt;域名解析 –&amp;gt; 发起TCP的3次握手 –&amp;gt; 建立TCP
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%B8%BA%E4%BB%80%E4%B9%88bk-cmdb%E4%B8%8D%E7%94%A8go%20mod%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2022/12/12/开发笔记/为什么bk-cmdb不用go mod管理/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址 <a href="https://github.com/Tencent/bk-cmdb">https://github.com/Tencent/bk-cmdb</a></p><p>为什么不用官方推荐的 go mod 管理依赖呢？</p><p>bk-cmdb vendor下的一些依赖库都是有修改过的：</p><ul><li>vendor&#x2F;go.mongodb.org&#x2F;mongo-driver&#x2F;mongo&#x2F;session_exposer.go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CmdbPrepareCommitOrAbort set state to InProgress, so that we can commit with other</span></span><br><span class="line"><span class="comment">// operation directly. otherwise mongodriver will do a false commit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CmdbPrepareCommitOrAbort</span><span class="params">(sess Session)</span></span> &#123;</span><br><span class="line">i, ok := sess.(*sessionImpl)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;the session is not type *sessionImpl&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i.clientSession.SetState(<span class="number">2</span>)</span><br><span class="line">i.didCommitAfterStart=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CmdbContextWithSession set the session into context if context includes session info</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CmdbContextWithSession</span><span class="params">(ctx context.Context, sess Session)</span></span> SessionContext &#123;</span><br><span class="line"><span class="keyword">return</span> contextWithSession(ctx, sess)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在mongo driver中添加了CmdbPrepareCommitOrAbort、 CmdbReloadSessio等方法</li></ul><p>这些在官方库是没有的，如果切换 go mod,从官方源获取依赖，肯定是不行的</p><p>issue：<a href="https://github.com/Tencent/bk-cmdb/issues/4748">https://github.com/Tencent/bk-cmdb/issues/4748</a></p><p>如果将修改后的官方库上传到github，应该可以解决go mod难切换的问题</p><p>会不会有版权问题？</p><p>所以，尽量不要修改官方库</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址 &lt;a href=&quot;https://github.com/Tencent/bk-cmdb&quot;&gt;https://github.com/Tencent/bk-cmdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么不用官方推荐的 go mod 管理依赖呢？&lt;/p&gt;
&lt;p&gt;bk-cmdb v
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC%E7%9A%84%20Helloworld/"/>
    <id>http://example.com/2022/12/12/开发笔记/各种语言版本的 Helloworld/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>接触过C、C++、Java、C#、Python、Go，自认为接触过的编程语言很多了，那么各种语言的经典程序 Hello World 都是什么样的呢？</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello,World!&quot;);</span><br><span class="line">    return (0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void main()                 </span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello,World!\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello,World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-2"><a href="#C-2" class="headerlink" title="C#"></a>C#</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace log&#123;</span><br><span class="line">    class helloworld&#123;</span><br><span class="line">        static void  Main(string[] args)&#123;</span><br><span class="line">            Console.WriteLine(&quot;Hello,World!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python2.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &quot;Hello,World!&quot;</span><br></pre></td></tr></table></figure><p>Python3.x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello,World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main()&#123;</span><br><span class="line">    fmt.Printf(&quot;Hello,World!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;Hello,World!&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接触过C、C++、Java、C#、Python、Go，自认为接触过的编程语言很多了，那么各种语言的经典程序 Hello World 都是什么样的呢？&lt;/p&gt;
&lt;h3 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/golang/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://example.com/2022/12/12/开发笔记/golang/学习大纲/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="golang" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/golang/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/2020%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF%EF%BC%89/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/2020 学习计划（成长之路）/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>2020 学习计划（成长之路）</p><p>领导怎么说：</p><p>k8s</p><p>docker</p><p>多读源码</p><p>逛逛开源社区</p><p>提高英文文档阅读能力</p><p>设计模式，工作中体现</p><p>一个优秀的软件架构师，首先一定是一个出色的程序员</p><p>eBay的架构师[RandyShoup先生]是如何总结架构师在项目中的职责的：</p><p>l 具备丰富的一线大中型开发项目的整体规划、方案设计及技术队伍管理经验。</p><p>2 具备软件行业工作经验，熟悉业务领域的技术应用和发展。</p><p>3 具有项目管理理论基础，并在应用系统开发平台和项目管理上有实践经验。</p><p>4 对相关的技术标准有深刻的认识，对软件工程标准规范有良好的把握。 具备C&#x2F;S或B&#x2F;S体系结构或特定领域软件产品开发及架构和设计的经验。</p><p>5 具有面向对象分析（Object-Oriented Analysis, OOA）、设计（OOD）、开发（OOP）能力，精通UML和XML等，熟练使用Rational Rose、PowerDesigner等CASE工具进行设计开发。</p><p>6 对相关编程技术及整个解决方案有深刻的理解及熟练的应用，并且精通架构和设计模式，并在此基础上设计产品框架。</p><p>7 精通大型数据库如Oracle、Sql Server、MySQL等的开发。l 对计算机系统、网络和安全、应用系统架构等有全面的认识。</p><p>8 良好的团队意识和写作精神，有较强的内外沟通能力。</p><p>学习计划：</p><p>\1. Java 基础知识的深入理解</p><p>反射、IO、接口&#x2F;抽象类、内部类、异常、Enum、序列化、static、final、Iterator，Iterable和Comparable,Comparator 等等知识点，虽然都有学习，按实际上还差得很远，还有很多细节与需要深入学习理解。还应该尝试看 Java 源码，源码阅读理解是程序员成长中的必经之路，在源码中可以得到更多细节。最近在看《On Java 8》(事实上的 《Java 编程思想》第五版)这本书，书中讲解真的很详细，内容也非常多，需要反复深入学习。2020 年需要攻克完成这本书，不单单只是阅读浏览一遍，应该要融会贯通，对晦涩难懂的知识多思考，争取掌握。</p><p>\2. 设计模式</p><p>设计模式很重要，支撑起代码的整个生命历程。设计模式应该被理解，被应用到项目中，而不是只是简单的概念层面上的了解，当然，也不应该生搬硬套。能够简化流程，优化项目的设计模式，才是好的设计模式。2020年希望能够掌握常用的设计模式，理解设计模式的套路，加深编程经验。完成《大话设计模式》这本书的学习理解。四人帮(GOF)的书籍《. Design Patterns》可能较之有一定的学习难度，但是经典还是需要了解。</p><p>\3. 微服务、容器等知识</p><p>现如今，微服务非常重要，阿里系的Dubbo+Zookeeper，Spring系的SpringCloud，以及在此基础上二次开发可能更优秀的SpringCloud。主要学习SpringCloud。</p><p>Docker 是微服务中至关重要的工具，也需要学习。之前有比较简单的学习，还需要深入学习，注意在实践中多使用 Docker 技术，争取融会贯通，学以致用。</p><p>kubernetes 也需要学习理解，这是基于容器的集群管理平台，现在事实上的标准，需要掌握。主要通过网课学习。</p><p>\4. 分布式架构</p><p>分布式缓存、分布式存储、分布式锁、幂等性、分布式事务、流量削峰、服务容错、服务降级等等，现在的分布式太火了，必须要对分布式有一定的理解和把握。计划是通过网课学习分布式架构。</p><p>\5. 数据库等知识</p><p>常用的关系型数据库有MySQL、Oracle、DB2等，MySQL应该是使用最多的，深入学习和掌握MySQL，是高级程序员的基本要求。还又 Redis、消息中间件等也需要有一定的知识储备。</p><p>\6. 开发工具</p><p>开发工具保证了开发效率，现在基本上离不开开发工具了，一个项目的开发到部署的过程都设计到许多的软件工具。作为使用者和潜在使用者，更应该对它们有深入的了解，就算是最熟悉的 idea, 我也不敢说完全掌握，Idea、maven、git、svn、jenkins、tomcat 等等也需要学习掌握。</p><p>\7. 提高英语水平</p><p>如今流行的编程语言都是贴近英语语法。大家更倾向于写出来的代码是好读易懂的。能够快速的理解原作者的用词，就可以更快的读懂代码结构，这比纯粹的分析编程语法要简单且自然的多。</p><p>能够流畅的阅读英文文档，对于程序员而言，是非常重要的。这也是非常艰难的，英语也确实是我的短板，提高的英语的阅读能力，通过逼迫自己去看，去理解英文来实现，尝试去读英文的工具文档、逛外国的开发论坛，stackoverflow、github。YouTube、Reddit、ins 等也可以多逛逛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020 学习计划（成长之路）&lt;/p&gt;
&lt;p&gt;领导怎么说：&lt;/p&gt;
&lt;p&gt;k8s&lt;/p&gt;
&lt;p&gt;docker&lt;/p&gt;
&lt;p&gt;多读源码&lt;/p&gt;
&lt;p&gt;逛逛开源社区&lt;/p&gt;
&lt;p&gt;提高英文文档阅读能力&lt;/p&gt;
&lt;p&gt;设计模式，工作中体现&lt;/p&gt;
&lt;p&gt;一个优秀的软件架构师，首先
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/JTW%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/JTW详解/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JTW详解</strong></p><p><strong>spring boot集成jwt实现token认证；</strong></p><p>\1. 什么是jwt?</p><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。</p><p>\2. jwt的工作流程</p><p>\1. 用户使用账号和密码发出post请求；</p><p>\2. 服务器使用私钥创建一个jwt；</p><p>\3. 服务器返回这个jwt给浏览器；</p><p>\4. 浏览器将该jwt串在请求头中向服务器发送请求；</p><p>\5. 服务器验证该jwt；</p><p>\6. 返回响应的资源给浏览器。</p><p><img src="C:\Users\14133\AppData\Local\YNote\data\m18378511016@163.com\f5f9098e49bc44e887b4c730a09776c1\jwt.png" alt="img"></p><p>\3. jwt结构</p><p>1）Header 头部：JWT的头部承载两部分信息：token类型和采用的加密算法。</p><p>2）Payload：存放有效信息的地方。</p><p>3）Signature：签证信息。</p><p>（完整见博客<a href="https://www.jianshu.com/p/e88d3f8151db%EF%BC%89">https://www.jianshu.com/p/e88d3f8151db）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JTW详解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring boot集成jwt实现token认证；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\1. 什么是jwt?&lt;/p&gt;
&lt;p&gt;Json web token (JWT), 是为了在网络应用环境间传递声明
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/JVM%E4%B8%8EJava%E7%A8%8B%E5%BA%8F/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/JVM与Java程序/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>当启动一个Java程序时，一个JVM实例也就产生。当该程序关闭退出，这个JVM实例也就随之消亡。</p><p>JVM实例负责运行一个Java程序</p><h4 id="Java虚拟机及程序的生命周期："><a href="#Java虚拟机及程序的生命周期：" class="headerlink" title="Java虚拟机及程序的生命周期："></a>Java虚拟机及程序的生命周期：</h4><p>（1）通过java命令运行一个Java程序时，启动一个Java虚拟机进程；</p><p>（2）Java虚拟机进程从启动到终止的过程，称为Java虚拟机生命周期；</p><p>（3）程序生命周期和Java虚拟机生命周期是一致的，因为Java虚拟机进程从创建起的任务就是执行Java程序。</p><p>（4）每个运行中的Java程序会有独立的Java堆和非堆等物理资源，程序之间的jvm运行时状态是区分的。</p><h4 id="类的加载，连接和初始化："><a href="#类的加载，连接和初始化：" class="headerlink" title="类的加载，连接和初始化："></a>类的加载，连接和初始化：</h4><p>Java程序要使用某个类时，Java虚拟机要确保这个类被加载，连接和运行，其中连接包括验证，准备和解析。</p><p>1、装载：查找并加载类的二进制数据</p><p>装载的最终目标是实现将编译后的class文件（class文件采用字节码，是JVM的机器语言）装入内存运行时数据区的方法区中，并在内存运行时数据区的堆区生成一个class对象，这个对象可以引用到方法区中的类定义</p><p>2、连接</p><p>（1）验证：确保加载类的正确性；</p><p>（2）准备：为静态变量分配内存，并将其初始化为默认值；</p><p>（3）解析：将类中的符号引用转换为直接引用。</p><p>3、初始化：</p><p>类的初始化过程是执行类的初始化语句，包括静态变量的声明语句，以及静态代码块，静态代码块的作用即是为静态变量赋初始化值。</p><p>4、卸载</p><p>只有没有任何引用指向Class对象的时候，这时候才会卸载类，结束类的生命周期。</p><p>装载验证准备解析初始化对象实例化垃圾收集对象终结卸载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当启动一个Java程序时，一个JVM实例也就产生。当该程序关闭退出，这个JVM实例也就随之消亡。&lt;/p&gt;
&lt;p&gt;JVM实例负责运行一个Java程序&lt;/p&gt;
&lt;h4 id=&quot;Java虚拟机及程序的生命周期：&quot;&gt;&lt;a href=&quot;#Java虚拟机及程序的生命周期：&quot; class
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E3%80%90%E8%BD%AC%E3%80%91/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java 归并排序【转】/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>归并排序是一种概念上最简单的排序算法，与快速排序一样，归并排序也是基于分治法的。归并排序将待排序的元素序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个子序列。合并两个子序列的过程也就是两路归并。</p><h3 id="2、复杂度"><a href="#2、复杂度" class="headerlink" title="2、复杂度"></a>2、复杂度</h3><p>归并排序是一种稳定的排序算法，归并排序的主要问题在于它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是nlog2n。 </p><p>我们可以通过下图非常容易看懂归并排序的过程： </p><p><img src="https://note.youdao.com/yws/api/personal/file/F94C8510579B48B38D52AC97D3E6C1B7?method=download&shareKey=65d334fbb49d6f315cc8421850dd33a4" alt="归并排序过程"></p><p>时间复杂度：</p><p><img src="https://note.youdao.com/yws/api/personal/file/E039B66FD79B46A4937A8C90D1AD018A?method=download&shareKey=f45e4224c86dbd0af47e81c6b20cb574" alt="归并排序复杂度"></p><h3 id="3、完整Java代码"><a href="#3、完整Java代码" class="headerlink" title="3、完整Java代码"></a>3、完整Java代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    //两路归并算法，两个排好序的子序列合并为一个子序列</span><br><span class="line">    public void merge(int []a,int left,int mid,int right)&#123;</span><br><span class="line">        int []tmp=new int[a.length];//辅助数组</span><br><span class="line">        int p1=left,p2=mid+1,k=left;//p1、p2是检测指针，k是存放指针</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid &amp;&amp; p2&lt;=right)&#123;</span><br><span class="line">            if(a[p1]&lt;=a[p2])</span><br><span class="line">                tmp[k++]=a[p1++];</span><br><span class="line">            else</span><br><span class="line">                tmp[k++]=a[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(p1&lt;=mid) tmp[k++]=a[p1++];//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span><br><span class="line">        while(p2&lt;=right) tmp[k++]=a[p2++];//同上</span><br><span class="line"></span><br><span class="line">        //复制回原素组</span><br><span class="line">        for (int i = left; i &lt;=right; i++) </span><br><span class="line">            a[i]=tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void mergeSort(int [] a,int start,int end)&#123;</span><br><span class="line">        if(start&lt;end)&#123;//当子序列中只有一个元素时结束递归</span><br><span class="line">            int mid=(start+end)/2;//划分子序列</span><br><span class="line">            mergeSort(a, start, mid);//对左侧子序列进行递归排序</span><br><span class="line">            mergeSort(a, mid+1, end);//对右侧子序列进行递归排序</span><br><span class="line">            merge(a, start, mid, end);//合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int[] a = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;;</span><br><span class="line">        mergeSort(a, 0, a.length-1);</span><br><span class="line">        System.out.println(&quot;排好序的数组：&quot;);</span><br><span class="line">        for (int e : a)</span><br><span class="line">            System.out.print(e+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/qq_36442947/article/details/81612870">https://blog.csdn.net/qq_36442947/article/details/81612870</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;h3 id=&quot;1、原理&quot;&gt;&lt;a href=&quot;#1、原理&quot; class=&quot;headerlink&quot; title=&quot;1、原理&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java8新特性/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java8新特性</strong></p><p>（转载自<a href="https://www.runoob.com/java/java8-new-features.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E8%A7%81%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%9D%9E%E5%B8%B8%E8%AF%A6%E7%BB%86%E5%AE%9E%E7%94%A8%EF%BC%89">https://www.runoob.com/java/java8-new-features.html，具体内容见链接，非常详细实用）</a></p><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。</p><p>Java8 新增了非常多的特性，我们主要讨论以下几个：</p><ul><li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li><li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong>新工具</strong> − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li><strong>Stream API</strong> −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li><li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li><strong>Nashorn, JavaScript 引擎</strong> − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Java8新特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（转载自&lt;a href=&quot;https://www.runoob.com/java/java8-new-features.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%86%85%E5%
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java创建线程的4种方式/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h4><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程</p><h3 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2. 同步与异步"></a>2. 同步与异步</h3><p>同步（Synchronous）：同步是指一个进程在执行某个请求的时候，如果该请求需要一段时间才能返回信息，那么这个进程会一直等待下去，直到收到返回信息才继续执行下去。</p><p>异步（Asynchronous）：异步是指进程不需要一直等待下去，而是继续执行下面的操作，不管其他进程的状态，当有信息返回的时候会通知进程进行处理。</p><p>通俗地讲，也就是说，同步需要按部就班地走完一整个流程，完成一整个动作。而异步则不需要按部就班，可以在等待那个动作的时候同时做别的动作</p><h3 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3. 并行与并发"></a>3. 并行与并发</h3><p>并行：时间上是由重叠的，也就是说并行才是真正意义上的同一时刻可以有多个任务同时执行。</p><p>并发：任务在执行的时候，并发是没有时间上的重叠的，两个任务是交替执行的，由于切换的非常快，对于外界调用者来说相当于同一时刻多个任务一起执行了。</p><h3 id="二、Java创建线程的3种方式"><a href="#二、Java创建线程的3种方式" class="headerlink" title="二、Java创建线程的3种方式"></a>二、Java创建线程的3种方式</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h4><ol><li>定义 Thread 类的子类,并重写该类的 run() 方法,该 run() 方法的方法体就代表了线程需要完成的任务.因此把 run() 方法称为线程执行体。</li><li>创建 Thread 子类的实例,即创建了线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">public MyThread() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int i=0;i&lt;10;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread()+&quot;:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyThread mThread1=new MyThread();</span><br><span class="line">MyThread mThread2=new MyThread();</span><br><span class="line">MyThread myThread3=new MyThread();</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 Runnable 接口</h4><ol><li>定义 Runnable 接口的实现类,并重写该接口的 run() 方法,该 run() 方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable 实现类的实例,并以此实例作为 Thread 的target来创建 Thread 对象,该 Thread 对象才是真正的线程对象。</li><li>调用线程对象的 start() 方法来启动该线程。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable&#123;</span><br><span class="line">public static int count=20;</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(count&gt;0) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(200);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;-当前剩余票数:&quot;+count--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyThread Thread1=new MyThread();</span><br><span class="line">Thread mThread1=new Thread(Thread1,&quot;线程1&quot;);</span><br><span class="line">Thread mThread2=new Thread(Thread1,&quot;线程2&quot;);</span><br><span class="line">Thread mThread3=new Thread(Thread1,&quot;线程3&quot;);</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐使用此方式</p><h4 id="3-使用-Callable-和-Future"><a href="#3-使用-Callable-和-Future" class="headerlink" title="3. 使用 Callable 和 Future"></a>3. 使用 Callable 和 Future</h4><ol><li>创建 Callable 接口的实现类,并实现 call() 方法,该 call() 方法将作为线程执行体,且该 call() 方法有返回值,再创建 Callable 实现类的实例。</li><li>使用 FutureTask 类来包装 Callable 对象,该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Callable;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.FutureTask;</span><br><span class="line"> </span><br><span class="line">public class MyThread implements Callable&lt;String&gt; &#123;</span><br><span class="line">private int count = 20;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public String call() throws Exception &#123;</span><br><span class="line">for (int i = count; i &gt; 0; i--) &#123;</span><br><span class="line">        //Thread.yield();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;当前票数：&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">return &quot;sale out&quot;;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">Callable&lt;String&gt; callable  =new MyThread();</span><br><span class="line">FutureTask &lt;String&gt;futureTask=new FutureTask&lt;&gt;(callable);</span><br><span class="line">Thread mThread=new Thread(futureTask);</span><br><span class="line">Thread mThread2=new Thread(futureTask);</span><br><span class="line">Thread mThread3=new Thread(futureTask);</span><br><span class="line">        //mThread.setName(&quot;hhh&quot;);</span><br><span class="line">mThread.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">mThread3.start();</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h4><p>通过 <code>java.util.concurrent.Executors</code> 的工具类可以创建三种类型的普通线程池：</p><h5 id="1-SingleThreadPoolExecutor-单线程池"><a href="#1-SingleThreadPoolExecutor-单线程池" class="headerlink" title="(1)SingleThreadPoolExecutor :单线程池"></a>(1)SingleThreadPoolExecutor :单线程池</h5><p>适用于需要保证顺序执行各个任务的场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-FixThreadPool-int-n-固定大小的线程池"><a href="#2-FixThreadPool-int-n-固定大小的线程池" class="headerlink" title="(2) FixThreadPool(int n); 固定大小的线程池"></a>(2) FixThreadPool(int n); 固定大小的线程池</h5><p>使用于为了满足资源管理需求而需要限制当前线程数量的场合。使用于负载比较重的服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newFixedThreadPool(5);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-CashedThreadPool-缓存线程池"><a href="#5-CashedThreadPool-缓存线程池" class="headerlink" title="(5)CashedThreadPool(); 缓存线程池"></a>(5)CashedThreadPool(); 缓存线程池</h5><p>当提交任务速度高于线程池中任务处理速度时，缓存线程池会不断的创建线程 适用于提交短期的异步小程序，以及负载较轻的服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ExecutorService ex=Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++) &#123;</span><br><span class="line">ex.submit(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int j=0;j&lt;10;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;h4 id=&quot;1-线程与进程&quot;&gt;&lt;a href=&quot;#1-线程与进程&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java序列化与反序列化/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、序列化"><a href="#1、序列化" class="headerlink" title="1、序列化"></a>1、序列化</h4><p>把对象转换为字节序列的过程。</p><h4 id="2、反序列化"><a href="#2、反序列化" class="headerlink" title="2、反序列化"></a>2、反序列化</h4><p>把字节序列恢复为对象的过程。</p><h4 id="3、对象的序列化主要有两种用途："><a href="#3、对象的序列化主要有两种用途：" class="headerlink" title="3、对象的序列化主要有两种用途："></a>3、对象的序列化主要有两种用途：</h4><p>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</p><p>2） 在网络上传送对象的字节序列。</p><h4 id="4、serialVersionUID的作用"><a href="#4、serialVersionUID的作用" class="headerlink" title="4、serialVersionUID的作用"></a>4、serialVersionUID的作用</h4><p>对象序列化的版本号，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量。</p><p>如果没有显式定义serialVersionUID，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件多一个空格，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以class有了修改之后，已修改类的serialVersionUID和之前已经序列化的文件流中的类的的serialVersionUID是不一致的，处于安全机制考虑，程序抛出了错误，并且拒绝载入。</p><p>如果显式定义了serialVersionUID，在序列化后，在类中添加字段，或者方法，不会影响到后期的还原。可以说serialVersionUID是序列化和反序列化之间彼此认识的唯一信物。</p><p>显式地定义serialVersionUID有两种用途：</p><p>1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；</p><p>2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、序列化&quot;&gt;&lt;a href=&quot;#1、序列化&quot; class=&quot;headerlink&quot; title=&quot;1、序列化&quot;&gt;&lt;/a&gt;1、序列化&lt;/h4&gt;&lt;p&gt;把对象转换为字节序列的过程。&lt;/p&gt;
&lt;h4 id=&quot;2、反序列化&quot;&gt;&lt;a href=&quot;#2、反序列化&quot; class
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java异常处理原则/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Java的异常处理原则</strong></p><p>Java异常处理中的“反例”：</p><ol><li>丢弃异常</li></ol><p>捕获了异常却不作任何处理，可以算得上Java编程中的杀手。调用一下printStackTrace算不上“处理异常”。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。</p><ol><li>不指定具体的异常</li></ol><p>用一个catch语句捕获所有的异常。最常见的情形就是使用catch（Exception ex）语句。在catch语句中尽可能指定具体的异常类型，必要时使用多个catch.不要试图处理所有可能出现的异常。 </p><ol><li>占用资源不释放</li></ol><p>如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。Java提供了一个简化这类操作的关键词finally。 保证所有资源都被正确释放。充分运用finally关键词。 </p><ol><li>不说明异常的详细信息</li></ol><p>在出现异常时，最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。 </p><ol><li>过于庞大的try块</li></ol><p>一些新手常常把大量的代码放入单个try块，然后再在catch语句中声明Exception，而不是分离各个可能出现异常的段落并分别捕获其异常。这种做法为分析程序抛出异常的原因带来了困难，因为一大段代码中有太多的地方可能抛出Exception。应尽量减小try块的体积。 </p><ol><li>输出数据不完整</li></ol><p>不完整的数据是Java程序的隐形杀手。出现异常导致输出数据不完整，应该加入提示说明。全面考虑可能出现的异常以及这些异常对执行流程的影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Java的异常处理原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java异常处理中的“反例”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;丢弃异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;捕获了异常却不作任何处理，可以算得上Java编程中的杀手。调用一下printStackTrace算不上“处
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java构造函数细节/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>（1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。</p><p>注意: 有时候无参构造函数是必须的，比如用 @RequestBody 接收参数对象，如果没有无参数构造函数，无法正确接收参数，报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON parse error: Can not construct instance of xxx: no suitable constructor found, can not deserialize from Object value</span><br></pre></td></tr></table></figure><p>（2）. 在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的。因为构造函数的名称都相同。</p><p>构造函数与普通函数的区别：</p><ol><li>一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。</li><li>构造函数是在对象建立时由 jvm 调用, 给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。</li><li>普通函数可以使用对象多次调用，构造函数就在创建对象时调用。</li><li>构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。</li><li>构造函数没有返回值类型。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（1）. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。&lt;/p&gt;
&lt;p&gt;注意: 有时候无参构造函数是必须的，比如用 @RequestBody 接收参数对象，如果没有无参数
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java正则表达式/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<p>一直都有接触正则表达式，但是都是照搬过来使用的程度，没有能系统的学习，也没有留下一些笔记，下次使用还需网上查找资料。此次正好稍微做点记录，方便遗忘后重拾。</p><h3 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1. 什么是正则表达式"></a>1. 什么是正则表达式</h3><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h3 id="2-正则表达式知识点"><a href="#2-正则表达式知识点" class="headerlink" title="2. 正则表达式知识点"></a>2. 正则表达式知识点</h3><ol><li>一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World” 字符串。  </li><li>java.util.regex 包主要包括以下三个类：</li></ol><ul><li><p>Pattern 类：<br>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p>Matcher 类：<br>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><p>以下实例中使用了正则表达式 .<em>runoob.</em> 用于查找字符串中是否包了 runoob 子串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.*;</span><br><span class="line"> </span><br><span class="line">class RegexExample1&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      String content = &quot;I am noob &quot; +</span><br><span class="line">        &quot;from runoob.com.&quot;;</span><br><span class="line"> </span><br><span class="line">      String pattern = &quot;.*runoob.*&quot;;</span><br><span class="line"> </span><br><span class="line">      boolean isMatch = Pattern.matches(pattern, content);</span><br><span class="line">      System.out.println(&quot;字符串中是否包含了 &#x27;runoob&#x27; 子字符串? &quot; + isMatch);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Java-正则表达式语法"><a href="#3-Java-正则表达式语法" class="headerlink" title="3. Java 正则表达式语法"></a>3. Java 正则表达式语法</h3><p>在其他语言中，\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 </p><p>在 Java 中，\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 </p><p>所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \d，而表示一个普通的反斜杠是 \\。</p><table><thead><tr><th align="center">字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</td></tr><tr><td align="center">^</td><td align="center">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td align="center">$</td><td align="center">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr></tbody></table><ul><li>| 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。<br>+ | 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。<br>? | 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。<br>{n} | n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。<br>{n,} | n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。<br>{n,m} | m 和 n 是非负整数，其中 n &lt;&#x3D; m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。<br>? | 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。<br>x|y | 匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。<br>[xyz] | 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。<br>[^xyz] | 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。<br>[a-z] | 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。<br>[^a-z] | 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。<br>\b | 匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。<br>\B | 非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。<br>\cx | 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。<br>\d | 数字字符匹配。等效于 [0-9]。<br>\D | 非数字字符匹配。等效于 [^0-9]。<br>\f | 换页符匹配。等效于 \x0c 和 \cL。<br>\n | 换行符匹配。等效于 \x0a 和 \cJ。<br>\r | 匹配一个回车符。等效于 \x0d 和 \cM。<br>\s | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。<br>\S | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。<br>\t | 制表符匹配。与 \x09 和 \cI 等效。<br>\v | 垂直制表符匹配。与 \x0b 和 \cK 等效。<br>\w | 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。<br>\W | 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</li></ul><h3 id="4-正则表达式应用"><a href="#4-正则表达式应用" class="headerlink" title="4. 正则表达式应用"></a>4. 正则表达式应用</h3><ol><li>匹配字符串，如 手机号校验、邮箱校验</li><li>切割字符串，提取字符串信息</li></ol><p>场景：需要从一串字符串中提取出其中的主机ip信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;ip地址是127.0.0.1:8848，真的，不骗你&quot;</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;(((localhost)|(\\d+.&#123;1&#125;\\d+.&#123;1&#125;\\d+.&#123;1&#125;\\d+))\\:&#123;1&#125;\\d+)&quot;);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line">while (matcher.find())&#123; // 一定要先调用 find()函数！</span><br><span class="line">    host = matcher.group();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>详情见： <a href="https://www.runoob.com/java/java-regular-expressions.html">菜鸟教程：Java 正则表达式</a><br>&amp;emsp;&amp;emsp; &amp;emsp; &amp;ensp;<a href="https://www.cnblogs.com/ggjucheng/p/3423731.html">JAVA正则表达式：Pattern类与Matcher类详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都有接触正则表达式，但是都是照搬过来使用的程度，没有能系统的学习，也没有留下一些笔记，下次使用还需网上查找资料。此次正好稍微做点记录，方便遗忘后重拾。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是正则表达式&quot;&gt;&lt;a href=&quot;#1-什么是正则表达式&quot; class=&quot;header
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/12/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/Java%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://example.com/2022/12/12/开发笔记/java/Java获取时间工具类/</id>
    <published>2022-12-12T17:36:23.241Z</published>
    <updated>2022-12-12T17:36:23.241Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> format：时间格式，例：yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTimeNow</span><span class="params">(String format)</span>&#123;</span><br><span class="line">        Calendar calendar= Calendar.getInstance();</span><br><span class="line">        SimpleDateFormat dateFormat= <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间的前n天</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> format：时间格式，例：yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTimeDayBefore</span><span class="params">(<span class="type">int</span> n, String format)</span>&#123;</span><br><span class="line">        Calendar calendar= Calendar.getInstance();</span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, - n); </span><br><span class="line">        SimpleDateFormat dateFormat= <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更加自由的时间字符串获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 当前时间之间 n 个单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 步进单位，如 Calendar.MONTH(2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> format 时间格式，如：yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getTimeBefore</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> step, String format)</span>&#123;</span><br><span class="line">        Calendar calendar= Calendar.getInstance();</span><br><span class="line">        calendar.add(step, - n); </span><br><span class="line">        SimpleDateFormat dateFormat= <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(format);</span><br><span class="line">        <span class="keyword">return</span> dateFormat.format(calendar.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="开发笔记" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/java/"/>
    
    
  </entry>
  
</feed>

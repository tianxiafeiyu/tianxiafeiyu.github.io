{"meta":{"title":"Dalin blog","subtitle":"","description":"","author":"Dalin","url":"http://example.com"},"pages":[{"title":"Categories","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"README","slug":"技术开发/README","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/README/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/README/","excerpt":"","text":"Dalin bloggithub pages + hexo abouthexo: https://hexo.io/zh-cn/docs/ wikitten: https://github.com/zthxxx/hexo-theme-Wikitten","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"","slug":"技术开发/进程间通信技术","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/进程间通信技术/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/","excerpt":"","text":"转自 https://my.oschina.net/taogang/blog/4313908 最早在Unix&#x2F;Linux的编程领域，提供了进程间通信的手段，例如：管道，信号量，消息队列，套接字（Socket）等。如果你的应用是由不同语言编写的，那么这里只能选择Socket通信作为应用之间的API手段。但是Socket通信是一种非常低Level的通信手段，它以底层的数据包作为抽象和通信内容，很难维护和使用。 早期的进程间通信技术包括： DCOM （ Distributed Component Object Model ）分布式组件对象模型，这个是微软的技术，只能用于Windows平台， 通过网络实现远程对象间的通信 RMI （ Remote Method Call) Java的远程方法调用，这个是Java自己的RPC，只能用于Java应用之间的远程调用。 JNI Java的本地接口， 支持Java应用调用本地方法，这个是跨越语言障碍的，但是仅仅局限于Java应用调用其它的本地应用，不具备互操作性，是个单项通道。 CORBA1991年一种名叫CORBA （ Common Object Request Broker Architecture ） 的技术出现。 CORBA和之前提到的DCOM和RMI类似，都提供了远程的对象&#x2F;方法调用，但是CORBA是一种与语言和实现无关的技术 CORBA定了与语言解耦的系统间通信的标准。开发CORAB的过程从IDL的定义开始，用户通过IDL定义了对象，然后在Server端实现该对象的应用逻辑，在Client端调用该对象。 CORBA存在的主要问题： 对象的生命周期管理比较复杂。远程对象的发现，创建和销毁都会带来问题 整个CORAB的架构比较复杂 XML-RPC &#x2F; SOAPXML-RPC发表于1998年，由UserLand Software（UserLand Software）的Dave Winer及Microsoft共同发表。后来在新的功能不断被引入下，这个标准慢慢演变成为今日的SOAP协议。 下面是一个 XML-RPC的请求&#x2F;响应的例子： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;40&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodResponse&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;South Dakota&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodResponse&gt; SOAP是 Simple Object Access Protocol 的缩写。SOAP为Web服务提供了Web服务协议栈的Messaging Protocol层。它是一个基于XML的协议，由三部分组成： 一个信封，它定义了消息结构以及如何处理它 一组用于表达应用程序定义的数据类型实例的编码规则 表示过程调用和响应的约定 SOAP具有三个主要特征： 可扩展性（安全性和WS-Addressing在开发中） 中立性（SOAP可以通过HTTP，SMTP，TCP，UDP等任何协议进行操作） 独立性（SOAP允许任何编程语言） 作为SOAP过程可以执行的操作的示例，应用程序可以将SOAP请求发送到启用了带有搜索参数的Web服务的服务器（例如，房地产价格数据库）。然后，服务器返回SOAP响应（包含结果数据的XML格式的文档），例如价格，位置，功能。由于生成的数据采用标准化的机器可解析格式，因此发出请求的应用程序可以直接将其集成。 SOAP体系结构由以下几层规范组成： 讯息格式 邮件交换模式（MEP） 底层传输协议绑定 消息处理模型 协议可扩展性 下面是一个SOAP消息的例子： 12345678910111213141516POST /InStock HTTP/1.1Host: www.example.orgContent-Type: application/soap+xml; charset=utf-8Content-Length: 299SOAPAction: &quot;http://www.w3.org/2003/05/soap-envelope&quot;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;soap:Envelope xmlns:soap=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:m=&quot;http://www.example.org&quot;&gt; &lt;soap:Header&gt; &lt;/soap:Header&gt; &lt;soap:Body&gt; &lt;m:GetStockPrice&gt; &lt;m:StockName&gt;T&lt;/m:StockName&gt; &lt;/m:GetStockPrice&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt; 相比较XML-RPC，他的功能更多，当然消息结构也更复杂。 SOAP是W3C推荐的Webservice标准，一度也是非常的流行，但是我们看到基于XML的消息比较复杂，消息本身因为XML的原因，有相当多的开销。于是后面又有了基于JSON的RPC格式。但总的来说，SOAP也已经是昨日黄花，当今的应用构建，你选它的概率应该也不大了。 RESTREST是当今最为流行的API。因为大量的Web应用采用REST作为其API的选择。REST是 Representational State Transfer 的缩写。是Roy Thomas Fielding博士于2000年在他的博士论文中提出来的一种万维网软件架构风格，目的是便于不同软件&#x2F;程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以统一资源标识符访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。目前在三种主流的Web服务实现方案中，因为REST模式与复杂的SOAP和XML-RPC相比更加简洁，越来越多的Web服务开始采用REST风格设计和实现。所以我么可以看到软件的发展，大体是从复杂变得简单，只有简单的东西才会变的更有生命力。 为了使任何应用程序真正实现RESTful，必须遵循六个体系结构约束： 统一接口：意味着必须向Web应用程序中的API使用者提供API接口。 客户端服务器：客户端和服务器必须彼此独立，并且客户端应仅知道资源的URI。 无状态：服务器不得存储与客户端请求相关的任何内容。 客户端负责维护应用程序的状态。 可缓存的：资源必须可缓存。 分层系统：体系结构必须是分层的，这意味着体系结构的组件可以位于多个服务器中。 按需代码：客户端必须能够获取可执行代码作为响应。 这是一个可选约束。 基于REST的Web服务被称为RESTful Web服务。 在这些应用程序中，每个组件都是一种资源，可以使用HTTP标准方法通过公共接口访问这些资源。 以下四种HTTP方法通常用于基于REST的体系结构中： GET-对资源的只读访问。 POST —创建一个新资源。 DELETE—删除资源。 PUT-更新现有资源&#x2F;创建新资源。 RESTFul风格API所有的操作都是一个动词，对应HTTP请求的一种类型。每一个操作都定义了对操作的资源的某种行为。这种抽象，特别适合相当多的Web应用，后台是一个数据库，每一个REST的端点对应了一张数据库的表，很自然的利用REST操作来实现表的增删查改。 当然RESTFul的风格也有它的不足： 不是所有的应用操作都可以用资源的增删查改来对应，在实际的开发中经常会需要把一个操作映射为一个资源这种不伦不类的行为。 REST是同步服务，如果需要可能要引入回调机制。例如Webhook。 REST只提供客户端调用服务器的选项，不支持服务器端发起请求。 GraphQLGraphQL是一个开源的API数据查询和操作语言及实现为了实现上述操作的相应运行环境。 2012年，GraphQL由Facebook内部开发，2015年公开公布。 2018年11月7日，Facebook将GraphQL项目转移到新成立的GraphQL基金会 。 GraphQL规范概述了5条设计原则，这使其成为现代前端开发的精心设计的解决方案: 查询是分层结构的，具有分层和嵌套字段，查询与响应数据一对一匹配。 查询和响应的形状像树，可以查询每个项目的其他嵌套字段。 该结构以产品为中心，着重于前端希望如何接收数据，并构建交付所需的运行时。 这样一来，就可以向后端请求一个所需的所有数据，然后让服务器根据GraphQL的规范从不同的端点获取数据。 它使用特定于应用程序的类型系统，使开发人员能够确保查询使用有效类型，并且在执行之前在语法上正确。 GraphQL查询是在客户端指定的，因此客户端确切知道它将以什么格式接收数据。 带有GraphQL的服务器结构必须是自省的，或者可由GraphQL本身查询。 这将启用功能强大的开发人员工具，例如GraphiQL或GraphQL Playground，这两种工具都将使开发人员能够准确查看哪些查询和字段可供他们在服务器中使用。 像RESTful API一样，GraphQL API旨在处理HTTP请求并提供对这些请求的响应。 但是，相似之处到此结束。 在REST API建立在请求方法和端点之间的连接上的情况下，GraphQL API设计为仅使用一个始终通过POST请求查询的端点，通常使用URL yourdomain.com&#x2F;graphql。 达到GraphQL端点后，客户端请求的负担将完全在请求主体内处理。 该请求主体必须遵守GraphQL规范，并且API必须具有适当的服务器端逻辑来处理这些请求并提供适当的响应。 与RESTful API相比，这提供了更流畅的客户端体验，后者可能要求客户端对多个数据进行多次请求，并在数据返回后进行操作。 GraphQL提供的性能优于REST API，可以为前端开发人员带来回报。 使用GraphQL规范创建服务器可能需要更多设置和编写预测性服务器端逻辑来解析和处理请求。 尽管GraphQL的安装成本可能会高于传统的REST架构，但更具可维护性的代码，强大的开发工具以及简化的客户端查询，这些都是不错的收益。 除了灵活性这个最大的优点外，GraphQL还有以下的优点： 声明性的数据获取，避免了客户端和服务器端的额外交互 优秀的开发体验，不需要版本控制，因为引入新的字段不会影响到API查询。同时客户端和服务器端的团队可以并行的独立工作。 强类型的GraphQL模式使得代码可预测，并及早发现错误。 当然，GraphQL也不是没有缺点： 使用GraphQL，如果您需要查找有关列表或记录集合的信息，则处理起来会很棘手。 例如，如果您想获取包含其地址的用户列表的详细信息，则它将执行n + 1个查询。 一个用于用户列表，然后n查询每个用户的地址。现在它会严重影响性能，因此必须非常小心地处理它。 很难缓存，缓存API响应的目的主要是为了更快地从将来的请求中获取响应。 与GraphQL不同，RESTful API可以利用HTTP规范中内置的缓存。 正如前面提到的，GraphQL查询可以请求资源的任何字段，因此缓存本质上是困难的。 gRPCgRPC是一个开源的远程过程调用框架，用于在服务之间进行高性能的通信。 这是将以不同语言编写的服务与可插拔支持（用于负载平衡，跟踪，运行状况检查和身份验证）相连接的有效方法。 默认情况下，gRPC使用Protobuf（协议缓冲区）序列化结构化数据。 通常，对于微服务体系结构，gRPC被认为是REST协议的更好替代方案。 gRPC中的” g”可以归因于最初开发该技术的Google。 gRPC是对传统RPC框架的改编。 那么，它与现有的RPC框架有何不同？ 最重要的区别是gRPC使用protobuf 协议缓冲区作为接口定义语言进行序列化和通信，而不是JSON &#x2F; XML。 协议缓冲区可以描述数据的结构，并且可以从该描述中生成代码，以生成或解析表示结构化数据的字节流。 这就是为什么gRPC首选多语言（使用不同技术实现）的Web应用程序的原因。 二进制数据格式使通信更轻松。 gRPC也可以与其他数据格式一起使用，但是首选的是protobuf。 同样，gRPC建立在HTTP &#x2F; 2之上，它支持双向通信以及传统的请求&#x2F;响应。 gRPC允许服务器和客户端之间的松散耦合。 在实践中，客户端打开与gRPC服务器的长期连接，并且将为每个RPC调用打开一个新的HTTP &#x2F; 2流。 与使用JSON（主要是JSON）的REST不同，gRPC使用Protobuf，这是编码数据的更好方法。 由于JSON是基于文本的格式，因此它比protobuf格式的压缩数据要重得多。与REST相比，gRPC的另一个显着改进是它使用HTTP 2作为其传输协议。 REST使用的HTTP 1.1基本上是一个请求-响应模型。 gRPC利用HTTP 2的双向通信功能以及传统的响应请求结构。 在HTTP 1.1中，当多个请求来自多个客户端时，它们将被一一处理。 这会降低系统速度。 HTTP 2允许多路复用，因此可以同时处理多个请求和响应。 gRPC的开发模式和之前提到的CORBA有些类似。Protobuf充当了IDL的角色，然后利用工具生成各种语言的代码，最后在生成的代码上实现服务器端和客户端的逻辑。 gRPC的优点是： 出色的性能，因为采用protobuf编码和http&#x2F;2 支持服务器端和客户端的双向通信 易用，相比REST开发，需要更少的代码 缺点： 更陡峭的学习曲线 支持的语言的种类没有REST多，当然它还在发展中 因为需要Protobuf的编译，这带来了服务器和客户端一定的耦合，因为接口变动的时候需要重新编译生成代码。REST的化，基于不同的工具链可能由不同的解决方案 因为其高性能，gRPC更适合被用于系统内部组件的通信选择。比如微服务架构中，对外的服务采用了REST或者GraphQL的API，而内部微服务之间使用的是gRPC。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"}],"tags":[]},{"title":"","slug":"技术开发/Java/Java8新特性","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/Java/Java8新特性/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"Java8新特性 （转载自https://www.runoob.com/java/java8-new-features.html，具体内容见链接，非常详细实用） Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。 Java8 新增了非常多的特性，我们主要讨论以下几个： Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。 Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。 Date Time API − 加强对日期与时间的处理。 Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。 Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"技术开发/Java","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Java/"}],"tags":[]},{"title":"","slug":"技术开发/Golang/k8s配置文件详解","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/Golang/k8s配置文件详解/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Golang/k8s%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"k8s yaml文件yaml基础YAML是专门用来写配置文件的语言，非常简洁和强大，使用比json更方便。它实质上是一种通用的数据串行化格式。 YAML语法规则： 12345大小写敏感使用缩进表示层级关系缩进时不允许使用Tal键，只允许使用空格缩进的空格数目不重要，只要相同层级的元素左侧对齐即可”#” 表示注释，从这个字符一直到行尾，都会被解析器忽略 在Kubernetes中，只需要知道两种结构类型即可：Lists和Maps YAML Maps： Map顾名思义指的是字典，即一个Key:Value 的键值对信息。例如： 123apiVersion: v1kind: Pod 注：---为可选的分隔符 ，当需要在一个文件中定义多个结构的时候需要使用。上述内容表示有两个键apiVersion和kind，分别对应的值为v1和Pod。 Maps的value既能够对应字符串也能够对应一个Maps。例如： 123456apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: web List即列表，说白了就是数组，例如： 12345args -beijing -shanghai -shenzhen -guangzhou 当然Lists的子项也可以是Maps，Maps的子项也可以是List，例如： 123456789101112131415apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: webspec: containers: - name: front-end image: nginx ports: - containerPort: 80 - name: flaskapp-demo image: jcdemo/flaskapp ports: 8080 k8s yaml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172apiVersion: v1 #指定api版本，此值必须在kubectl apiversion中 kind: Pod #指定创建资源的角色/类型 metadata: #资源的元数据/属性 name: web04-pod #资源的名字，在同一个namespace中必须唯一 labels: #设定资源的标签，详情请见http://blog.csdn.net/liyingke112/article/details/77482384 k8s-app: apache version: v1 kubernetes.io/cluster-service: &quot;true&quot; annotations: #自定义注解列表 - name: String #自定义注解名字 spec:#specification of the resource content 指定该资源的内容 restartPolicy: Always #表明该容器一直运行，默认k8s的策略，在此容器退出后，会立即创建一个相同的容器 nodeSelector: #节点选择，先给主机打标签kubectl label nodes kube-node1 zone=node1 zone: node1 containers: - name: web04-pod #容器的名字 image: web:apache #容器使用的镜像地址 imagePullPolicy: Never #三个选择Always、Never、IfNotPresent，每次启动时检查和更新（从registery）images的策略， # Always，每次都检查 # Never，每次都不检查（不管本地是否有） # IfNotPresent，如果本地有就不检查，如果没有就拉取 command: [&#x27;sh&#x27;] #启动容器的运行命令，将覆盖容器中的Entrypoint,对应Dockefile中的ENTRYPOINT args: [&quot;$(str)&quot;] #启动容器的命令参数，对应Dockerfile中CMD参数 env: #指定容器中的环境变量 - name: str #变量的名字 value: &quot;/etc/run.sh&quot; #变量的值 resources: #资源管理，请求请见http://blog.csdn.net/liyingke112/article/details/77452630 requests: #容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行 cpu: 0.1 #CPU资源（核数），两种方式，浮点数或者是整数+m，0.1=100m，最少值为0.001核（1m） memory: 32Mi #内存使用量 limits: #资源限制 cpu: 0.5 memory: 32Mi ports: - containerPort: 80 #容器开放对外的端口 name: httpd #名称 protocol: TCP livenessProbe: #pod内容器健康检查的设置，详情请见http://blog.csdn.net/liyingke112/article/details/77531584 httpGet: #通过httpget检查健康，返回200-399之间，则认为容器正常 path: / #URI地址 port: 80 #host: 127.0.0.1 #主机地址 scheme: HTTP initialDelaySeconds: 180 #表明第一次检测在容器启动后多长时间后开始 timeoutSeconds: 5 #检测的超时时间 periodSeconds: 15 #检查间隔时间 #也可以用这种方法 #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常 # command: # - cat # - /tmp/health #也可以用这种方法 #tcpSocket: //通过tcpSocket检查健康 # port: number lifecycle: #生命周期管理 postStart: #容器运行之前运行的任务 exec: command: - &#x27;sh&#x27; - &#x27;yum upgrade -y&#x27; preStop: #容器关闭之前运行的任务 exec: command: [&#x27;service httpd stop&#x27;] volumeMounts: #详情请见http://blog.csdn.net/liyingke112/article/details/76577520 - name: volume #挂载设备的名字，与volumes[*].name 需要对应 mountPath: /data #挂载到容器的某个路径下 readOnly: True volumes: #定义一组挂载设备 - name: volume #定义一个挂载设备的名字 #meptyDir: &#123;&#125; hostPath: path: /opt #挂载设备类型为hostPath，路径为宿主机下的/opt,这里设备类型支持很多种 k8s 使用过程笔记如何进入kubernetes的一个pod123456类似于docker进入docker容器 ：docker exec -ti &lt;your-container-name&gt; /bin/sh进入pod：kubectl exec -ti &lt;your-pod-name&gt; -n &lt;your-namespace&gt; -- /bin/sh 关于k8s使用镜像创建pod的坑k8s默认从远程仓库中获取镜像，可以使用镜像获取策略从本地获取： 1234containers: - name: test image: nginx:1.7.9 #必须带上tag imagePullPolicy: Never Always 总是拉取镜像 IfNotPresent 本地有则使用本地镜像,不拉取 Never 只使用本地镜像，从不拉取，即使本地没有 如果省略imagePullPolicy 镜像tag为 :latest 策略为always ，否则 策略为 IfNotPresent","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Golang","slug":"技术开发/Golang","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Golang/"}],"tags":[]},{"title":"","slug":"技术开发/Python/REST风格理解","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/Python/REST风格理解/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Python/REST%E9%A3%8E%E6%A0%BC%E7%90%86%E8%A7%A3/","excerpt":"","text":"转载自 https://www.jianshu.com/p/6e8381c9b01d 一、什么是REST一句话来概括RESTful API(具有REST风格的API): 用URL定位资源，用HTTP动词（GET,HEAD,POST,PUT,PATCH,DELETE）描述操作，用响应状态码表示操作结果。 REST是一种软件架构风格，或者说是一种规范，其强调HTTP应当以资源为中心，并且规范了URI的风格；规范了HTTP请求动作（GET&#x2F;PUT&#x2F;POST&#x2F;DELETE&#x2F;HEAD&#x2F;OPTIONS）的使用，具有对应的语义。 核心概念包括： 资源（Resource）：在REST中，资源可以简单的理解为URI，表示一个网络实体。比如，&#x2F;users&#x2F;1&#x2F;name，对应id&#x3D;1的用户的属性name。既然资源是URI，就会具有以下特征：名词，代表一个资源；它对应唯一的一个资源，是资源的地址。 表现（Representation）：资源呈现出来的形式，比如上述URI返回的HTML或JSON，包括HTTP Header等； REST是一个无状态的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布REST服务，客户端通过URL来定位这些资源并通过HTTP协议来访问它们。","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"技术开发/Python","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Python/"}],"tags":[]},{"title":"","slug":"技术开发/Golang/为什么bk-cmdb不用go mod管理","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/技术开发/Golang/为什么bk-cmdb不用go mod管理/","link":"","permalink":"http://example.com/2022/12/13/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Golang/%E4%B8%BA%E4%BB%80%E4%B9%88bk-cmdb%E4%B8%8D%E7%94%A8go%20mod%E7%AE%A1%E7%90%86/","excerpt":"","text":"项目地址 https://github.com/Tencent/bk-cmdb 为什么不用官方推荐的 go mod 管理依赖呢？ bk-cmdb vendor下的一些依赖库都是有修改过的： vendor&#x2F;go.mongodb.org&#x2F;mongo-driver&#x2F;mongo&#x2F;session_exposer.go12345678910111213141516// CmdbPrepareCommitOrAbort set state to InProgress, so that we can commit with other// operation directly. otherwise mongodriver will do a false commitfunc CmdbPrepareCommitOrAbort(sess Session) &#123; i, ok := sess.(*sessionImpl) if !ok &#123; panic(&quot;the session is not type *sessionImpl&quot;) &#125; i.clientSession.SetState(2) i.didCommitAfterStart=false&#125;// CmdbContextWithSession set the session into context if context includes session infofunc CmdbContextWithSession(ctx context.Context, sess Session) SessionContext &#123; return contextWithSession(ctx, sess)&#125; 在mongo driver中添加了CmdbPrepareCommitOrAbort、 CmdbReloadSessio等方法 这些在官方库是没有的，如果切换 go mod,从官方源获取依赖，肯定是不行的 issue：https://github.com/Tencent/bk-cmdb/issues/4748 如果将修改后的官方库上传到github，应该可以解决go mod难切换的问题 会不会有版权问题？ 所以，尽量不要修改官方库","categories":[{"name":"技术开发","slug":"技术开发","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/"},{"name":"Golang","slug":"技术开发/Golang","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/Golang/"}],"tags":[]},{"title":"","slug":"生活点滴/git 笔记","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/生活点滴/git 笔记/","link":"","permalink":"http://example.com/2022/12/13/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/git%20%E7%AC%94%E8%AE%B0/","excerpt":"","text":"删除本地文件后从远程仓库获取问题在本地删除文件后，git pull从远程仓库获取，但是一直提示 up-to-date，无法获取被删除的文件。 原因：当前本地库处于另一个分支中，需将本分支发Head重置至master。 将本分支发Head重置至master: 12$ git checkout master $ git reset --hard 强行pull并覆盖本地文件 123$ git fetch --all $ git reset --hard origin/master $ git pull","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"}],"tags":[]},{"title":"life is strange","slug":"index","date":"2022-12-13T16:20:37.108Z","updated":"2022-12-13T16:20:37.108Z","comments":true,"path":"2022/12/13/index/","link":"","permalink":"http://example.com/2022/12/13/index/","excerpt":"","text":"","categories":[],"tags":[]}]}
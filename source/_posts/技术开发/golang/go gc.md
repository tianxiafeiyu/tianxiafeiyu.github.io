https://www.cnblogs.com/HinaChan/p/14842521.html

## GoGC机制
垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。

Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。

## 一、Go V1.3之前的标记-清除(mark and sweep)算法
此算法主要有两个主要的步骤：

1. 标记(Mark phase)：暂停程序业务逻辑, 找出不可达的对象，然后做上标记。
2. 清除(Sweep phase)：回收标记好的对象。

注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)。也就是说，这段时间程序会卡在哪儿。

第一步，暂停程序业务逻辑

第二步, 开始标记，程序找出它所有可达的对象，并做上标记。

第三步, 标记完了之后，然后开始清除未标记的对象。

第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。

缺点：
1. STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。
2. 标记需要扫描整个heap
3. 清除数据会产生heap碎片

Go V1.3 做了简单的优化,将STW提前, STW结束后再清除

## 二、Go V1.5的三色并发标记法
三色标记法 实际上就是通过三个阶段的标记来确定清除的对象都有哪些

第一步 , 就是只要是新创建的对象,默认的颜色都是标记为“白色”

第二步, 每次GC回收开始, 然后从根节点开始遍历所有对象（直接子节点），把遍历到的对象从白色集合放入“灰色”集合

第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合

第四步, 重复第三步, 直到灰色中无任何对象

第五步: 回收所有的白色标记表的对象. 也就是回收垃圾


有点类似于人群中找人：寻找所有小明的朋友（朋友的朋友也是朋友）：

一开始，所有的人都在房间A

从小明开始，找到小明的所有朋友，放置到房间B

找到房间B的人里所有在房间A的朋友，放置到房间B，找完的人放到房间C

继续上一步，知道房间B没有人为止

解散房间A的人

### 没有STW的三色标记法
屏障机制

我们让GC回收器,满足下面两种情况之一时,可保对象不丢失：

#### “强-弱” 三色不变式
- 强三色不变式：不存在黑色对象引用到白色对象的指针。
- 弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态。

### 插入屏障
具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

满足: 强三色不变式.(不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)

伪码如下:
```
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //1
  标记灰色(新下游对象ptr)   
  
  //2
  当前下游对象slot = 新下游对象ptr  				  
}
```
场景：
```
A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B， 
```
B被标记为灰色
这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中。

栈中对象会额外进行一次STW的染色操作

#### 删除屏障
具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。

满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)

伪代码：
```
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
  		标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }
  
  //2
  当前下游对象slot = 新下游对象ptr
}
```
场景：
```
A.添加下游对象(B, nil)   //A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)		 //A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
```


我的理解，插入屏障和删除屏障，都是在引用关系发生变化时，将引用关系被修改的对象置为灰色，保护起来，放置在cg期间被清理掉
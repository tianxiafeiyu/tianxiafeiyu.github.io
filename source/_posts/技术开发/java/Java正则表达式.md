一直都有接触正则表达式，但是都是照搬过来使用的程度，没有能系统的学习，也没有留下一些笔记，下次使用还需网上查找资料。此次正好稍微做点记录，方便遗忘后重拾。

### 1. 什么是正则表达式
正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

### 2. 正则表达式知识点
1. 一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 "Hello World" 字符串。  
2. java.util.regex 包主要包括以下三个类：
- Pattern 类：  
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

- Matcher 类：  
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

- PatternSyntaxException：  
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

以下实例中使用了正则表达式 .*runoob.* 用于查找字符串中是否包了 runoob 子串：
```
import java.util.regex.*;
 
class RegexExample1{
   public static void main(String args[]){
      String content = "I am noob " +
        "from runoob.com.";
 
      String pattern = ".*runoob.*";
 
      boolean isMatch = Pattern.matches(pattern, content);
      System.out.println("字符串中是否包含了 'runoob' 子字符串? " + isMatch);
   }
}
```

### 3. Java 正则表达式语法
在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 

在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 

所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。

字符 | 说明
 :-: |  :-: 
\ | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\\\"匹配"\\"，"\\("匹配"("。
^ | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与"\n"或"\r"之后的位置匹配。
$ | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与"\n"或"\r"之前的位置匹配。
* | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。
\+ | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。
? | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。
{n} | n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。
{n,} | n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。
{n,m} | m 和 n 是非负整数，其中 n <= m。匹配至少 n 次，至多 m 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。
? | 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。
x\|y | 匹配 x 或 y。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。
[xyz] | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。
[^xyz] | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。
[a-z] | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
[^a-z] | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。
\b | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。
\B | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。
\cx | 匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。
\d | 数字字符匹配。等效于 [0-9]。
\D | 非数字字符匹配。等效于 [^0-9]。
\f | 换页符匹配。等效于 \x0c 和 \cL。
\n | 换行符匹配。等效于 \x0a 和 \cJ。
\r | 匹配一个回车符。等效于 \x0d 和 \cM。
\s | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。
\S | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。
\t | 制表符匹配。与 \x09 和 \cI 等效。
\v | 垂直制表符匹配。与 \x0b 和 \cK 等效。
\w | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。
\W | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。

### 4. 正则表达式应用
1. 匹配字符串，如 手机号校验、邮箱校验
2. 切割字符串，提取字符串信息

场景：需要从一串字符串中提取出其中的主机ip信息
```
String str = "ip地址是127.0.0.1:8848，真的，不骗你"
Pattern pattern = Pattern.compile("(((localhost)|(\\d+.{1}\\d+.{1}\\d+.{1}\\d+))\\:{1}\\d+)");
Matcher matcher = pattern.matcher(str);
while (matcher.find()){ // 一定要先调用 find()函数！
    host = matcher.group();
  }
```

详情见： [菜鸟教程：Java 正则表达式](https://www.runoob.com/java/java-regular-expressions.html)  
&emsp;&emsp; &emsp; &ensp;[JAVA正则表达式：Pattern类与Matcher类详解](https://www.cnblogs.com/ggjucheng/p/3423731.html)
# Spring的单例模式与线程安全
## 前言
spring 管理的bean（@Component类注解标记的类并且由IOC容器注入），默认是单例的。声明为单例的bean，在spring容器中只会有一个实例化对象，存储在全局的map中，处理请求时，会先从缓存（map）中寻找对象，如果不存在才实例化一个对象并且缓存起来。也就是说，在处理多个请求中，使用的都是同一个对象。

> Spring提供了5种scope分别是singleton（单例）、prototype（原型）、request、session、global session。

## 单例bean的优势
- **减少了新生成实例的消耗**  
    新生成实例消耗包括两方面，第一，spring会通过反射或者cglib（动态代理）来生成bean实例这都是耗性能的操作，其次给对象分配内存也会涉及复杂算法。

- **减少jvm垃圾回收**  
    由于不会给每个请求都生成新的bean实例，所以自然回收的对象少了。
- **可以快速获取到bean**  
    单例bean除了第一次需要实例化外其余都是从缓存中获取，速度自然快。

## 单例bean的劣势
单例的bean一个很大的劣势就是他不能做到线程安全，由于所有请求都共享一个bean实例，所以这个bean要是有状态的一个bean的话可能在并发场景下出现问题，而原型的bean则不会有这样问题（但也有例外，比如他被单例bean依赖），因为给每个请求都新创建实例。

什么是有状态对象？什么是无状态对象？
- **有状态对象**：有实例变量可以标志其对象所处的状态。（有实例变量的对象，有存储数据能力）- 白话：有属性的对象
- **无状态对象**：无实例变量可以标志其对象所处的状态。（无实例变量的对象，无存储数据能力）- 白话：无属性的对象

## 结论
在编码时，需要注意把contoller,service等类设计成无状态的，不要随便把类交由spring管理（@Component注解）。

## spring多例的设置
前面有提到， Spring提供了5种scope分别是singleton、prototype、request、session、global session。可以添加类注解 `@Scope(prototype)` 来声明该类使用原型模式（每次调用都生成新实例）。

但是这个注解并不好用。

- 如果父类声明了原型模式，子类是单例模式，那么子类中的父类也是只有一个实例；

- 如果类的属性是原型模式，类是单例模式，那么该属性也会只有一个实例。

## 注意
因为spring管理bean是单例的特性，在操作外部资源时需要注意及时释放资源，否则资源将会长时间按得不到释放。